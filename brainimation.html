<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="cache-buster" content="20250929-v1">
    <title>BrainImation: Live EEG + P5.js Creative Coding</title>
    <meta name="description" content="Interactive brain-computer interface art platform using real-time EEG data from Muse headsets with live P5.js coding environment.">
    
    <!-- P5.js and required libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/addons/p5.sound.min.js"></script>
    
    <!-- Muse-js for Bluetooth EEG - LOCAL BROWSER BUNDLE -->
    <script src="./muse-browser.js"></script>
    
    <!-- Monaco Editor for live coding -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
    
    <style>
      :root {
        --bg: #0a0a0a;
        --bg-2: #1a1a1a;
        --text: #e0e0e0;
        --muted: #888;
        --accent: #ff6b9d;
        --accent-2: #4ecdc4;
        --success: #4caf50;
        --warning: #ff9800;
        --error: #f44336;
        --neural: rgba(78, 205, 196, 0.3);
      }

      * { box-sizing: border-box; }
      
      body {
        margin: 0;
        padding: 0;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        background: var(--bg);
        color: var(--text);
        overflow: hidden;
        height: 100vh;
      }

      .main-container {
        display: grid;
        grid-template-columns: 1fr 1000px 500px;
        grid-template-rows: 60px 1fr auto;
        height: 100vh;
        gap: 2px;
        background: var(--bg-2);
        overflow: hidden;
      }
      
      .main-container.hide-reference {
        grid-template-columns: 1fr 200px;
      }

      .header {
        grid-column: 1 / -1;
        background: var(--bg-2);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        border-bottom: 2px solid var(--accent);
      }

      .logo {
        font-size: 24px;
        font-weight: bold;
        background: linear-gradient(45deg, var(--accent), var(--accent-2));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .controls {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .btn {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-family: inherit;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.2s;
      }

      .btn-primary {
        background: var(--accent);
        color: white;
      }
      .btn-primary:hover { background: #e55a8a; }
      .btn-primary:disabled { 
        background: #666; 
        cursor: not-allowed; 
      }

      .btn-success {
        background: var(--success);
        color: white;
      }
      .btn-success:hover { background: #45a049; }

      .btn-secondary {
        background: var(--bg);
        color: var(--text);
        border: 1px solid var(--muted);
      }
      .btn-secondary:hover { background: var(--bg-2); }

      .status {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
      }

      .status-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--muted);
        animation: pulse 2s infinite;
      }
      .status-indicator.connected { background: var(--success); }
      .status-indicator.error { background: var(--error); }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }

      .canvas-container {
        background: #000;
        position: relative;
        overflow: hidden;
      }

      /* Fullscreen mode styling */
      .canvas-container:fullscreen {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .canvas-container:-webkit-full-screen {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .canvas-container:-moz-full-screen {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .canvas-container:-ms-fullscreen {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .code-panel {
        background: var(--bg-2);
        display: flex;
        flex-direction: column;
      }

      .panel-header {
        background: var(--bg);
        padding: 8px 12px;
        font-size: 12px;
        font-weight: 600;
        color: var(--accent-2);
        border-bottom: 1px solid var(--muted);
      }

      .code-editor {
        flex: 1;
        position: relative;
      }

      .eeg-data {
        background: var(--bg);
        border-top: 1px solid var(--muted);
        max-height: 250px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
      }

      .data-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
        padding: 12px;
      }

      .data-item {
        background: var(--bg-2);
        padding: 8px;
        border-radius: 4px;
        text-align: center;
        font-size: 11px;
      }

      .data-label {
        color: var(--muted);
        text-transform: uppercase;
        margin-bottom: 4px;
      }

      .data-value {
        font-size: 16px;
        font-weight: bold;
        color: var(--accent-2);
      }

      .wave-viz {
        grid-column: 1 / -1;
        height: 60px;
        background: var(--bg-2);
        border-radius: 4px;
        position: relative;
        overflow: hidden;
      }

      .examples-bar {
        background: var(--bg);
        padding: 8px 12px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 11px;
      }

      .example-selector {
        flex: 1;
        padding: 6px 10px;
        background: var(--bg-2);
        border: 1px solid var(--muted);
        border-radius: 4px;
        color: var(--text);
        font-family: inherit;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .example-selector:hover {
        border-color: var(--accent);
      }
      
      .example-selector:focus {
        outline: none;
        border-color: var(--accent);
        background: var(--bg);
      }
      
      .examples-label {
        color: var(--muted);
        white-space: nowrap;
      }


      .error-console {
        background: var(--bg);
        color: var(--error);
        padding: 8px 12px;
        font-size: 11px;
        border-top: 1px solid var(--error);
        max-height: 100px;
        overflow-y: auto;
        display: none;
      }

      .reference-panel {
        background: var(--bg-2);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        grid-row: 2 / 4;
      }
      
      .main-container.hide-reference .reference-panel {
        display: none;
      }
      
      .reference-tabs {
        display: flex;
        background: var(--bg);
        border-bottom: 1px solid var(--muted);
      }
      
      .reference-tab {
        padding: 8px 12px;
        cursor: pointer;
        font-size: 11px;
        border-bottom: 2px solid transparent;
        transition: all 0.2s;
        flex: 1;
        text-align: center;
      }
      
      .reference-tab:hover {
        background: var(--bg-2);
      }
      
      .reference-tab.active {
        border-bottom-color: var(--accent);
        color: var(--accent);
      }
      
      .reference-content {
        flex: 1;
        overflow-y: auto;
        padding: 12px;
        font-size: 11px;
      }
      
      .function-group {
        margin-bottom: 16px;
      }
      
      .function-group-title {
        color: var(--accent-2);
        font-weight: 600;
        margin-bottom: 6px;
        font-size: 12px;
      }
      
      .function-item {
        padding: 4px 8px;
        margin: 2px 0;
        background: var(--bg);
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.3s ease;
        border: 1px solid transparent;
        overflow: hidden;
      }
      
      .function-item:hover {
        background: var(--accent);
        color: white;
        border-color: var(--accent);
      }
      
      .function-name {
        font-family: 'Courier New', monospace;
        font-weight: 600;
        display: block;
        padding: 2px 0;
      }
      
      .function-tooltip {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
        padding: 0;
        margin: 0;
      }
      
      .function-item:hover .function-tooltip {
        max-height: 300px;
        padding-top: 8px;
        margin-top: 4px;
        border-top: 1px solid rgba(255,255,255,0.3);
      }
      
      .tooltip-signature {
        font-family: 'Courier New', monospace;
        color: var(--accent-2);
        margin-bottom: 4px;
        font-size: 10px;
        font-weight: 600;
        word-wrap: break-word;
      }
      
      .function-item:hover .tooltip-signature {
        color: white;
        opacity: 0.9;
      }
      
      .tooltip-description {
        color: var(--text);
        line-height: 1.5;
        font-size: 10px;
        word-wrap: break-word;
      }
      
      .function-item:hover .tooltip-description {
        color: white;
        opacity: 0.85;
      }
      
      .ai-assistant {
        background: var(--bg);
        padding: 12px;
        border-top: 2px solid var(--accent);
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      
      .ai-input {
        background: var(--bg-2);
        border: 1px solid var(--muted);
        color: var(--text);
        padding: 8px;
        border-radius: 4px;
        font-family: inherit;
        font-size: 11px;
        resize: vertical;
        min-height: 60px;
      }
      
      .ai-input:focus {
        outline: none;
        border-color: var(--accent);
      }
      
      .ai-buttons {
        display: flex;
        gap: 6px;
      }
      
      .ai-status {
        font-size: 10px;
        color: var(--muted);
        font-style: italic;
      }
      
      .toggle-reference {
        background: var(--bg);
        color: var(--accent-2);
        border: 1px solid var(--accent-2);
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s;
      }
      
      .toggle-reference:hover {
        background: var(--accent-2);
        color: var(--bg);
      }

      @media (max-width: 1200px) {
        .main-container {
          grid-template-columns: 1fr 400px;
        }
        .reference-panel {
          display: none;
        }
      }

      @media (max-width: 768px) {
        .main-container {
          grid-template-columns: 1fr;
          grid-template-rows: 60px 300px 1fr auto;
          overflow-y: auto;
        }
        .code-panel {
          grid-row: 3;
          min-height: 200px;
        }
        .canvas-container {
          grid-row: 2;
        }
        .eeg-data {
          max-height: 200px;
        }
        .reference-panel {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="main-container">
      <!-- Header -->
      <div class="header">
        <div class="logo">🧠 BrainImation</div>
        <div class="controls">
          <div style="display:flex;align-items:center;gap:8px;margin-right:16px;font-size:12px;">
            <a href="./index.html" style="color: var(--accent-2); text-decoration: none;">Course Home</a>
            <span style="color: var(--muted);">|</span>
            <a href="./lecture3.html" style="color: var(--accent-2); text-decoration: none;">← Lecture 3</a>
          </div>
          <div class="status">
            <div class="status-indicator" id="muse-status"></div>
            <span id="status-text">Disconnected</span>
          </div>
          <button class="btn btn-primary" id="connect-btn">Connect Muse</button>
          <button class="btn btn-secondary" id="simulate-btn">Simulate Data</button>
          <button class="btn btn-success" id="run-btn">Run Code</button>
          <button class="btn btn-secondary" id="save-btn">💾 Save</button>
          <button class="btn btn-secondary" id="load-btn">📁 Load</button>
          <button class="btn btn-secondary" id="reload-btn" disabled>🔄 Reload</button>
          <button class="btn btn-secondary" id="fullscreen-btn">Fullscreen</button>
          <button class="toggle-reference" id="toggle-reference-btn">📖 Reference</button>
          <input type="file" id="file-input" accept=".js" style="display: none;">
        </div>
      </div>

      <!-- Canvas -->
      <div class="canvas-container" id="canvas-container"></div>

      <!-- Code Editor Panel -->
      <div class="code-panel">
        <div class="panel-header">Live P5.js Code Editor</div>
        <div class="examples-bar">
          <label for="example-selector" class="examples-label">Example Animations:</label>
          <select id="example-selector" class="example-selector">
            <option value="">-- Select an Example --</option>
            <optgroup label="Getting Started">
              <option value="basic">Basic Animation</option>
              <option value="basicShapes">Basic Shapes</option>
              <option value="functionExample">Function Example</option>
            </optgroup>
            <optgroup label="Brain Wave Visualizations">
              <option value="alpha">Alpha Waves</option>
              <option value="waves">Wave Visualization</option>
              <option value="BasicFrequencyBands">Basic Frequency Bands</option>
              <option value="bandOrbitz">Band Orbitz</option>
              <option value="piWedges">Pi Wedges</option>
              <option value="spectra">Spectra</option>
            </optgroup>
            <optgroup label="Attention & Meditation">
              <option value="attention">Attention Meter</option>
              <option value="mandala">Neural Mandala</option>
            </optgroup>
            <optgroup label="Particle Systems">
              <option value="particles">Brain Particles</option>
              <option value="ColourBalls">Colour Balls</option>
              <option value="MultipleBalls">Multiple Balls</option>
            </optgroup>
            <optgroup label="3D & Advanced">
              <option value="3dTorus">3D Torus</option>
              <option value="AlphaSnake">Alpha Snake</option>
              <option value="SplineBounce">Spline Bounce</option>
            </optgroup>
            <optgroup label="Drawing & Interaction">
              <option value="BrainDraw">Brain Draw</option>
              <option value="bouncingLine">Bouncing Line</option>
              <option value="ghostLines">Ghost Lines</option>
            </optgroup>
            <optgroup label="Raw EEG Data">
              <option value="eegtrace">EEG Trace</option>
              <option value="multichannel">Multi-Channel EEG</option>
              <option value="epochs">Epoch View</option>
            </optgroup>
          </select>
        </div>
        <div class="code-editor" id="code-editor"></div>
        <div class="error-console" id="error-console"></div>
      </div>

      <!-- Reference Panel -->
      <div class="reference-panel" id="reference-panel">
        <div class="reference-tabs">
          <div class="reference-tab active" data-tab="p5js">P5.js</div>
          <div class="reference-tab" data-tab="eeg">EEG Data</div>
          <div class="reference-tab" data-tab="ai">AI Helper</div>
        </div>
        
        <div class="reference-content" id="reference-content">
          <!-- Content will be dynamically loaded -->
        </div>
        
        <!-- AI Assistant at bottom -->
        <div class="ai-assistant" id="ai-assistant" style="display: none;">
          <div style="font-size: 12px; font-weight: 600; color: var(--accent);">🤖 AI Code Assistant</div>
          <textarea class="ai-input" id="ai-prompt" placeholder="Describe what you want to change or add...&#10;e.g., 'Add a particle system that responds to alpha waves'&#10;'Change the colors to be more vibrant'&#10;'Make the animation slower'"></textarea>
          <div class="ai-buttons">
            <button class="btn btn-primary" id="ai-generate-btn" style="flex: 1;">Generate Code</button>
            <button class="btn btn-secondary" id="ai-config-btn">⚙️</button>
          </div>
          <div class="ai-status" id="ai-status">Configure API key to use AI features</div>
        </div>
      </div>

      <!-- EEG Data Display -->
      <div class="eeg-data">
        <div class="panel-header">Real-time Brain Data</div>
        <div class="data-grid">
          <div class="data-item">
            <div class="data-label">Alpha</div>
            <div class="data-value" id="alpha-value">0.0</div>
          </div>
          <div class="data-item">
            <div class="data-label">Beta</div>
            <div class="data-value" id="beta-value">0.0</div>
          </div>
          <div class="data-item">
            <div class="data-label">Theta</div>
            <div class="data-value" id="theta-value">0.0</div>
          </div>
          <div class="data-item">
            <div class="data-label">Delta</div>
            <div class="data-value" id="delta-value">0.0</div>
          </div>
          <div class="wave-viz" id="wave-viz"></div>
        </div>
        
        <!-- Simulation Controls -->
        <div id="sim-controls" style="display: none; padding: 12px; border-top: 1px solid var(--muted); background: var(--bg-2);">
          <div style="font-size: 11px; color: var(--accent-2); margin-bottom: 8px; font-weight: 600;">🎛️ SIMULATION CONTROLS</div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
            <div>
              <label style="color: var(--muted);">Attention:</label>
              <input type="range" id="sim-attention" min="0" max="1" step="0.1" value="0.5" 
                     style="width: 100%; margin-top: 2px;">
              <span id="sim-attention-val" style="color: var(--accent-2);">0.5</span>
            </div>
            <div>
              <label style="color: var(--muted);">Meditation:</label>
              <input type="range" id="sim-meditation" min="0" max="1" step="0.1" value="0.3" 
                     style="width: 100%; margin-top: 2px;">
              <span id="sim-meditation-val" style="color: var(--accent-2);">0.3</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ============================================
      // BRAINIMATION - MAIN APPLICATION
      // ============================================
      console.log('🔍 BrainImation Loading...');
      console.log('📍 muse-browser.js should be loaded by now');
      console.log('window.muse:', window.muse);
      console.log('window.muse.MuseClient:', window.muse?.MuseClient);
      
      // Function to check library loading
      function checkMuseLibrary() {
        console.log('\n🔍 === MUSE LIBRARY DEBUG CHECK ===');
        console.log('1. window.muse:', window.muse);
        console.log('2. typeof window.muse:', typeof window.muse);
        
        if (window.muse) {
          console.log('3. window.muse.MuseClient:', window.muse.MuseClient);
          console.log('4. typeof window.muse.MuseClient:', typeof window.muse.MuseClient);
          console.log('5. All muse properties:', Object.keys(window.muse));
          
          if (window.muse.MuseClient) {
            console.log('✅ muse-js library loaded successfully!');
            try {
              const testClient = new window.muse.MuseClient();
              console.log('✅ Test client created:', testClient);
              return true;
            } catch (e) {
              console.error('❌ Error creating test client:', e);
              return false;
            }
          } else {
            console.error('❌ window.muse exists but MuseClient is missing!');
            return false;
          }
        } else {
          console.error('❌ window.muse is undefined - library not loaded!');
          console.log('💡 This could mean:');
          console.log('   - CDN is blocked or unreachable');
          console.log('   - Script tag failed to load');
          console.log('   - Content Security Policy blocking');
          console.log('   - CORS or network issue');
          return false;
        }
      }
      
      // Check immediately
      console.log('\n📊 Immediate check:');
      checkMuseLibrary();
      
      // Check again after a delay (scripts might still be loading)
      setTimeout(() => {
        console.log('\n📊 Check after 500ms:');
        const loaded = checkMuseLibrary();
        
        if (!loaded) {
          console.error('\n⚠️ === MUSE LIBRARY STILL NOT LOADED ===');
          console.log('🔧 TROUBLESHOOTING STEPS:');
          console.log('1. Check browser console for network errors');
          console.log('2. Try opening https://unpkg.com/muse-js@4.0.3/dist/muse.min.js in a new tab');
          console.log('3. Check if you have internet connection');
          console.log('4. Try opening developer tools > Network tab > refresh page');
          console.log('5. Look for any Content Security Policy errors');
        }
      }, 500);
      
      // Check after page fully loaded
      window.addEventListener('load', () => {
        console.log('\n📊 Check after window.onload:');
        checkMuseLibrary();
      });
      
      // Global variables for EEG data access in p5 sketches
      let eegData = {
        // Frequency bands (existing)
        alpha: 0,
        beta: 0,
        theta: 0,
        delta: 0,
        gamma: 0,
        
        // Current samples (existing - keep for compatibility)
        raw: [0, 0, 0, 0], // TP9, AF7, AF8, TP10 current values
        
        // Enhanced raw data access (NEW)
        rawHistory: {
          TP9: [],    // Array of recent samples
          AF7: [],    // Array of recent samples  
          AF8: [],    // Array of recent samples
          TP10: []    // Array of recent samples
        },
        
        // Configuration
        historyLength: 1000,  // ~4 seconds at 256Hz
        sampleRate: 256,      // Samples per second
        
        // Derived metrics (existing)
        attention: 0,
        meditation: 0,
        connected: false,
        
        // Helper functions for accessing raw data in animations
        getRawChannel: function(channel, numSamples = 100) {
          const channelData = this.rawHistory[channel] || [];
          return channelData.slice(-numSamples);
        },
        
        getAllChannels: function(numSamples = 100) {
          return {
            TP9: this.getRawChannel('TP9', numSamples),
            AF7: this.getRawChannel('AF7', numSamples),
            AF8: this.getRawChannel('AF8', numSamples),
            TP10: this.getRawChannel('TP10', numSamples)
          };
        },
        
        getChannelNames: function() {
          return ['TP9', 'AF7', 'AF8', 'TP10'];
        },
        
        // Get the most recent N samples across all channels
        getRecentEpoch: function(numSamples = 100) {
          const channels = this.getAllChannels(numSamples);
          const epoch = [];
          
          // Transpose data so each time point has all 4 channels
          for (let i = 0; i < numSamples; i++) {
            epoch.push([
              channels.TP9[i] || 0,
              channels.AF7[i] || 0,
              channels.AF8[i] || 0,
              channels.TP10[i] || 0
            ]);
          }
          return epoch;
        }
      };

      // EEG Data Simulator for demonstration purposes
      class EEGSimulator {
        constructor() {
          this.isRunning = false;
          this.startTime = Date.now();
          this.updateInterval = null;
          this.baseAttention = 0.5;
          this.baseMeditation = 0.3;
          this.noiseLevel = 0.1;
        }

        start() {
          this.isRunning = true;
          this.startTime = Date.now();
          
          // Update data every 50ms (20 Hz)
          this.updateInterval = setInterval(() => {
            this.generateData();
          }, 50);
          
          console.log('EEG Simulation started');
        }

        stop() {
          this.isRunning = false;
          if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
          }
          console.log('EEG Simulation stopped');
        }

        setAttention(value) {
          this.baseAttention = parseFloat(value);
        }

        setMeditation(value) {
          this.baseMeditation = parseFloat(value);
        }

        generateData() {
          const time = (Date.now() - this.startTime) / 1000; // seconds
          
          // Generate realistic brain wave patterns with some natural variation
          const noise = () => (Math.random() - 0.5) * this.noiseLevel;
          
          // Alpha waves (8-12 Hz) - stronger during meditation/relaxed attention
          const alphaBase = this.baseMeditation * 0.8 + 0.1;
          eegData.alpha = Math.max(0, Math.min(1, 
            alphaBase + Math.sin(time * 10) * 0.1 + noise()
          ));
          
          // Beta waves (13-30 Hz) - stronger during active attention/concentration
          const betaBase = this.baseAttention * 0.7 + 0.2;
          eegData.beta = Math.max(0, Math.min(1, 
            betaBase + Math.sin(time * 20) * 0.15 + noise()
          ));
          
          // Theta waves (4-8 Hz) - stronger during deep meditation/creativity
          const thetaBase = this.baseMeditation * 0.6 + 0.1;
          eegData.theta = Math.max(0, Math.min(1, 
            thetaBase + Math.sin(time * 6) * 0.12 + noise()
          ));
          
          // Delta waves (0.5-4 Hz) - low during awake states
          eegData.delta = Math.max(0, Math.min(1, 
            0.1 + Math.sin(time * 2) * 0.05 + noise()
          ));
          
          // Gamma waves (30+ Hz) - bursts during high-level cognition
          eegData.gamma = Math.max(0, Math.min(1, 
            0.2 + Math.sin(time * 40) * this.baseAttention * 0.3 + noise()
          ));
          
          // Generate realistic raw EEG samples for each channel
          const channels = ['TP9', 'AF7', 'AF8', 'TP10'];
          for (let i = 0; i < 4; i++) {
            const channel = channels[i];
            
            // Create realistic EEG signal combining multiple frequency components
            let sample = 0;
            
            // Alpha component (8-12 Hz)
            sample += Math.sin(time * 2 * Math.PI * (9 + i * 0.5)) * eegData.alpha * 30;
            
            // Beta component (15-25 Hz)  
            sample += Math.sin(time * 2 * Math.PI * (18 + i * 1.5)) * eegData.beta * 20;
            
            // Theta component (4-8 Hz)
            sample += Math.sin(time * 2 * Math.PI * (6 + i * 0.3)) * eegData.theta * 25;
            
            // Delta component (1-4 Hz)
            sample += Math.sin(time * 2 * Math.PI * (2 + i * 0.2)) * eegData.delta * 40;
            
            // Gamma component (30-40 Hz)
            sample += Math.sin(time * 2 * Math.PI * (35 + i * 2)) * eegData.gamma * 10;
            
            // Add some 1/f noise and artifacts
            sample += noise() * 15; // High-frequency noise
            sample += Math.sin(time * 2 * Math.PI * 0.1) * 5; // Slow drift
            
            // Occasional "blink" artifacts (more prominent in frontal channels)
            if (i >= 1 && i <= 2 && Math.random() < 0.001) { // AF7, AF8
              sample += (Math.random() - 0.5) * 200;
            }
            
            // Store current sample for compatibility
            eegData.raw[i] = sample;
            
            // Add to history buffer
            if (!eegData.rawHistory[channel]) {
              eegData.rawHistory[channel] = [];
            }
            eegData.rawHistory[channel].push(sample);
            
            // Maintain buffer size
            if (eegData.rawHistory[channel].length > eegData.historyLength) {
              eegData.rawHistory[channel] = eegData.rawHistory[channel].slice(-eegData.historyLength);
            }
          }
          
          // Calculate derived metrics
          eegData.attention = Math.max(0, Math.min(1, 
            this.baseAttention + Math.sin(time * 0.5) * 0.1 + noise() * 0.05
          ));
          
          eegData.meditation = Math.max(0, Math.min(1, 
            this.baseMeditation + Math.cos(time * 0.3) * 0.1 + noise() * 0.05
          ));
          
          eegData.connected = true;
          this.updateDataDisplay();
        }

        updateDataDisplay() {
          document.getElementById('alpha-value').textContent = eegData.alpha.toFixed(2);
          document.getElementById('beta-value').textContent = eegData.beta.toFixed(2);
          document.getElementById('theta-value').textContent = eegData.theta.toFixed(2);
          document.getElementById('delta-value').textContent = eegData.delta.toFixed(2);
        }
      }

      // Muse connection and data processing
      class MuseEEGManager {
        constructor() {
          this.muse = null;
          this.isConnected = false;
          this.dataBuffer = [];
          this.samplingRate = 256;
          this.bufferSize = 256; // 1 second of data
          this.subscriptions = [];
        }

        async connect() {
          try {
            console.log('\n🔌 === ATTEMPTING TO CONNECT TO MUSE ===');
            
            // First, verify the library is loaded
            console.log('Step 1: Checking if muse-js library is loaded...');
            if (!window.muse) {
              throw new Error('muse-js library not loaded! window.muse is undefined. Check browser console for loading errors.');
            }
            
            if (!window.muse.MuseClient) {
              throw new Error('MuseClient not found in muse-js library! window.muse.MuseClient is undefined.');
            }
            
            console.log('✅ muse-js library is loaded');
            console.log('Step 2: Creating MuseClient instance...');
            
            // Create a new MuseClient instance
            // When loaded from unpkg, muse-js exports as window.muse
            this.muse = new window.muse.MuseClient();
            console.log('✅ MuseClient created:', this.muse);
            
            // Enable PPG if available (for better compatibility)
            this.muse.enablePpg = true;
            
            // Connect to the device (this will show the pairing dialog)
            console.log('Requesting device connection...');
            await this.muse.connect();
            console.log('Device connected, setting up subscriptions...');
            
            // Set up subscriptions BEFORE starting the stream
            // This is crucial for proper data reception
            const eegSubscription = this.muse.eegReadings.subscribe(reading => {
              this.processEEGReading(reading);
            });
            this.subscriptions.push(eegSubscription);

            // Subscribe to accelerometer for movement detection (optional)
            const accelSubscription = this.muse.accelerometerData.subscribe(accel => {
              // Could add movement-based interactions here
            });
            this.subscriptions.push(accelSubscription);

            // Subscribe to telemetry (battery level, temperature, etc.)
            const telemetrySubscription = this.muse.telemetryData.subscribe(telemetry => {
              if (telemetry.batteryLevel !== undefined) {
                console.log(`🔋 Battery: ${telemetry.batteryLevel.toFixed(1)}%`);
              }
            });
            this.subscriptions.push(telemetrySubscription);

            // Subscribe to connection status
            const statusSubscription = this.muse.connectionStatus.subscribe(status => {
              console.log('📡 Connection status:', status);
              if (!status) {
                console.warn('Connection lost!');
                this.isConnected = false;
                eegData.connected = false;
                this.updateStatus('Connection lost', 'error');
              }
            });
            this.subscriptions.push(statusSubscription);

            // Now start the data stream
            console.log('Starting data stream...');
            await this.muse.start();
            
            this.isConnected = true;
            eegData.connected = true;
            this.updateStatus('Connected to Muse', 'connected');

            console.log('Muse connected successfully and streaming data');
            
          } catch (error) {
            console.error('Failed to connect to Muse:', error);
            this.isConnected = false;
            eegData.connected = false;
            
            // Provide more detailed error messages
            let errorMsg = 'Connection failed';
            if (error.message && error.message.includes('cancelled')) {
              errorMsg = 'Connection cancelled by user';
            } else if (error.message && error.message.includes('GATT')) {
              errorMsg = 'Bluetooth connection failed';
            } else if (error.message) {
              errorMsg = `Connection failed: ${error.message}`;
            }
            
            this.updateStatus(errorMsg, 'error');
            throw error;
          }
        }

        processEEGReading(reading) {
          // Log first few readings to confirm data flow
          if (this.dataBuffer.length < 5) {
            console.log(`📊 EEG data received from ${reading.electrode}:`, 
                       reading.samples.length, 'samples');
          }
          
          // Add to buffer for frequency analysis
          this.dataBuffer.push({
            electrode: reading.electrode,
            samples: reading.samples,
            timestamp: Date.now()
          });

          // Keep buffer size manageable
          if (this.dataBuffer.length > this.bufferSize * 4) { // 4 electrodes
            this.dataBuffer = this.dataBuffer.slice(-this.bufferSize * 4);
          }

          // Update raw values for immediate access (compatibility)
          const electrodeIndex = ['TP9', 'AF7', 'AF8', 'TP10'].indexOf(reading.electrode);
          if (electrodeIndex !== -1 && reading.samples.length > 0) {
            eegData.raw[electrodeIndex] = reading.samples[reading.samples.length - 1];
          }

          // NEW: Add ALL samples to raw history for time-series access
          const electrode = reading.electrode;
          if (!eegData.rawHistory[electrode]) {
            eegData.rawHistory[electrode] = [];
          }
          
          // Add all samples from this reading (usually 12 samples per packet)
          eegData.rawHistory[electrode].push(...reading.samples);
          
          // Maintain buffer size (keep last N samples)
          if (eegData.rawHistory[electrode].length > eegData.historyLength) {
            eegData.rawHistory[electrode] = eegData.rawHistory[electrode].slice(-eegData.historyLength);
          }

          // Calculate frequency bands every few samples
          if (this.dataBuffer.length % 32 === 0) {
            this.calculateFrequencyBands();
          }
          
          // Update status to show data is flowing (every 100 packets)
          if (this.dataBuffer.length % 100 === 0) {
            const dataRate = (this.dataBuffer.length / 4).toFixed(0); // packets per electrode
            this.updateStatus(`Connected (${dataRate} packets/ch)`, 'connected');
          }
        }

        calculateFrequencyBands() {
          // Simple frequency band calculation
          // In a real implementation, you'd use FFT
          const recentData = this.dataBuffer.slice(-64); // Last 64 samples per electrode
          
          if (recentData.length < 64) return;

          // Group by electrode
          const electrodeData = { TP9: [], AF7: [], AF8: [], TP10: [] };
          recentData.forEach(reading => {
            if (electrodeData[reading.electrode]) {
              electrodeData[reading.electrode].push(...reading.samples);
            }
          });

          // Calculate power in different bands (simplified)
          Object.keys(electrodeData).forEach(electrode => {
            const samples = electrodeData[electrode].slice(-64);
            if (samples.length >= 64) {
              // Simplified band power calculation
              const variance = this.calculateVariance(samples);
              const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
              
              // Update frequency bands (this is a simplified approach)
              eegData.alpha = Math.max(0, Math.min(1, variance * 0.1));
              eegData.beta = Math.max(0, Math.min(1, Math.abs(mean) * 0.05));
              eegData.theta = Math.max(0, Math.min(1, variance * 0.05));
              eegData.delta = Math.max(0, Math.min(1, variance * 0.02));
              
              // Calculate attention and meditation (simplified)
              eegData.attention = Math.max(0, Math.min(1, (eegData.beta + eegData.gamma) / 2));
              eegData.meditation = Math.max(0, Math.min(1, (eegData.alpha + eegData.theta) / 2));
            }
          });

          eegData.connected = this.isConnected;
          this.updateDataDisplay();
        }

        calculateVariance(samples) {
          const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
          const variance = samples.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / samples.length;
          return Math.sqrt(variance);
        }

        updateStatus(text, status) {
          document.getElementById('status-text').textContent = text;
          const indicator = document.getElementById('muse-status');
          indicator.className = `status-indicator ${status}`;
        }

        updateDataDisplay() {
          document.getElementById('alpha-value').textContent = eegData.alpha.toFixed(2);
          document.getElementById('beta-value').textContent = eegData.beta.toFixed(2);
          document.getElementById('theta-value').textContent = eegData.theta.toFixed(2);
          document.getElementById('delta-value').textContent = eegData.delta.toFixed(2);
        }

        disconnect() {
          console.log('Disconnecting from Muse...');
          
          // Unsubscribe from all subscriptions
          if (this.subscriptions && this.subscriptions.length > 0) {
            console.log(`Unsubscribing from ${this.subscriptions.length} subscriptions`);
            this.subscriptions.forEach(sub => {
              try {
                sub.unsubscribe();
              } catch (e) {
                console.warn('Error unsubscribing:', e);
              }
            });
            this.subscriptions = [];
          }
          
          // Disconnect the device
          if (this.muse) {
            try {
              this.muse.disconnect();
              console.log('Muse disconnected');
            } catch (e) {
              console.warn('Error during disconnect:', e);
            }
            this.muse = null;
          }
          
          this.isConnected = false;
          eegData.connected = false;
          this.updateStatus('Disconnected', '');
        }
      }

      // P5.js Function Reference Database
      const p5Reference = {
        'Drawing': {
          'ellipse': {
            signature: 'ellipse(x, y, width, [height])',
            description: 'Draws an ellipse (oval) to the screen. By default, the first two parameters set the location, and the third and fourth parameters set the shape\'s width and height.'
          },
          'circle': {
            signature: 'circle(x, y, diameter)',
            description: 'Draws a circle to the screen. A circle is a simple closed shape, by default drawn from the center point.'
          },
          'rect': {
            signature: 'rect(x, y, width, height, [tl], [tr], [br], [bl])',
            description: 'Draws a rectangle to the screen. Optional parameters for rounded corners.'
          },
          'square': {
            signature: 'square(x, y, size, [tl], [tr], [br], [bl])',
            description: 'Draws a square to the screen. A square is a four-sided shape with equal sides.'
          },
          'triangle': {
            signature: 'triangle(x1, y1, x2, y2, x3, y3)',
            description: 'Draws a triangle to the screen. A triangle is a plane created by connecting three points.'
          },
          'quad': {
            signature: 'quad(x1, y1, x2, y2, x3, y3, x4, y4)',
            description: 'Draws a quadrilateral (four-sided polygon) to the screen.'
          },
          'line': {
            signature: 'line(x1, y1, x2, y2)',
            description: 'Draws a line (a direct path between two points) to the screen.'
          },
          'point': {
            signature: 'point(x, y)',
            description: 'Draws a point, a coordinate in space at the dimension of one pixel.'
          },
          'arc': {
            signature: 'arc(x, y, w, h, start, stop, [mode])',
            description: 'Draws an arc to the screen. Arcs are drawn along the outer edge of an ellipse.'
          }
        },
        'Color': {
          'background': {
            signature: 'background(color) or background(r, g, b, [a])',
            description: 'Sets the color used for the background. Default is light gray.'
          },
          'fill': {
            signature: 'fill(color) or fill(r, g, b, [a])',
            description: 'Sets the color used to fill shapes.'
          },
          'stroke': {
            signature: 'stroke(color) or stroke(r, g, b, [a])',
            description: 'Sets the color used to draw lines and borders around shapes.'
          },
          'noFill': {
            signature: 'noFill()',
            description: 'Disables filling geometry. If both noStroke() and noFill() are called, nothing will be drawn.'
          },
          'noStroke': {
            signature: 'noStroke()',
            description: 'Disables drawing the stroke (outline).'
          },
          'color': {
            signature: 'color(gray, [alpha]) or color(r, g, b, [a])',
            description: 'Creates a color object. Can be used with fill(), stroke(), and background().'
          },
          'lerpColor': {
            signature: 'lerpColor(c1, c2, amt)',
            description: 'Blends two colors to find a third color between them. The amt parameter is between 0.0 and 1.0.'
          },
          'colorMode': {
            signature: 'colorMode(mode, [max1], [max2], [max3], [maxA])',
            description: 'Changes the way p5.js interprets color data. Modes: RGB or HSB.'
          }
        },
        'Transform': {
          'translate': {
            signature: 'translate(x, y)',
            description: 'Specifies an amount to displace objects within the display window.'
          },
          'rotate': {
            signature: 'rotate(angle)',
            description: 'Rotates shapes around the origin (0,0). Angle should be in radians unless angleMode(DEGREES) is used.'
          },
          'scale': {
            signature: 'scale(s) or scale(x, y)',
            description: 'Increases or decreases the size of shapes by expanding and contracting vertices.'
          },
          'push': {
            signature: 'push()',
            description: 'Saves the current drawing style settings and transformations.'
          },
          'pop': {
            signature: 'pop()',
            description: 'Restores the previous drawing style settings and transformations.'
          }
        },
        'Math': {
          'map': {
            signature: 'map(value, start1, stop1, start2, stop2)',
            description: 'Re-maps a number from one range to another.'
          },
          'random': {
            signature: 'random([min], [max]) or random(choices)',
            description: 'Returns a random floating-point number or element from an array.'
          },
          'noise': {
            signature: 'noise(x, [y], [z])',
            description: 'Returns the Perlin noise value at specified coordinates. Creates smooth random values.'
          },
          'noiseSeed': {
            signature: 'noiseSeed(seed)',
            description: 'Sets the seed value for noise(). Use same seed for consistent noise patterns.'
          },
          'randomSeed': {
            signature: 'randomSeed(seed)',
            description: 'Sets the seed value for random(). Use same seed for consistent random values.'
          },
          'constrain': {
            signature: 'constrain(n, low, high)',
            description: 'Constrains a value between a minimum and maximum value.'
          },
          'lerp': {
            signature: 'lerp(start, stop, amt)',
            description: 'Calculates a number between two numbers at a specific increment.'
          },
          'dist': {
            signature: 'dist(x1, y1, x2, y2)',
            description: 'Calculates the distance between two points.'
          }
        },
        'Control': {
          'loop': {
            signature: 'loop()',
            description: 'Causes draw() to execute continuously. By default, draw() loops.'
          },
          'noLoop': {
            signature: 'noLoop()',
            description: 'Stops draw() from continuously executing. Can restart with loop() or redraw().'
          },
          'redraw': {
            signature: 'redraw([n])',
            description: 'Executes draw() one time. Can specify number of times to redraw.'
          },
          'frameRate': {
            signature: 'frameRate([fps])',
            description: 'Sets the number of frames per second or gets the current framerate.'
          }
        },
        'Text': {
          'text': {
            signature: 'text(str, x, y, [width], [height])',
            description: 'Draws text to the screen at the specified position.'
          },
          'textAlign': {
            signature: 'textAlign(horizAlign, [vertAlign])',
            description: 'Sets the current alignment for drawing text. Values: LEFT, CENTER, RIGHT, TOP, BOTTOM.'
          },
          'textSize': {
            signature: 'textSize(size)',
            description: 'Sets the size of the text in pixels.'
          },
          'textWidth': {
            signature: 'textWidth(str)',
            description: 'Calculates and returns the width of any character or text string.'
          }
        }
      };

      // EEG Data Reference
      const eegReference = {
        'Frequency Bands': {
          'eegData.alpha': {
            signature: 'eegData.alpha (0.0 - 1.0)',
            description: 'Alpha waves (8-12 Hz). Higher during relaxation, meditation, and eyes closed.'
          },
          'eegData.beta': {
            signature: 'eegData.beta (0.0 - 1.0)',
            description: 'Beta waves (13-30 Hz). Higher during active thinking, focus, and concentration.'
          },
          'eegData.theta': {
            signature: 'eegData.theta (0.0 - 1.0)',
            description: 'Theta waves (4-8 Hz). Higher during deep meditation, creativity, and drowsiness.'
          },
          'eegData.delta': {
            signature: 'eegData.delta (0.0 - 1.0)',
            description: 'Delta waves (0.5-4 Hz). Higher during deep sleep (low when awake).'
          },
          'eegData.gamma': {
            signature: 'eegData.gamma (0.0 - 1.0)',
            description: 'Gamma waves (30+ Hz). Associated with high-level cognition and information processing.'
          }
        },
        'Derived Metrics': {
          'eegData.attention': {
            signature: 'eegData.attention (0.0 - 1.0)',
            description: 'Attention level derived from beta and gamma activity.'
          },
          'eegData.meditation': {
            signature: 'eegData.meditation (0.0 - 1.0)',
            description: 'Meditation/relaxation level derived from alpha and theta activity.'
          }
        },
        'Raw Data Access': {
          'eegData.getRawChannel': {
            signature: 'eegData.getRawChannel(channel, numSamples)',
            description: 'Get recent raw EEG samples from a channel. Channels: "TP9", "AF7", "AF8", "TP10".'
          },
          'eegData.getAllChannels': {
            signature: 'eegData.getAllChannels(numSamples)',
            description: 'Get recent samples from all 4 channels as an object.'
          },
          'eegData.getRecentEpoch': {
            signature: 'eegData.getRecentEpoch(numSamples)',
            description: 'Get a time-aligned epoch with all channels. Returns array where each element has 4 channel values.'
          },
          'eegData.getChannelNames': {
            signature: 'eegData.getChannelNames()',
            description: 'Returns array of channel names: ["TP9", "AF7", "AF8", "TP10"].'
          }
        },
        'Connection Status': {
          'eegData.connected': {
            signature: 'eegData.connected (boolean)',
            description: 'True if Muse is connected or simulation is running, false otherwise.'
          },
          'eegData.sampleRate': {
            signature: 'eegData.sampleRate (256)',
            description: 'Sample rate in Hz (samples per second).'
          }
        }
      };

      // Monaco Editor setup and management
      class CodeEditor {
        constructor() {
          this.editor = null;
          this.currentSketch = null;
          this.autoRun = true;
          this.lastLoadedCode = null; // Track last loaded/selected code
          this.lastLoadedFilename = null; // Track filename
          this.setupEditor();
        }

        setupAutocomplete() {
          // Create completion items for p5.js functions
          const p5CompletionItems = [];
          
          Object.keys(p5Reference).forEach(category => {
            Object.keys(p5Reference[category]).forEach(funcName => {
              const func = p5Reference[category][funcName];
              p5CompletionItems.push({
                label: funcName,
                kind: monaco.languages.CompletionItemKind.Function,
                documentation: `${func.signature}\n\n${func.description}`,
                insertText: funcName,
                detail: category
              });
            });
          });
          
          // Create completion items for eegData
          const eegCompletionItems = [];
          Object.keys(eegReference).forEach(category => {
            Object.keys(eegReference[category]).forEach(propName => {
              const prop = eegReference[category][propName];
              eegCompletionItems.push({
                label: propName,
                kind: monaco.languages.CompletionItemKind.Property,
                documentation: `${prop.signature}\n\n${prop.description}`,
                insertText: propName,
                detail: category
              });
            });
          });
          
          // Register completion provider
          monaco.languages.registerCompletionItemProvider('javascript', {
            provideCompletionItems: (model, position) => {
              const word = model.getWordUntilPosition(position);
              const range = {
                startLineNumber: position.lineNumber,
                endLineNumber: position.lineNumber,
                startColumn: word.startColumn,
                endColumn: word.endColumn
              };
              
              // Check if we're typing after "eegData."
              const lineContent = model.getLineContent(position.lineNumber);
              const textBeforeCursor = lineContent.substring(0, position.column - 1);
              
              if (textBeforeCursor.includes('eegData.')) {
                return {
                  suggestions: eegCompletionItems.map(item => ({
                    ...item,
                    range: range
                  }))
                };
              }
              
              // Otherwise show p5.js functions
              return {
                suggestions: [...p5CompletionItems, ...eegCompletionItems].map(item => ({
                  ...item,
                  range: range
                }))
              };
            }
          });
          
          console.log('✅ Autocomplete registered for p5.js and eegData');
        }

        setupEditor() {
          require.config({ 
            paths: { 
              'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' 
            } 
          });

          require(['vs/editor/editor.main'], () => {
            this.editor = monaco.editor.create(document.getElementById('code-editor'), {
              value: this.getDefaultCode(),
              language: 'javascript',
              theme: 'vs-dark',
              fontSize: 12,
              minimap: { enabled: false },
              scrollBeyondLastLine: false,
              automaticLayout: true,
              wordWrap: 'on',
              suggestOnTriggerCharacters: true,
              quickSuggestions: true
            });

            // Register p5.js autocomplete
            this.setupAutocomplete();

            // Auto-run on change with debounce
            let timeout;
            this.editor.onDidChangeModelContent(() => {
              clearTimeout(timeout);
              timeout = setTimeout(() => {
                if (this.autoRun) {
                  this.runCode();
                }
              }, 1000);
            });

            // Initial run
            setTimeout(() => {
              console.log('Auto-running initial code...');
              this.runCode();
            }, 500);
          });
        }

        getDefaultCode() {
          return `// 🧠 BrainImation: Live EEG + P5.js
// Access real-time brain data through the 'eegData' object:
// eegData.alpha, eegData.beta, eegData.theta, eegData.delta
// eegData.attention, eegData.meditation, eegData.raw[]

let particles = [];
let time = 0;

function setup() {
  // Canvas is already created by the system
  // Just set up the drawing mode and initialize
  colorMode(HSB, 360, 100, 100, 1);
  
  // Initialize particles
  for (let i = 0; i < 50; i++) {
    particles.push({
      x: random(width),
      y: random(height),
      vx: random(-1, 1),
      vy: random(-1, 1),
      hue: random(360)
    });
  }
}

function draw() {
  // Background responds to meditation
  let bgAlpha = map(eegData.meditation, 0, 1, 0.05, 0.2);
  background(220, 30, 10, bgAlpha);
  
  time += 0.01;
  
  // Draw neural network
  stroke(180, 80, 90, 0.3);
  strokeWeight(1);
  
  for (let i = 0; i < particles.length; i++) {
    let p = particles[i];
    
    // Movement influenced by alpha waves
    let alphaForce = eegData.alpha * 2;
    p.vx += random(-alphaForce, alphaForce) * 0.01;
    p.vy += random(-alphaForce, alphaForce) * 0.01;
    
    // Damping
    p.vx *= 0.99;
    p.vy *= 0.99;
    
    // Update position
    p.x += p.vx;
    p.y += p.vy;
    
    // Wrap around edges
    if (p.x < 0) p.x = width;
    if (p.x > width) p.x = 0;
    if (p.y < 0) p.y = height;
    if (p.y > height) p.y = 0;
    
    // Color influenced by attention
    let hue = (p.hue + eegData.attention * 50 + time * 10) % 360;
    let brightness = map(eegData.beta, 0, 1, 30, 90);
    
    fill(hue, 70, brightness, 0.8);
    noStroke();
    
    // Size influenced by theta waves
    let size = 5 + eegData.theta * 15;
    ellipse(p.x, p.y, size);
    
    // Connect nearby particles
    for (let j = i + 1; j < particles.length; j++) {
      let p2 = particles[j];
      let d = dist(p.x, p.y, p2.x, p2.y);
      
      if (d < 80) {
        let alpha = map(d, 0, 80, 0.5, 0) * eegData.alpha;
        stroke(hue, 50, 70, alpha);
        strokeWeight(1);
        line(p.x, p.y, p2.x, p2.y);
      }
    }
  }
  
  // Display connection status
  if (!eegData.connected) {
    fill(0, 0, 100, 0.8);
    textAlign(CENTER, CENTER);
    textSize(20);
    text("Connect your Muse headset or use 'Simulate Data'", width/2, height/2 - 10);
    textSize(16);
    fill(0, 0, 70, 0.6);
    text("to see brain-controlled animation", width/2, height/2 + 20);
  }
}`;
        }

        runCode() {
          console.log('🚀 Running code...');
          try {
            // Clear any existing sketch
            if (this.currentSketch) {
              console.log('Removing existing sketch');
              this.currentSketch.remove();
            }

            // Clear the canvas container
            const container = document.getElementById('canvas-container');
            container.innerHTML = '';
            console.log('Canvas container cleared');

            // Hide error console
            document.getElementById('error-console').style.display = 'none';

            // Get code from editor
            const code = this.editor.getValue();
            console.log('Code retrieved from editor:', code.length, 'characters');

            // Get container dimensions
            const containerRect = container.getBoundingClientRect();
            const containerWidth = containerRect.width || 800;
            const containerHeight = containerRect.height || 600;
            console.log('Container dimensions:', containerWidth, 'x', containerHeight);

            // Execute the sketch with proper p5.js instance mode
            console.log('Creating p5 sketch...');
            this.currentSketch = new p5((p) => {
              // Store original p5 functions
              let userSetup, userDraw, userWindowResized;
              
              // Override console.error to catch p5 errors
              const originalError = console.error;
              console.error = function(...args) {
                originalError.apply(console, args);
                showError(args.join(' '));
              };

              // Make p5 functions available globally within the sketch context
              const bindP5Functions = () => {
                // Core p5 functions
                window.createCanvas = p.createCanvas.bind(p);
                window.background = p.background.bind(p);
                window.fill = p.fill.bind(p);
                window.stroke = p.stroke.bind(p);
                window.noStroke = p.noStroke.bind(p);
                window.noFill = p.noFill.bind(p);
                window.strokeWeight = p.strokeWeight.bind(p);
                window.ellipse = p.ellipse.bind(p);
                window.rect = p.rect.bind(p);
                window.line = p.line.bind(p);
                window.point = p.point.bind(p);
                window.triangle = p.triangle.bind(p);
                window.quad = p.quad.bind(p);
                window.arc = p.arc.bind(p);
                window.text = p.text.bind(p);
                window.textAlign = p.textAlign.bind(p);
                window.textSize = p.textSize.bind(p);
                window.textFont = p.textFont ? p.textFont.bind(p) : undefined;
                window.textWidth = p.textWidth.bind(p);
                window.beginShape = p.beginShape.bind(p);
                window.endShape = p.endShape.bind(p);
                window.vertex = p.vertex.bind(p);
                window.curveVertex = p.curveVertex ? p.curveVertex.bind(p) : undefined;
                window.bezierVertex = p.bezierVertex ? p.bezierVertex.bind(p) : undefined;
                
                // Loop control
                window.loop = p.loop.bind(p);
                window.noLoop = p.noLoop.bind(p);
                window.redraw = p.redraw.bind(p);
                
                // Math and utility
                window.map = p.map.bind(p);
                window.random = p.random.bind(p);
                window.randomSeed = p.randomSeed.bind(p);
                window.noise = p.noise.bind(p);
                window.noiseSeed = p.noiseSeed.bind(p);
                window.noiseDetail = p.noiseDetail ? p.noiseDetail.bind(p) : undefined;
                window.sin = p.sin.bind(p);
                window.cos = p.cos.bind(p);
                window.tan = p.tan.bind(p);
                window.asin = p.asin ? p.asin.bind(p) : undefined;
                window.acos = p.acos ? p.acos.bind(p) : undefined;
                window.atan = p.atan ? p.atan.bind(p) : undefined;
                window.atan2 = p.atan2 ? p.atan2.bind(p) : undefined;
                window.dist = p.dist.bind(p);
                window.abs = p.abs.bind(p);
                window.max = p.max.bind(p);
                window.min = p.min.bind(p);
                window.floor = p.floor.bind(p);
                window.ceil = p.ceil.bind(p);
                window.round = p.round.bind(p);
                window.sqrt = p.sqrt ? p.sqrt.bind(p) : undefined;
                window.pow = p.pow ? p.pow.bind(p) : undefined;
                window.constrain = p.constrain ? p.constrain.bind(p) : undefined;
                window.lerp = p.lerp ? p.lerp.bind(p) : undefined;
                window.norm = p.norm ? p.norm.bind(p) : undefined;
                
                // Color functions
                window.colorMode = p.colorMode.bind(p);
                window.color = p.color.bind(p);
                window.lerpColor = p.lerpColor.bind(p);
                window.red = p.red ? p.red.bind(p) : undefined;
                window.green = p.green ? p.green.bind(p) : undefined;
                window.blue = p.blue ? p.blue.bind(p) : undefined;
                window.alpha = p.alpha ? p.alpha.bind(p) : undefined;
                window.hue = p.hue ? p.hue.bind(p) : undefined;
                window.saturation = p.saturation ? p.saturation.bind(p) : undefined;
                window.brightness = p.brightness ? p.brightness.bind(p) : undefined;
                
                // Color mode constants
                window.HSB = p.HSB;
                window.RGB = p.RGB;
                window.HSL = p.HSL;
                
                // Transformation functions
                window.translate = p.translate.bind(p);
                window.rotate = p.rotate.bind(p);
                window.rotateX = p.rotateX ? p.rotateX.bind(p) : undefined;
                window.rotateY = p.rotateY ? p.rotateY.bind(p) : undefined;
                window.rotateZ = p.rotateZ ? p.rotateZ.bind(p) : undefined;
                window.scale = p.scale.bind(p);
                window.shearX = p.shearX ? p.shearX.bind(p) : undefined;
                window.shearY = p.shearY ? p.shearY.bind(p) : undefined;
                window.push = p.push.bind(p);
                window.pop = p.pop.bind(p);
                window.resetMatrix = p.resetMatrix ? p.resetMatrix.bind(p) : undefined;
                
                // Shape detail
                window.rectMode = p.rectMode ? p.rectMode.bind(p) : undefined;
                window.ellipseMode = p.ellipseMode ? p.ellipseMode.bind(p) : undefined;
                window.strokeCap = p.strokeCap ? p.strokeCap.bind(p) : undefined;
                window.strokeJoin = p.strokeJoin ? p.strokeJoin.bind(p) : undefined;
                window.smooth = p.smooth ? p.smooth.bind(p) : undefined;
                window.noSmooth = p.noSmooth ? p.noSmooth.bind(p) : undefined;
                
                // Constants
                window.TWO_PI = p.TWO_PI;
                window.PI = p.PI;
                window.HALF_PI = p.HALF_PI;
                window.QUARTER_PI = p.QUARTER_PI;
                window.CENTER = p.CENTER;
                window.LEFT = p.LEFT;
                window.RIGHT = p.RIGHT;
                window.TOP = p.TOP;
                window.BOTTOM = p.BOTTOM;
                window.CORNER = p.CORNER;
                window.CORNERS = p.CORNERS;
                window.RADIUS = p.RADIUS;
                window.CLOSE = p.CLOSE;
                window.OPEN = p.OPEN;
                
                // Frame and time
                window.frameCount = p.frameCount;
                window.millis = p.millis.bind(p);
                window.frameRate = p.frameRate.bind(p);
                
                // Dimensions (will be updated after canvas creation)
                window.width = containerWidth;
                window.height = containerHeight;
                window.windowWidth = containerWidth;
                window.windowHeight = containerHeight;
              };

              // Bind p5 functions
              bindP5Functions();

              // Execute user code to get their setup/draw functions
              try {
                console.log('Executing user code...');
                console.log('Code to execute:', code.substring(0, 200) + '...');
                
                // Clear any existing user functions
                window.setup = undefined;
                window.draw = undefined;
                window.windowResized = undefined;
                
                // Use eval with 'this' bound to window to ensure global scope
                eval.call(window, code);
                
                console.log('User code executed successfully');
                console.log('window.setup type:', typeof window.setup);
                console.log('window.draw type:', typeof window.draw);
                
                // Capture user-defined functions
                if (typeof window.setup === 'function') {
                  userSetup = window.setup;
                  console.log('✅ User setup function captured');
                } else {
                  console.log('❌ No setup function found in user code');
                }
                
                if (typeof window.draw === 'function') {
                  userDraw = window.draw;
                  console.log('✅ User draw function captured');
                } else {
                  console.log('❌ No draw function found in user code');
                }
                
                if (typeof window.windowResized === 'function') {
                  userWindowResized = window.windowResized;
                  console.log('✅ User windowResized function captured');
                }
              } catch (error) {
                console.error('Error in user code:', error);
                showError('Error in user code: ' + error.message);
                return;
              }

              // p5.js setup function
              p.setup = function() {
                console.log('p5.js setup() called');
                // Create canvas and attach to container
                const canvas = p.createCanvas(containerWidth, containerHeight);
                canvas.parent('canvas-container');
                console.log('Canvas created:', containerWidth, 'x', containerHeight);
                
                // Update global dimensions
                window.width = p.width;
                window.height = p.height;
                window.windowWidth = containerWidth;
                window.windowHeight = containerHeight;
                
                // Call user setup if it exists
                if (userSetup) {
                  console.log('Calling user setup function');
                  userSetup();
                } else {
                  console.log('No user setup function found');
                }
              };

              // p5.js draw function
              p.draw = function() {
                // Update frame count and dimensions
                window.frameCount = p.frameCount;
                window.width = p.width;
                window.height = p.height;
                
                // Call user draw if it exists
                if (userDraw) {
                  userDraw();
                } else {
                  // Show a test pattern if no user draw function
                  p.background(50);
                  p.fill(255);
                  p.textAlign(p.CENTER, p.CENTER);
                  p.textSize(20);
                  p.text('Canvas is working! Add your draw() function.', p.width/2, p.height/2);
                }
              };

              // Handle window resize
              p.windowResized = function() {
                const newRect = container.getBoundingClientRect();
                const newWidth = newRect.width || 800;
                const newHeight = newRect.height || 600;
                
                p.resizeCanvas(newWidth, newHeight);
                window.width = p.width;
                window.height = p.height;
                window.windowWidth = newWidth;
                window.windowHeight = newHeight;
                
                if (userWindowResized) {
                  userWindowResized();
                }
              };

            });

          } catch (error) {
            console.error('Error creating p5 sketch:', error);
            this.showError('Error creating sketch: ' + error.message);
          }
        }

        showError(message) {
          const errorConsole = document.getElementById('error-console');
          errorConsole.textContent = message;
          errorConsole.style.display = 'block';
        }

        saveCode() {
          const code = this.editor.getValue();
          const blob = new Blob([code], { type: 'text/javascript' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          
          // Generate filename with timestamp
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
          const filename = this.lastLoadedFilename || `brainimation-${timestamp}.js`;
          
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          
          console.log('Code saved as:', filename);
        }

        loadCodeFromFile(file) {
          const reader = new FileReader();
          
          reader.onload = (e) => {
            const code = e.target.result;
            this.editor.setValue(code);
            this.lastLoadedCode = code;
            this.lastLoadedFilename = file.name;
            
            // Enable reload button
            document.getElementById('reload-btn').disabled = false;
            
            console.log('Code loaded from:', file.name);
            
            // Auto-run the loaded code
            if (this.autoRun) {
              this.runCode();
            }
          };
          
          reader.onerror = (e) => {
            this.showError('Error loading file: ' + e.target.error);
          };
          
          reader.readAsText(file);
        }

        reloadCode() {
          if (this.lastLoadedCode) {
            this.editor.setValue(this.lastLoadedCode);
            console.log('Code reloaded:', this.lastLoadedFilename || 'last loaded code');
            
            // Auto-run the reloaded code
            if (this.autoRun) {
              this.runCode();
            }
          } else {
            console.log('No code to reload');
          }
        }

        loadExample(exampleName) {
          const examples = {
            basic: `// Basic animated background
function setup() {
  console.log('User setup() function called!');
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  let hue = map(eegData.alpha, 0, 1, 180, 300);
  background(hue, 50, 20);
  
  fill(hue + 60, 80, 90);
  let size = 50 + eegData.attention * 100;
  ellipse(width/2, height/2, size);
}`,

            alpha: `// Alpha wave visualization
let waves = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(220, 30, 10, 0.1);
  
  // Add new wave based on alpha strength
  if (frameCount % 10 === 0) {
    waves.push({
      x: width/2,
      y: height/2,
      r: 0,
      alpha: eegData.alpha
    });
  }
  
  // Draw and update waves
  for (let i = waves.length - 1; i >= 0; i--) {
    let w = waves[i];
    
    noFill();
    stroke(200, 70, 90, w.alpha);
    strokeWeight(2);
    ellipse(w.x, w.y, w.r * 2);
    
    w.r += w.alpha * 5 + 1;
    w.alpha *= 0.98;
    
    if (w.alpha < 0.01) {
      waves.splice(i, 1);
    }
  }
}`,

            attention: `// Attention meter
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Attention bar
  let barWidth = width * 0.8;
  let barHeight = 40;
  let x = (width - barWidth) / 2;
  let y = height / 2;
  
  // Background bar
  fill(0, 0, 20);
  rect(x, y, barWidth, barHeight);
  
  // Attention level
  let attentionWidth = barWidth * eegData.attention;
  let hue = map(eegData.attention, 0, 1, 0, 120);
  fill(hue, 80, 90);
  rect(x, y, attentionWidth, barHeight);
  
  // Text
  fill(0, 0, 100);
  textAlign(CENTER, CENTER);
  textSize(20);
  text("Attention: " + (eegData.attention * 100).toFixed(1) + "%", width/2, y - 60);
}`,

            particles: `// Brain particle system
let particles = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  for (let i = 0; i < 100; i++) {
    particles.push({
      x: random(width),
      y: random(height),
      vx: random(-2, 2),
      vy: random(-2, 2),
      life: 1.0
    });
  }
}

function draw() {
  background(0, 0, 5, 0.1);
  
  for (let p of particles) {
    // Movement influenced by brain waves
    p.vx += (random(-1, 1) * eegData.alpha * 0.1);
    p.vy += (random(-1, 1) * eegData.beta * 0.1);
    
    p.x += p.vx;
    p.y += p.vy;
    
    // Wrap around
    if (p.x < 0) p.x = width;
    if (p.x > width) p.x = 0;
    if (p.y < 0) p.y = height;
    if (p.y > height) p.y = 0;
    
    // Draw particle
    let hue = map(eegData.theta, 0, 1, 180, 300);
    fill(hue, 70, 90, p.life);
    noStroke();
    ellipse(p.x, p.y, 5 + eegData.gamma * 10);
    
    p.life *= 0.995;
    if (p.life < 0.1) p.life = 1.0;
  }
}`,

            mandala: `// Neural mandala
let angle = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 0, 0.05);
  
  translate(width/2, height/2);
  
  let layers = 5;
  for (let layer = 0; layer < layers; layer++) {
    let radius = 50 + layer * 40;
    let points = 6 + layer * 2;
    
    for (let i = 0; i < points; i++) {
      let a = angle + (TWO_PI / points) * i;
      let x = cos(a) * radius;
      let y = sin(a) * radius;
      
      let hue = (angle * 57.3 + layer * 60) % 360;
      let brightness = 50 + eegData.attention * 40;
      let size = 5 + eegData.alpha * layer * 2;
      
      fill(hue, 80, brightness, 0.7);
      noStroke();
      ellipse(x, y, size);
    }
  }
  
  angle += eegData.meditation * 0.02 + 0.005;
}`,

            waves: `// EEG wave visualization
let waveHistory = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  
  // Add current values to history
  waveHistory.push({
    alpha: eegData.alpha,
    beta: eegData.beta,
    theta: eegData.theta,
    delta: eegData.delta
  });
  
  // Keep history manageable
  if (waveHistory.length > width / 2) {
    waveHistory.shift();
  }
  
  // Draw waves
  let waves = ['alpha', 'beta', 'theta', 'delta'];
  let colors = [300, 180, 60, 0];
  
  for (let w = 0; w < waves.length; w++) {
    let wave = waves[w];
    let hue = colors[w];
    
    stroke(hue, 70, 90);
    strokeWeight(2);
    noFill();
    
    beginShape();
    for (let i = 0; i < waveHistory.length; i++) {
      let x = map(i, 0, waveHistory.length - 1, 0, width);
      let y = height/2 + (w - 1.5) * 80 + waveHistory[i][wave] * -50;
      vertex(x, y);
    }
    endShape();
    
    // Label
    fill(hue, 70, 90);
    noStroke();
    textAlign(LEFT, CENTER);
    text(wave.toUpperCase(), 10, height/2 + (w - 1.5) * 80);
  }
}`,

            eegtrace: `// Raw EEG trace visualization
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Get raw EEG data from TP9 electrode (left temporal)
  let tp9Data = eegData.getRawChannel('TP9', 300);
  
  if (tp9Data.length > 10) {
    // Draw EEG trace
    stroke(180, 80, 90);
    strokeWeight(2);
    noFill();
    
    beginShape();
    for (let i = 0; i < tp9Data.length; i++) {
      let x = map(i, 0, tp9Data.length - 1, 50, width - 50);
      let y = map(tp9Data[i], -100, 100, height - 50, 50);
      vertex(x, y);
    }
    endShape();
    
    // Add grid lines
    stroke(0, 0, 30);
    strokeWeight(1);
    
    // Horizontal lines (voltage levels)
    for (let v = -100; v <= 100; v += 50) {
      let y = map(v, -100, 100, height - 50, 50);
      line(50, y, width - 50, y);
    }
    
    // Vertical time markers
    for (let t = 0; t < tp9Data.length; t += 50) {
      let x = map(t, 0, tp9Data.length - 1, 50, width - 50);
      line(x, 50, x, height - 50);
    }
    
    // Labels
    fill(0, 0, 100);
    noStroke();
    textAlign(LEFT, TOP);
    textSize(16);
    text("TP9 Raw EEG Trace", 50, 20);
    
    textAlign(RIGHT, CENTER);
    textSize(12);
    text("100μV", 45, map(100, -100, 100, height - 50, 50));
    text("0μV", 45, map(0, -100, 100, height - 50, 50));
    text("-100μV", 45, map(-100, -100, 100, height - 50, 50));
  } else {
    // No data message
    fill(0, 0, 70);
    textAlign(CENTER, CENTER);
    textSize(20);
    text("Waiting for EEG data...", width/2, height/2);
  }
}`,

            multichannel: `// Multi-channel EEG visualization
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  let channels = eegData.getChannelNames();
  let colors = [300, 180, 60, 120]; // Purple, Cyan, Yellow, Green
  
  // Draw each channel
  for (let c = 0; c < channels.length; c++) {
    let channelData = eegData.getRawChannel(channels[c], 200);
    
    if (channelData.length > 10) {
      let yOffset = (c + 1) * height / (channels.length + 1);
      
      // Channel trace
      stroke(colors[c], 80, 90);
      strokeWeight(1.5);
      noFill();
      
      beginShape();
      for (let i = 0; i < channelData.length; i++) {
        let x = map(i, 0, channelData.length - 1, 80, width - 20);
        let y = yOffset + map(channelData[i], -100, 100, -40, 40);
        vertex(x, y);
      }
      endShape();
      
      // Channel label
      fill(colors[c], 80, 90);
      noStroke();
      textAlign(LEFT, CENTER);
      textSize(14);
      text(channels[c], 10, yOffset);
      
      // Zero line
      stroke(0, 0, 20);
      strokeWeight(1);
      line(80, yOffset, width - 20, yOffset);
    }
  }
  
  // Title
  fill(0, 0, 100);
  noStroke();
  textAlign(CENTER, TOP);
  textSize(16);
  text("Multi-Channel EEG (All 4 Electrodes)", width/2, 10);
  
  // Real-time indicator
  if (eegData.connected) {
    fill(120, 80, 90);
    ellipse(width - 30, 30, 10);
    textAlign(RIGHT, CENTER);
    textSize(12);
    text("LIVE", width - 40, 30);
  }
}`,

            epochs: `// EEG epoch visualization (like ERP analysis)
let epochData = [];
let epochLength = 128; // ~0.5 seconds at 256Hz

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 8);
  
  // Collect epochs when attention changes significantly
  if (frameCount % 60 === 0) { // Every second
    let recentEpoch = eegData.getRecentEpoch(epochLength);
    if (recentEpoch.length >= epochLength) {
      epochData.push({
        data: recentEpoch,
        attention: eegData.attention,
        timestamp: millis()
      });
      
      // Keep last 20 epochs
      if (epochData.length > 20) {
        epochData.shift();
      }
    }
  }
  
  if (epochData.length > 0) {
    // Draw averaged epoch
    let avgEpoch = [];
    for (let i = 0; i < epochLength; i++) {
      let sum = [0, 0, 0, 0]; // 4 channels
      let count = 0;
      
      for (let e = 0; e < epochData.length; e++) {
        if (epochData[e].data[i]) {
          for (let ch = 0; ch < 4; ch++) {
            sum[ch] += epochData[e].data[i][ch] || 0;
          }
          count++;
        }
      }
      
      if (count > 0) {
        avgEpoch.push([
          sum[0] / count,
          sum[1] / count,
          sum[2] / count,
          sum[3] / count
        ]);
      }
    }
    
    // Draw the averaged epoch for each channel
    let channelNames = ['TP9', 'AF7', 'AF8', 'TP10'];
    let colors = [300, 180, 60, 120];
    
    for (let ch = 0; ch < 4; ch++) {
      stroke(colors[ch], 80, 90);
      strokeWeight(2);
      noFill();
      
      beginShape();
      for (let i = 0; i < avgEpoch.length; i++) {
        let x = map(i, 0, avgEpoch.length - 1, 60, width - 60);
        let y = height/2 + (ch - 1.5) * 60 + map(avgEpoch[i][ch], -50, 50, 30, -30);
        vertex(x, y);
      }
      endShape();
      
      // Channel label
      fill(colors[ch], 80, 90);
      noStroke();
      textAlign(LEFT, CENTER);
      textSize(12);
      text(channelNames[ch], 10, height/2 + (ch - 1.5) * 60);
    }
    
    // Zero line
    stroke(0, 0, 30);
    strokeWeight(1);
    line(60, height/2, width - 60, height/2);
    
    // Time markers
    textAlign(CENTER, BOTTOM);
    textSize(10);
    fill(0, 0, 60);
    text("0ms", 60, height - 10);
    text("250ms", width/2, height - 10);
    text("500ms", width - 60, height - 10);
    
    // Title and info
    fill(0, 0, 100);
    textAlign(CENTER, TOP);
    textSize(16);
    text("Averaged Epochs (n=" + epochData.length + ")", width/2, 10);
    
    textSize(12);
    text("Grand average across all channels", width/2, 30);
  } else {
    // Waiting message
    fill(0, 0, 70);
    textAlign(CENTER, CENTER);
    textSize(18);
    text("Collecting epochs...", width/2, height/2);
    textSize(14);
    text("Epochs will appear as data accumulates", width/2, height/2 + 30);
  }
}`,

            // New examples from p5.eegedu.art repository
            basicShapes: `// Basic shapes with brain control
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  
  // Circle size controlled by alpha
  let circleSize = 50 + eegData.alpha * 150;
  fill(180, 70, 90);
  ellipse(width/4, height/2, circleSize);
  
  // Rectangle size controlled by beta
  let rectSize = 30 + eegData.beta * 100;
  fill(270, 70, 90);
  rect(width/2 - rectSize/2, height/2 - rectSize/2, rectSize, rectSize);
  
  // Triangle controlled by theta
  let triSize = 40 + eegData.theta * 120;
  fill(60, 70, 90);
  triangle(
    3*width/4, height/2 + triSize/2,
    3*width/4 - triSize/2, height/2 - triSize/2,
    3*width/4 + triSize/2, height/2 - triSize/2
  );
}`,

            functionExample: `// Function example with EEG
function setup() {
  colorMode(HSB, 360, 100, 100);
  frameRate(30);
}

function draw() {
  background(0, 0, 5);
  
  // Draw grid of brain-controlled shapes
  for (let x = 0; x < 5; x++) {
    for (let y = 0; y < 5; y++) {
      drawBrainShape(
        x * width/5 + width/10,
        y * height/5 + height/10,
        x, y
      );
    }
  }
}

function drawBrainShape(x, y, gridX, gridY) {
  push();
  translate(x, y);
  
  let size = 20 + eegData.attention * 40;
  let hue = (gridX * 60 + gridY * 30 + frameCount) % 360;
  let brightness = 50 + eegData.meditation * 40;
  
  fill(hue, 70, brightness);
  noStroke();
  ellipse(0, 0, size);
  pop();
}`,

            BasicFrequencyBands: `// Basic frequency bands visualization
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Draw bars for each frequency band
  let bands = [
    {name: 'Delta', value: eegData.delta, hue: 0},
    {name: 'Theta', value: eegData.theta, hue: 60},
    {name: 'Alpha', value: eegData.alpha, hue: 180},
    {name: 'Beta', value: eegData.beta, hue: 270},
    {name: 'Gamma', value: eegData.gamma, hue: 300}
  ];
  
  let barWidth = width / bands.length;
  
  for (let i = 0; i < bands.length; i++) {
    let band = bands[i];
    let x = i * barWidth;
    let barHeight = band.value * height * 0.8;
    
    // Draw bar
    fill(band.hue, 70, 90);
    rect(x, height - barHeight, barWidth - 10, barHeight);
    
    // Draw label
    fill(0, 0, 100);
    textAlign(CENTER, BOTTOM);
    textSize(12);
    text(band.name, x + barWidth/2, height - 5);
    
    // Draw value
    textAlign(CENTER, TOP);
    textSize(10);
    text(band.value.toFixed(2), x + barWidth/2, height - barHeight - 5);
  }
}`,

            bandOrbitz: `// Band orbitz - frequency bands as orbiting circles
let angle = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5, 0.1);
  translate(width/2, height/2);
  
  let bands = [
    {name: 'Delta', value: eegData.delta, hue: 0, radius: 50},
    {name: 'Theta', value: eegData.theta, hue: 60, radius: 100},
    {name: 'Alpha', value: eegData.alpha, hue: 180, radius: 150},
    {name: 'Beta', value: eegData.beta, hue: 270, radius: 200},
    {name: 'Gamma', value: eegData.gamma, hue: 300, radius: 250}
  ];
  
  for (let i = 0; i < bands.length; i++) {
    let band = bands[i];
    let a = angle + (i * TWO_PI / bands.length);
    let r = band.radius;
    let size = 10 + band.value * 40;
    
    let x = cos(a) * r;
    let y = sin(a) * r;
    
    fill(band.hue, 70, 90, 0.8);
    noStroke();
    ellipse(x, y, size);
    
    // Draw orbit path
    noFill();
    stroke(band.hue, 30, 50, 0.3);
    ellipse(0, 0, r * 2);
  }
  
  angle += 0.02 * eegData.attention;
}`,

            piWedges: `// Pi wedges - frequency bands as pie chart
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  translate(width/2, height/2);
  
  let bands = [
    {name: 'Delta', value: eegData.delta, hue: 0},
    {name: 'Theta', value: eegData.theta, hue: 60},
    {name: 'Alpha', value: eegData.alpha, hue: 180},
    {name: 'Beta', value: eegData.beta, hue: 270},
    {name: 'Gamma', value: eegData.gamma, hue: 300}
  ];
  
  let total = bands.reduce((sum, b) => sum + b.value, 0);
  let startAngle = 0;
  let radius = min(width, height) * 0.35;
  
  for (let i = 0; i < bands.length; i++) {
    let band = bands[i];
    let angle = (band.value / total) * TWO_PI;
    
    // Draw wedge
    fill(band.hue, 70, 90);
    arc(0, 0, radius * 2, radius * 2, startAngle, startAngle + angle, PIE);
    
    // Draw label
    let midAngle = startAngle + angle / 2;
    let labelX = cos(midAngle) * radius * 0.6;
    let labelY = sin(midAngle) * radius * 0.6;
    
    fill(0, 0, 100);
    textAlign(CENTER, CENTER);
    textSize(12);
    text(band.name, labelX, labelY);
    
    startAngle += angle;
  }
}`,

            spectra: `// Spectra - frequency spectrum visualization
let spectrumHistory = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Add current spectrum to history
  spectrumHistory.push({
    delta: eegData.delta,
    theta: eegData.theta,
    alpha: eegData.alpha,
    beta: eegData.beta,
    gamma: eegData.gamma
  });
  
  if (spectrumHistory.length > 100) {
    spectrumHistory.shift();
  }
  
  // Draw spectrum over time
  let bands = ['delta', 'theta', 'alpha', 'beta', 'gamma'];
  let hues = [0, 60, 180, 270, 300];
  
  for (let b = 0; b < bands.length; b++) {
    stroke(hues[b], 70, 90);
    strokeWeight(2);
    noFill();
    
    beginShape();
    for (let i = 0; i < spectrumHistory.length; i++) {
      let x = map(i, 0, spectrumHistory.length - 1, 50, width - 50);
      let y = height/2 + (b - 2) * 60 - spectrumHistory[i][bands[b]] * 40;
      vertex(x, y);
    }
    endShape();
    
    // Label
    fill(hues[b], 70, 90);
    noStroke();
    textAlign(LEFT, CENTER);
    textSize(10);
    text(bands[b].toUpperCase(), 10, height/2 + (b - 2) * 60);
  }
}`,

            ColourBalls: `// Colour balls - attention-controlled bouncing balls
let balls = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  for (let i = 0; i < 20; i++) {
    balls.push({
      x: random(width),
      y: random(height),
      vx: random(-3, 3),
      vy: random(-3, 3),
      size: random(10, 40),
      hue: random(360)
    });
  }
}

function draw() {
  background(0, 0, 5, 0.2);
  
  for (let ball of balls) {
    // Update position
    ball.x += ball.vx * (1 + eegData.attention);
    ball.y += ball.vy * (1 + eegData.attention);
    
    // Bounce off edges
    if (ball.x < 0 || ball.x > width) ball.vx *= -1;
    if (ball.y < 0 || ball.y > height) ball.vy *= -1;
    
    // Keep in bounds
    ball.x = constrain(ball.x, 0, width);
    ball.y = constrain(ball.y, 0, height);
    
    // Rotate hue based on meditation
    ball.hue = (ball.hue + eegData.meditation * 2) % 360;
    
    // Draw ball
    fill(ball.hue, 70, 90, 0.8);
    noStroke();
    ellipse(ball.x, ball.y, ball.size);
  }
}`,

            MultipleBalls: `// Multiple balls with different behaviors
let balls = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      balls.push({
        x: (i + 1) * width / 4,
        y: (j + 1) * height / 4,
        vx: random(-2, 2),
        vy: random(-2, 2),
        type: (i * 3 + j) % 5,
        phase: random(TWO_PI)
      });
    }
  }
}

function draw() {
  background(0, 0, 10, 0.1);
  
  let bands = [eegData.delta, eegData.theta, eegData.alpha, eegData.beta, eegData.gamma];
  let hues = [0, 60, 180, 270, 300];
  
  for (let ball of balls) {
    let bandValue = bands[ball.type];
    let hue = hues[ball.type];
    
    // Update with different behavior per type
    ball.x += ball.vx * (1 + bandValue);
    ball.y += ball.vy * (1 + bandValue);
    
    // Bounce
    if (ball.x < 0 || ball.x > width) ball.vx *= -1;
    if (ball.y < 0 || ball.y > height) ball.vy *= -1;
    
    ball.x = constrain(ball.x, 0, width);
    ball.y = constrain(ball.y, 0, height);
    
    // Draw
    let size = 15 + bandValue * 30;
    fill(hue, 70, 90, 0.7);
    noStroke();
    ellipse(ball.x, ball.y, size);
  }
}`,

            '3dTorus': `// 3D Torus controlled by brain waves
let rotX = 0;
let rotY = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Setup 3D
  push();
  translate(width/2, height/2);
  
  // Rotate based on brain waves
  rotX += eegData.alpha * 0.02;
  rotY += eegData.beta * 0.02;
  
  rotateX(rotX);
  rotateY(rotY);
  
  // Draw torus with changing parameters
  let radius = 50 + eegData.meditation * 50;
  let tubeRadius = 10 + eegData.attention * 20;
  
  // Color based on theta
  let hue = eegData.theta * 360;
  fill(hue, 70, 90);
  noStroke();
  
  torus(radius, tubeRadius);
  pop();
  
  // Info text
  fill(0, 0, 100);
  textAlign(LEFT, TOP);
  textSize(10);
  text("Alpha: rotation X", 10, 10);
  text("Beta: rotation Y", 10, 25);
  text("Meditation: radius", 10, 40);
  text("Attention: tube", 10, 55);
}`,

            AlphaSnake: `// Alpha snake - snake controlled by alpha waves
let snake = [];
let angle = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  // Initialize snake
  for (let i = 0; i < 50; i++) {
    snake.push({x: width/2, y: height/2});
  }
}

function draw() {
  background(0, 0, 5, 0.1);
  
  // Move snake head based on alpha
  angle += map(eegData.alpha, 0, 1, -0.1, 0.1);
  let speed = 2 + eegData.beta * 3;
  
  let headX = snake[0].x + cos(angle) * speed;
  let headY = snake[0].y + sin(angle) * speed;
  
  // Wrap around
  headX = (headX + width) % width;
  headY = (headY + height) % height;
  
  // Add new head
  snake.unshift({x: headX, y: headY});
  snake.pop();
  
  // Draw snake
  for (let i = 0; i < snake.length; i++) {
    let hue = (i * 5 + frameCount) % 360;
    let size = map(i, 0, snake.length - 1, 20, 5);
    let brightness = 50 + eegData.attention * 40;
    
    fill(hue, 70, brightness);
    noStroke();
    ellipse(snake[i].x, snake[i].y, size);
  }
}`,

            SplineBounce: `// Spline bounce - smooth curves with EEG
let points = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  // Initialize points
  for (let i = 0; i < 8; i++) {
    points.push({
      x: random(width),
      y: random(height),
      vx: random(-2, 2),
      vy: random(-2, 2)
    });
  }
}

function draw() {
  background(0, 0, 10);
  
  // Update points
  for (let p of points) {
    p.x += p.vx * (1 + eegData.attention * 0.5);
    p.y += p.vy * (1 + eegData.attention * 0.5);
    
    if (p.x < 0 || p.x > width) p.vx *= -1;
    if (p.y < 0 || p.y > height) p.vy *= -1;
    
    p.x = constrain(p.x, 0, width);
    p.y = constrain(p.y, 0, height);
  }
  
  // Draw smooth curve through points
  stroke(180 + eegData.alpha * 180, 70, 90);
  strokeWeight(2 + eegData.meditation * 5);
  noFill();
  
  beginShape();
  for (let i = 0; i < points.length; i++) {
    curveVertex(points[i].x, points[i].y);
  }
  // Repeat first points to close curve
  curveVertex(points[0].x, points[0].y);
  curveVertex(points[1].x, points[1].y);
  endShape();
  
  // Draw control points
  for (let p of points) {
    fill(60, 70, 90);
    noStroke();
    ellipse(p.x, p.y, 8);
  }
}`,

            BrainDraw: `// Brain draw - draw with your mind
let drawing = [];
let x, y;

function setup() {
  colorMode(HSB, 360, 100, 100);
  x = width/2;
  y = height/2;
}

function draw() {
  // Fade background slowly
  background(0, 0, 5, 0.02);
  
  // Move based on brain waves
  let dx = map(eegData.alpha - 0.5, -0.5, 0.5, -3, 3);
  let dy = map(eegData.beta - 0.5, -0.5, 0.5, -3, 3);
  
  x += dx;
  y += dy;
  
  // Keep in bounds
  x = constrain(x, 0, width);
  y = constrain(y, 0, height);
  
  // Draw if attention is high
  if (eegData.attention > 0.3) {
    let hue = eegData.theta * 360;
    let size = 5 + eegData.meditation * 20;
    
    fill(hue, 70, 90, 0.6);
    noStroke();
    ellipse(x, y, size);
    
    drawing.push({x: x, y: y, hue: hue, size: size});
    
    // Limit history
    if (drawing.length > 500) {
      drawing.shift();
    }
  }
  
  // Draw cursor
  stroke(0, 0, 100);
  strokeWeight(2);
  noFill();
  ellipse(x, y, 20);
  
  // Instructions
  fill(0, 0, 100);
  textAlign(LEFT, TOP);
  textSize(10);
  text("Alpha: move X | Beta: move Y", 10, 10);
  text("Attention: draw | Theta: color | Meditation: size", 10, 25);
}`,

            bouncingLine: `// Bouncing line with brain control
let x1, y1, x2, y2;
let vx1, vy1, vx2, vy2;

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  x1 = width/4;
  y1 = height/2;
  x2 = 3*width/4;
  y2 = height/2;
  
  vx1 = random(-3, 3);
  vy1 = random(-3, 3);
  vx2 = random(-3, 3);
  vy2 = random(-3, 3);
}

function draw() {
  background(0, 0, 5, 0.1);
  
  // Update endpoints
  let speed = 1 + eegData.attention;
  x1 += vx1 * speed;
  y1 += vy1 * speed;
  x2 += vx2 * speed;
  y2 += vy2 * speed;
  
  // Bounce
  if (x1 < 0 || x1 > width) vx1 *= -1;
  if (y1 < 0 || y1 > height) vy1 *= -1;
  if (x2 < 0 || x2 > width) vx2 *= -1;
  if (y2 < 0 || y2 > height) vy2 *= -1;
  
  x1 = constrain(x1, 0, width);
  y1 = constrain(y1, 0, height);
  x2 = constrain(x2, 0, width);
  y2 = constrain(y2, 0, height);
  
  // Draw line with varying thickness
  let weight = 1 + eegData.alpha * 20;
  let hue = eegData.theta * 360;
  
  stroke(hue, 70, 90);
  strokeWeight(weight);
  line(x1, y1, x2, y2);
  
  // Draw endpoints
  noStroke();
  fill(hue, 90, 90);
  ellipse(x1, y1, 15);
  ellipse(x2, y2, 15);
}`,

            ghostLines: `// Ghost lines - trailing line patterns
let lines = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5, 0.05);
  
  // Add new line
  if (frameCount % 3 === 0) {
    lines.push({
      x1: width/2 + cos(frameCount * 0.05) * 100,
      y1: height/2 + sin(frameCount * 0.05) * 100,
      x2: width/2 + cos(frameCount * 0.05 + PI) * 100,
      y2: height/2 + sin(frameCount * 0.05 + PI) * 100,
      life: 1.0,
      hue: (frameCount + eegData.alpha * 360) % 360
    });
  }
  
  // Draw and update lines
  for (let i = lines.length - 1; i >= 0; i--) {
    let line = lines[i];
    
    // Expand line
    let expansion = (1 - line.life) * eegData.attention * 50;
    let x1 = line.x1 + cos(atan2(line.y1 - height/2, line.x1 - width/2)) * expansion;
    let y1 = line.y1 + sin(atan2(line.y1 - height/2, line.x1 - width/2)) * expansion;
    let x2 = line.x2 + cos(atan2(line.y2 - height/2, line.x2 - width/2)) * expansion;
    let y2 = line.y2 + sin(atan2(line.y2 - height/2, line.x2 - width/2)) * expansion;
    
    stroke(line.hue, 70, 90, line.life);
    strokeWeight(2 + eegData.meditation * 5);
    stroke(line.hue, 70, 90, line.life);
    line(x1, y1, x2, y2);
    
    line.life -= 0.01;
    if (line.life <= 0) {
      lines.splice(i, 1);
    }
  }
}`
          };

          if (examples[exampleName]) {
            const exampleCode = examples[exampleName];
            this.editor.setValue(exampleCode);
            this.lastLoadedCode = exampleCode;
            this.lastLoadedFilename = `${exampleName}-example.js`;
            
            // Enable reload button
            document.getElementById('reload-btn').disabled = false;
            
            this.runCode();
          }
        }
      }

      // Reference Panel Manager
      class ReferencePanel {
        constructor() {
          this.currentTab = 'p5js';
          this.setupTabs();
          this.loadContent('p5js');
        }

        setupTabs() {
          document.querySelectorAll('.reference-tab').forEach(tab => {
            tab.addEventListener('click', () => {
              // Update active tab
              document.querySelectorAll('.reference-tab').forEach(t => t.classList.remove('active'));
              tab.classList.add('active');
              
              // Load content
              const tabName = tab.dataset.tab;
              this.loadContent(tabName);
            });
          });
        }

        loadContent(tabName) {
          this.currentTab = tabName;
          const contentDiv = document.getElementById('reference-content');
          const aiAssistant = document.getElementById('ai-assistant');
          
          if (tabName === 'ai') {
            contentDiv.style.display = 'none';
            aiAssistant.style.display = 'flex';
          } else {
            contentDiv.style.display = 'block';
            aiAssistant.style.display = 'none';
            
            if (tabName === 'p5js') {
              contentDiv.innerHTML = this.renderReference(p5Reference);
            } else if (tabName === 'eeg') {
              contentDiv.innerHTML = this.renderReference(eegReference);
            }
            
            // Add click handlers for inserting code
            this.setupFunctionClicks();
          }
        }

        renderReference(reference) {
          let html = '';
          
          Object.keys(reference).forEach(groupName => {
            html += `<div class="function-group">`;
            html += `<div class="function-group-title">${groupName}</div>`;
            
            Object.keys(reference[groupName]).forEach(funcName => {
              const func = reference[groupName][funcName];
              html += `
                <div class="function-item" data-function="${funcName}">
                  <span class="function-name">${funcName}</span>
                  <div class="function-tooltip">
                    <div class="tooltip-signature">${func.signature}</div>
                    <div class="tooltip-description">${func.description}</div>
                  </div>
                </div>
              `;
            });
            
            html += `</div>`;
          });
          
          return html;
        }

        setupFunctionClicks() {
          document.querySelectorAll('.function-item').forEach(item => {
            item.addEventListener('click', () => {
              const funcName = item.dataset.function;
              if (codeEditor && codeEditor.editor) {
                // Get the function signature to extract parameters
                let signature = '';
                let reference = this.currentTab === 'p5js' ? p5Reference : eegReference;
                
                // Find the function in the reference
                for (let group in reference) {
                  if (reference[group][funcName]) {
                    signature = reference[group][funcName].signature;
                    break;
                  }
                }
                
                // Parse parameters from signature
                let snippetText = this.createSnippet(funcName, signature);
                
                // Insert as Monaco snippet with placeholders
                const position = codeEditor.editor.getPosition();
                
                // Use Monaco's snippet controller for proper tab-through behavior
                const snippetController = codeEditor.editor.getContribution('snippetController2');
                if (snippetController && snippetText.includes('${')) {
                  // Insert with snippet support (allows tab through placeholders)
                  snippetController.insert(snippetText);
                } else {
                  // Fallback to simple text insertion
                  codeEditor.editor.executeEdits('', [{
                    range: new monaco.Range(
                      position.lineNumber,
                      position.column,
                      position.lineNumber,
                      position.column
                    ),
                    text: snippetText,
                    forceMoveMarkers: true
                  }]);
                }
                
                codeEditor.editor.focus();
              }
            });
          });
        }
        
        createSnippet(funcName, signature) {
          // Extract parameters from signature
          // e.g., "ellipse(x, y, width, [height])" -> ["x", "y", "width", "[height]"]
          
          if (!signature) {
            return funcName + '()';
          }
          
          // Find the parameters part (between parentheses)
          const paramsMatch = signature.match(/\(([^)]*)\)/);
          if (!paramsMatch || !paramsMatch[1].trim()) {
            return funcName + '()';
          }
          
          const paramsStr = paramsMatch[1];
          
          // Split by comma, handling nested brackets
          const params = paramsStr.split(',').map(p => p.trim()).filter(p => p);
          
          if (params.length === 0) {
            return funcName + '()';
          }
          
          // Create snippet with numbered placeholders
          let snippetParams = params.map((param, index) => {
            // Remove brackets for optional parameters but keep the name
            let cleanParam = param.replace(/[\[\]]/g, '');
            
            // Handle "or" alternatives (e.g., "color or r, g, b")
            if (cleanParam.includes(' or ')) {
              cleanParam = cleanParam.split(' or ')[0].trim();
            }
            
            return `\${${index + 1}:${cleanParam}}`;
          }).join(', ');
          
          return `${funcName}(${snippetParams})`;
        }
      }

      // AI Assistant Manager
      class AIAssistant {
        constructor() {
          this.apiKey = localStorage.getItem('brainimation_api_key') || '';
          this.apiProvider = localStorage.getItem('brainimation_api_provider') || 'openai';
          this.setupEventListeners();
          this.updateStatus();
        }

        setupEventListeners() {
          document.getElementById('ai-generate-btn').addEventListener('click', () => {
            this.generateCode();
          });

          document.getElementById('ai-config-btn').addEventListener('click', () => {
            this.showConfig();
          });
        }

        updateStatus() {
          const statusEl = document.getElementById('ai-status');
          if (this.apiKey) {
            statusEl.textContent = `Ready to assist (${this.apiProvider})`;
            statusEl.style.color = 'var(--success)';
          } else {
            statusEl.textContent = 'Configure API key to use AI features';
            statusEl.style.color = 'var(--muted)';
          }
        }

        showConfig() {
          const provider = prompt(
            'Select API Provider:\n\n1. OpenAI (ChatGPT)\n2. Anthropic (Claude)\n\nEnter 1 or 2:',
            this.apiProvider === 'anthropic' ? '2' : '1'
          );
          
          if (provider === '1' || provider === '2') {
            this.apiProvider = provider === '2' ? 'anthropic' : 'openai';
            localStorage.setItem('brainimation_api_provider', this.apiProvider);
            
            const key = prompt(
              `Enter your ${this.apiProvider === 'openai' ? 'OpenAI' : 'Anthropic'} API key:\n\n` +
              `(stored locally in browser only)`,
              this.apiKey
            );
            
            if (key !== null) {
              this.apiKey = key.trim();
              localStorage.setItem('brainimation_api_key', this.apiKey);
              this.updateStatus();
              alert('API key saved successfully!');
            }
          }
        }

        async generateCode() {
          if (!this.apiKey) {
            alert('Please configure your API key first (click ⚙️ button)');
            return;
          }

          const prompt = document.getElementById('ai-prompt').value.trim();
          if (!prompt) {
            alert('Please describe what you want to create or modify');
            return;
          }

          const statusEl = document.getElementById('ai-status');
          const generateBtn = document.getElementById('ai-generate-btn');
          
          try {
            generateBtn.disabled = true;
            statusEl.textContent = 'Generating code...';
            statusEl.style.color = 'var(--accent)';

            const currentCode = codeEditor.editor.getValue();
            
            const systemPrompt = `You are a helpful p5.js coding assistant for BrainImation, an EEG-powered creative coding platform. 
Help users create animations that respond to brain data available through the eegData object:
- eegData.alpha, beta, theta, delta, gamma (0.0-1.0)
- eegData.attention, meditation (0.0-1.0)
- eegData.getRawChannel(channel, numSamples) for raw EEG
- eegData.connected (boolean)

Respond ONLY with JavaScript code, no explanations or markdown. Include setup() and draw() functions.`;

            const userMessage = prompt + (currentCode ? `\n\nCurrent code:\n${currentCode}` : '');

            let generatedCode = '';

            if (this.apiProvider === 'openai') {
              const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${this.apiKey}`
                },
                body: JSON.stringify({
                  model: 'gpt-4',
                  messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userMessage }
                  ],
                  temperature: 0.7,
                  max_tokens: 2000
                })
              });

              if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
              }

              const data = await response.json();
              generatedCode = data.choices[0].message.content;
            } else if (this.apiProvider === 'anthropic') {
              const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-api-key': this.apiKey,
                  'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                  model: 'claude-3-5-sonnet-20241022',
                  max_tokens: 2000,
                  system: systemPrompt,
                  messages: [
                    { role: 'user', content: userMessage }
                  ]
                })
              });

              if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
              }

              const data = await response.json();
              generatedCode = data.content[0].text;
            }

            // Clean up code (remove markdown fences if present)
            generatedCode = generatedCode.replace(/```javascript\n?/g, '').replace(/```\n?/g, '').trim();

            // Insert into editor
            codeEditor.editor.setValue(generatedCode);
            
            statusEl.textContent = 'Code generated! Running...';
            statusEl.style.color = 'var(--success)';
            
            // Auto-run the generated code
            setTimeout(() => {
              codeEditor.runCode();
              statusEl.textContent = `Ready to assist (${this.apiProvider})`;
            }, 500);

          } catch (error) {
            console.error('AI generation error:', error);
            statusEl.textContent = `Error: ${error.message}`;
            statusEl.style.color = 'var(--error)';
            alert(`Failed to generate code:\n${error.message}\n\nPlease check your API key and try again.`);
          } finally {
            generateBtn.disabled = false;
          }
        }
      }

      // Application initialization
      let museManager;
      let eegSimulator;
      let codeEditor;
      let referencePanel;
      let aiAssistant;
      let currentDataSource = null; // 'muse' or 'simulator'

      function initApp() {
        museManager = new MuseEEGManager();
        eegSimulator = new EEGSimulator();
        codeEditor = new CodeEditor();
        referencePanel = new ReferencePanel();
        aiAssistant = new AIAssistant();

        // Toggle reference panel
        document.getElementById('toggle-reference-btn').addEventListener('click', () => {
          const mainContainer = document.querySelector('.main-container');
          const referencePanel = document.getElementById('reference-panel');
          const btn = document.getElementById('toggle-reference-btn');
          
          if (mainContainer.classList.contains('hide-reference')) {
            mainContainer.classList.remove('hide-reference');
            btn.textContent = '📖 Reference';
          } else {
            mainContainer.classList.add('hide-reference');
            btn.textContent = '📖 Show Reference';
          }
        });

        // Event listeners
        const connectBtn = document.getElementById('connect-btn');
        
        connectBtn.addEventListener('click', async () => {
          // If already connected, disconnect
          if (currentDataSource === 'muse' && museManager.isConnected) {
            console.log('User requested disconnect');
            museManager.disconnect();
            currentDataSource = null;
            connectBtn.textContent = 'Connect Muse';
            connectBtn.disabled = false;
            document.getElementById('simulate-btn').disabled = false;
            return;
          }
          
          // Stop simulation if running
          if (currentDataSource === 'simulator') {
            console.log('Stopping simulation before Muse connection');
            stopSimulation();
          }
          
          // Attempt to connect
          connectBtn.disabled = true;
          connectBtn.textContent = 'Connecting...';
          
          try {
            await museManager.connect();
            currentDataSource = 'muse';
            connectBtn.textContent = 'Disconnect Muse';
            connectBtn.disabled = false;
            document.getElementById('simulate-btn').disabled = true;
            console.log('Connection successful, button updated');
          } catch (error) {
            console.error('Connection failed:', error);
            connectBtn.textContent = 'Connect Muse';
            connectBtn.disabled = false;
            currentDataSource = null;
            document.getElementById('simulate-btn').disabled = false;
          }
        });

        document.getElementById('simulate-btn').addEventListener('click', () => {
          if (currentDataSource === 'muse') {
            museManager.disconnect();
          }
          
          if (currentDataSource === 'simulator') {
            stopSimulation();
          } else {
            startSimulation();
          }
        });

        document.getElementById('run-btn').addEventListener('click', () => {
          codeEditor.runCode();
        });

        // Save button
        document.getElementById('save-btn').addEventListener('click', () => {
          codeEditor.saveCode();
        });

        // Load button - trigger file input
        document.getElementById('load-btn').addEventListener('click', () => {
          document.getElementById('file-input').click();
        });

        // File input change handler
        document.getElementById('file-input').addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
            codeEditor.loadCodeFromFile(file);
          }
          // Reset input so same file can be loaded again
          e.target.value = '';
        });

        // Reload button
        document.getElementById('reload-btn').addEventListener('click', () => {
          codeEditor.reloadCode();
        });

        document.getElementById('fullscreen-btn').addEventListener('click', async () => {
          const container = document.getElementById('canvas-container');
          
          try {
            if (!document.fullscreenElement) {
              // Enter fullscreen mode
              await container.requestFullscreen();
              document.getElementById('fullscreen-btn').textContent = 'Exit Fullscreen';
            } else {
              // Exit fullscreen mode
              await document.exitFullscreen();
              document.getElementById('fullscreen-btn').textContent = 'Fullscreen';
            }
          } catch (error) {
            console.error('Fullscreen error:', error);
            alert('Fullscreen mode is not supported or was blocked. Please try pressing F11 or allow fullscreen permissions.');
          }
        });

        // Example selector dropdown
        document.getElementById('example-selector').addEventListener('change', (e) => {
          const exampleName = e.target.value;
          if (exampleName) {
            codeEditor.loadExample(exampleName);
          }
        });

        // Simulation control sliders
        const attentionSlider = document.getElementById('sim-attention');
        const meditationSlider = document.getElementById('sim-meditation');
        const attentionVal = document.getElementById('sim-attention-val');
        const meditationVal = document.getElementById('sim-meditation-val');
        
        attentionSlider.addEventListener('input', (e) => {
          const value = e.target.value;
          attentionVal.textContent = value;
          if (eegSimulator && eegSimulator.isRunning) {
            eegSimulator.setAttention(value);
          }
        });
        
        meditationSlider.addEventListener('input', (e) => {
          const value = e.target.value;
          meditationVal.textContent = value;
          if (eegSimulator && eegSimulator.isRunning) {
            eegSimulator.setMeditation(value);
          }
        });

        // Listen for fullscreen changes (e.g., when user presses ESC)
        document.addEventListener('fullscreenchange', () => {
          const btn = document.getElementById('fullscreen-btn');
          if (document.fullscreenElement) {
            btn.textContent = 'Exit Fullscreen';
          } else {
            btn.textContent = 'Fullscreen';
          }
        });

        // Check for Web Bluetooth support first
        if (!navigator.bluetooth) {
          console.warn('⚠️ Web Bluetooth is not supported in this browser');
          console.warn('Please use Chrome, Edge, or Opera to connect to Muse devices');
          document.getElementById('connect-btn').disabled = true;
          document.getElementById('connect-btn').title = 'Web Bluetooth not supported in this browser';
          museManager.updateStatus('Bluetooth not supported', 'error');
        } else {
          console.log('✅ Web Bluetooth is supported');
        }
        
        // Check if muse-js library loaded successfully
        console.log('\n🔍 Checking muse-js library...');
        console.log('muse-js library loaded:', !!window.muse);
        console.log('MuseClient available:', !!(window.muse && window.muse.MuseClient));
        
        if (window.muse && window.muse.MuseClient) {
          console.log('✅ muse-js library is ready!');
          document.getElementById('connect-btn').disabled = false;
          museManager.updateStatus('Ready to connect', '');
        } else {
          console.error('❌ muse-js library failed to load!');
          document.getElementById('connect-btn').disabled = true;
          museManager.updateStatus('muse-js library error', 'error');
        }
        
        console.log('🧠 BrainImation initialized successfully!');
      }

      // Simulation control functions
      function startSimulation() {
        eegSimulator.start();
        currentDataSource = 'simulator';
        
        document.getElementById('simulate-btn').textContent = 'Stop Simulation';
        document.getElementById('connect-btn').disabled = true;
        document.getElementById('sim-controls').style.display = 'block';
        document.getElementById('status-text').textContent = 'Simulating EEG Data';
        document.getElementById('muse-status').className = 'status-indicator connected';
        
        // Initialize with current slider values
        eegSimulator.setAttention(document.getElementById('sim-attention').value);
        eegSimulator.setMeditation(document.getElementById('sim-meditation').value);
      }

      function stopSimulation() {
        eegSimulator.stop();
        currentDataSource = null;
        
        document.getElementById('simulate-btn').textContent = 'Simulate Data';
        document.getElementById('connect-btn').disabled = false;
        document.getElementById('sim-controls').style.display = 'none';
        document.getElementById('status-text').textContent = 'Disconnected';
        document.getElementById('muse-status').className = 'status-indicator';
        
        // Reset eegData
        Object.keys(eegData).forEach(key => {
          if (typeof eegData[key] === 'number') {
            eegData[key] = 0;
          } else if (Array.isArray(eegData[key])) {
            eegData[key] = [0, 0, 0, 0];
          } else if (key === 'connected') {
            eegData[key] = false;
          } else if (key === 'rawHistory') {
            eegData[key] = { TP9: [], AF7: [], AF8: [], TP10: [] };
          }
        });
        
        // Update display
        document.getElementById('alpha-value').textContent = '0.0';
        document.getElementById('beta-value').textContent = '0.0';
        document.getElementById('theta-value').textContent = '0.0';
        document.getElementById('delta-value').textContent = '0.0';
      }

      // Global error handler
      window.showError = function(message) {
        codeEditor?.showError(message);
      };

      // Start the application
      window.addEventListener('load', initApp);
    </script>
  </body>
</html>
