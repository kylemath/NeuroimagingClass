<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="cache-buster" content="20250929-v1">
    <title>BrainImation: Live EEG + P5.js Creative Coding</title>
    <meta name="description" content="Interactive brain-computer interface art platform using real-time EEG data from Muse headsets with live P5.js coding environment.">
    
    <!-- P5.js and required libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/addons/p5.sound.min.js"></script>
    
    <!-- Muse-js for Bluetooth EEG - LOCAL BROWSER BUNDLE -->
    <script src="./muse-browser.js"></script>
    
    <!-- Monaco Editor for live coding -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
    
    <style>
      :root {
        --bg: #0a0a0a;
        --bg-2: #1a1a1a;
        --text: #e0e0e0;
        --muted: #888;
        --accent: #ff6b9d;
        --accent-2: #4ecdc4;
        --success: #4caf50;
        --warning: #ff9800;
        --error: #f44336;
        --neural: rgba(78, 205, 196, 0.3);
      }

      * { box-sizing: border-box; }
      
      body {
        margin: 0;
        padding: 0;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        background: var(--bg);
        color: var(--text);
        overflow: hidden;
        height: 100vh;
      }

      .main-container {
        display: grid;
        grid-template-columns: 1fr 1000px 500px;
        grid-template-rows: 60px 1fr auto;
        height: 100vh;
        gap: 2px;
        background: var(--bg-2);
        overflow: hidden;
      }
      
      .main-container.hide-reference {
        grid-template-columns: 1fr 200px;
      }

      .header {
        grid-column: 1 / -1;
        background: var(--bg-2);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        border-bottom: 2px solid var(--accent);
      }

      .logo {
        font-size: 24px;
        font-weight: bold;
        background: linear-gradient(45deg, var(--accent), var(--accent-2));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .controls {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .btn {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-family: inherit;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.2s;
      }

      .btn-primary {
        background: var(--accent);
        color: white;
      }
      .btn-primary:hover { background: #e55a8a; }
      .btn-primary:disabled { 
        background: #666; 
        cursor: not-allowed; 
      }

      .btn-success {
        background: var(--success);
        color: white;
      }
      .btn-success:hover { background: #45a049; }

      .btn-secondary {
        background: var(--bg);
        color: var(--text);
        border: 1px solid var(--muted);
      }
      .btn-secondary:hover { background: var(--bg-2); }

      .status {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
      }

      .status-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--muted);
        animation: pulse 2s infinite;
      }
      .status-indicator.connected { background: var(--success); }
      .status-indicator.error { background: var(--error); }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }

      .canvas-container {
        background: #000;
        position: relative;
        overflow: hidden;
      }

      /* Fullscreen mode styling */
      .canvas-container:fullscreen {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .canvas-container:-webkit-full-screen {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .canvas-container:-moz-full-screen {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .canvas-container:-ms-fullscreen {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .code-panel {
        background: var(--bg-2);
        display: flex;
        flex-direction: column;
      }

      .code-panel-tabs {
        display: flex;
        background: var(--bg);
        border-bottom: 2px solid var(--muted);
      }

      .code-panel-tab {
        padding: 10px 20px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 600;
        color: var(--muted);
        border-bottom: 3px solid transparent;
        transition: all 0.2s;
        background: var(--bg);
      }

      .code-panel-tab:hover {
        background: var(--bg-2);
        color: var(--text);
      }

      .code-panel-tab.active {
        color: var(--accent-2);
        border-bottom-color: var(--accent);
      }

      .code-panel-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .code-panel-view {
        flex: 1 1 auto;
        display: none;
        flex-direction: column;
        min-height: 0; /* Important for flex scrolling */
        overflow: hidden;
      }

      .code-panel-view.active {
        display: flex;
      }

      /* Ensure log view fills space properly */
      #log-view {
        padding: 0;
      }

      .panel-header {
        background: var(--bg);
        padding: 8px 12px;
        font-size: 12px;
        font-weight: 600;
        color: var(--accent-2);
        border-bottom: 1px solid var(--muted);
      }

      .code-editor {
        flex: 1;
        position: relative;
      }

      .eeg-data {
        background: var(--bg);
        border-top: 1px solid var(--muted);
        max-height: 250px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
      }

      .data-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
        padding: 12px;
      }

      .data-item {
        background: var(--bg-2);
        padding: 8px;
        border-radius: 4px;
        text-align: center;
        font-size: 11px;
      }

      .data-label {
        color: var(--muted);
        text-transform: uppercase;
        margin-bottom: 4px;
      }

      .data-value {
        font-size: 16px;
        font-weight: bold;
        color: var(--accent-2);
      }

      .wave-viz {
        grid-column: 1 / -1;
        height: 60px;
        background: var(--bg-2);
        border-radius: 4px;
        position: relative;
        overflow: hidden;
      }

      .examples-bar {
        background: var(--bg);
        padding: 8px 12px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 11px;
      }

      .example-selector {
        flex: 1;
        padding: 6px 10px;
        background: var(--bg-2);
        border: 1px solid var(--muted);
        border-radius: 4px;
        color: var(--text);
        font-family: inherit;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .example-selector:hover {
        border-color: var(--accent);
      }
      
      .example-selector:focus {
        outline: none;
        border-color: var(--accent);
        background: var(--bg);
      }
      
      .examples-label {
        color: var(--muted);
        white-space: nowrap;
      }


      .error-console {
        background: var(--bg);
        color: var(--error);
        padding: 8px 12px;
        font-size: 11px;
        border-top: 1px solid var(--error);
        max-height: 100px;
        overflow-y: auto;
        display: none;
      }

      /* Console Log Panel */
      .console-log-panel {
        background: var(--bg);
        padding: 8px;
        font-family: 'Monaco', 'Courier New', monospace;
        font-size: 11px;
        display: flex;
        flex-direction: column;
        gap: 4px;
        overflow: hidden;
        height: 100%;
        box-sizing: border-box;
      }

      .console-log-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 4px 8px;
        background: var(--bg-2);
        border-radius: 4px;
        margin-bottom: 4px;
        flex-shrink: 0; /* Don't let header shrink */
      }

      .console-log-title {
        color: var(--accent-2);
        font-weight: 600;
        font-size: 12px;
      }

      .console-log-clear {
        background: var(--bg);
        border: 1px solid var(--muted);
        color: var(--text);
        padding: 2px 8px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 10px;
        transition: all 0.2s;
      }

      .console-log-clear:hover {
        background: var(--accent);
        color: white;
        border-color: var(--accent);
      }

      .console-log-messages {
        flex: 1 1 0;
        overflow-y: scroll; /* Always show scrollbar */
        overflow-x: hidden;
        display: block; /* Use block instead of flex for simpler scrolling */
        padding: 4px;
        scroll-behavior: smooth;
        min-height: 0;
      }
      
      .console-log-messages::-webkit-scrollbar {
        width: 10px;
      }
      
      .console-log-messages::-webkit-scrollbar-track {
        background: var(--bg);
        border-radius: 4px;
        margin: 4px;
      }
      
      .console-log-messages::-webkit-scrollbar-thumb {
        background: var(--accent-2);
        border-radius: 4px;
        border: 2px solid var(--bg);
      }
      
      .console-log-messages::-webkit-scrollbar-thumb:hover {
        background: var(--accent);
      }

      /* For Firefox */
      .console-log-messages {
        scrollbar-width: thin;
        scrollbar-color: var(--accent-2) var(--bg);
      }

      .log-message {
        padding: 4px 8px;
        margin-bottom: 2px;
        border-radius: 3px;
        background: var(--bg-2);
        border-left: 3px solid;
        word-wrap: break-word;
        word-break: break-word;
        animation: slideIn 0.2s ease-out;
        line-height: 1.4;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(-10px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .log-message.log-info {
        border-left-color: var(--accent-2);
        color: var(--text);
      }

      .log-message.log-success {
        border-left-color: var(--success);
        color: var(--success);
      }

      .log-message.log-warning {
        border-left-color: var(--warning);
        color: var(--warning);
      }

      .log-message.log-error {
        border-left-color: var(--error);
        color: var(--error);
        font-weight: 600;
      }

      .log-timestamp {
        opacity: 0.6;
        font-size: 9px;
        margin-right: 6px;
      }

      .reference-panel {
        background: var(--bg-2);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        grid-row: 2 / 4;
      }
      
      .main-container.hide-reference .reference-panel {
        display: none;
      }
      
      .reference-tabs {
        display: flex;
        background: var(--bg);
        border-bottom: 1px solid var(--muted);
      }
      
      .reference-tab {
        padding: 8px 12px;
        cursor: pointer;
        font-size: 11px;
        border-bottom: 2px solid transparent;
        transition: all 0.2s;
        flex: 1;
        text-align: center;
      }
      
      .reference-tab:hover {
        background: var(--bg-2);
      }
      
      .reference-tab.active {
        border-bottom-color: var(--accent);
        color: var(--accent);
      }
      
      .reference-content {
        flex: 1;
        overflow-y: auto;
        padding: 12px;
        font-size: 11px;
      }
      
      .function-group {
        margin-bottom: 16px;
      }
      
      .function-group-title {
        color: var(--accent-2);
        font-weight: 600;
        margin-bottom: 6px;
        font-size: 12px;
      }
      
      .function-item {
        padding: 4px 8px;
        margin: 2px 0;
        background: var(--bg);
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.2s ease;
        border: 1px solid transparent;
        overflow: hidden;
      }
      
      .function-item:hover {
        background: var(--bg-2);
        border-color: var(--accent);
        transform: translateX(2px);
      }
      
      .function-item.expanded {
        background: var(--accent);
        color: white;
        border-color: var(--accent);
      }
      
      .function-name {
        font-family: 'Courier New', monospace;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 2px 0;
      }
      
      .function-name::after {
        content: '▶';
        font-size: 8px;
        color: var(--muted);
        transition: transform 0.2s ease;
        margin-left: 8px;
      }
      
      .function-item.expanded .function-name::after {
        transform: rotate(90deg);
        color: white;
      }
      
      .function-tooltip {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
        padding: 0;
        margin: 0;
        opacity: 0;
      }
      
      .function-item.expanded .function-tooltip {
        max-height: 500px;
        padding-top: 8px;
        margin-top: 4px;
        border-top: 1px solid rgba(255,255,255,0.3);
        opacity: 1;
      }
      
      .tooltip-signature {
        font-family: 'Courier New', monospace;
        color: var(--accent-2);
        margin-bottom: 4px;
        font-size: 10px;
        font-weight: 600;
        word-wrap: break-word;
      }
      
      .function-item.expanded .tooltip-signature {
        color: white;
        opacity: 0.9;
      }
      
      .tooltip-description {
        color: var(--text);
        line-height: 1.5;
        font-size: 10px;
        word-wrap: break-word;
      }
      
      .function-item.expanded .tooltip-description {
        color: white;
        opacity: 0.85;
      }
      
      .function-item.code-inserted {
        animation: codeInserted 0.5s ease;
      }
      
      @keyframes codeInserted {
        0% {
          transform: scale(1);
          background: var(--accent);
        }
        50% {
          transform: scale(1.05);
          background: var(--success);
        }
        100% {
          transform: scale(1);
          background: var(--accent);
        }
      }
      
      .ai-assistant {
        background: var(--bg);
        padding: 12px;
        border-top: 2px solid var(--accent);
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      
      .ai-input {
        background: var(--bg-2);
        border: 1px solid var(--muted);
        color: var(--text);
        padding: 8px;
        border-radius: 4px;
        font-family: inherit;
        font-size: 11px;
        resize: vertical;
        min-height: 60px;
      }
      
      .ai-input:focus {
        outline: none;
        border-color: var(--accent);
      }
      
      .ai-buttons {
        display: flex;
        gap: 6px;
      }
      
      .ai-status {
        font-size: 10px;
        color: var(--muted);
        font-style: italic;
      }
      
      .toggle-reference {
        background: var(--bg);
        color: var(--accent-2);
        border: 1px solid var(--accent-2);
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s;
      }
      
      .toggle-reference:hover {
        background: var(--accent-2);
        color: var(--bg);
      }

      @media (max-width: 1200px) {
        .main-container {
          grid-template-columns: 1fr 400px;
        }
        .reference-panel {
          display: none;
        }
      }

      @media (max-width: 768px) {
        .main-container {
          grid-template-columns: 1fr;
          grid-template-rows: 60px 300px 1fr auto;
          overflow-y: auto;
        }
        .code-panel {
          grid-row: 3;
          min-height: 200px;
        }
        .canvas-container {
          grid-row: 2;
        }
        .eeg-data {
          max-height: 200px;
        }
        .reference-panel {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="main-container">
      <!-- Header -->
      <div class="header">
        <div class="logo">🧠 BrainImation</div>
        <div class="controls">
          <div style="display:flex;align-items:center;gap:8px;margin-right:16px;font-size:12px;">
            <a href="./index.html" style="color: var(--accent-2); text-decoration: none;">Course Home</a>
            <span style="color: var(--muted);">|</span>
            <a href="./lecture3.html" style="color: var(--accent-2); text-decoration: none;">← Lecture 3</a>
          </div>
          <div class="status">
            <div class="status-indicator" id="muse-status"></div>
            <span id="status-text">Disconnected</span>
          </div>
          <button class="btn btn-primary" id="connect-btn">Connect Muse</button>
          <button class="btn btn-secondary" id="simulate-btn">Simulate Data</button>
          <button class="btn btn-success" id="run-btn">Run Code</button>
          <button class="btn btn-secondary" id="save-btn">💾 Save</button>
          <button class="btn btn-secondary" id="load-btn">📁 Load</button>
          <button class="btn btn-secondary" id="reload-btn" disabled>🔄 Reload</button>
          <button class="btn btn-secondary" id="fullscreen-btn">Fullscreen</button>
          <button class="btn btn-secondary" id="test-sound-btn">🔊 Test Sound</button>
          <button class="toggle-reference" id="toggle-reference-btn">📖 Reference</button>
          <input type="file" id="file-input" accept=".js" style="display: none;">
        </div>
      </div>

      <!-- Canvas -->
      <div class="canvas-container" id="canvas-container"></div>

      <!-- Code Editor Panel -->
      <div class="code-panel">
        <div class="code-panel-tabs">
          <div class="code-panel-tab active" data-panel="code">💻 Code Editor</div>
          <div class="code-panel-tab" data-panel="log">📋 System Log</div>
        </div>
        <div class="code-panel-content">
          <!-- Code Editor View -->
          <div class="code-panel-view active" id="code-view">
            <div class="examples-bar">
              <label for="example-selector" class="examples-label">Example Animations:</label>
              <select id="example-selector" class="example-selector">
                <option value="">-- Select an Example --</option>
                <optgroup label="Getting Started">
                  <option value="basic">Basic Animation</option>
                  <option value="basicShapes">Basic Shapes</option>
                  <option value="functionExample">Function Example</option>
                </optgroup>
            <optgroup label="Brain Wave Visualizations">
              <option value="alpha">Alpha Waves</option>
              <option value="waves">Wave Visualization</option>
              <option value="BasicFrequencyBands">Basic Frequency Bands</option>
              <option value="bandOrbitz">Band Orbitz</option>
              <option value="piWedges">Pi Wedges</option>
              <option value="spectra">Spectra</option>
            </optgroup>
            <optgroup label="Attention & Meditation">
              <option value="attention">Attention Meter</option>
              <option value="mandala">Neural Mandala</option>
            </optgroup>
            <optgroup label="Particle Systems">
              <option value="particles">Brain Particles</option>
              <option value="ColourBalls">Colour Balls</option>
              <option value="MultipleBalls">Multiple Balls</option>
            </optgroup>
            <optgroup label="3D & Advanced">
              <option value="3dTorus">3D Torus</option>
              <option value="AlphaSnake">Alpha Snake</option>
              <option value="SplineBounce">Spline Bounce</option>
            </optgroup>
            <optgroup label="Drawing & Interaction">
              <option value="BrainDraw">Brain Draw</option>
              <option value="bouncingLine">Bouncing Line</option>
              <option value="ghostLines">Ghost Lines</option>
            </optgroup>
            <optgroup label="Raw EEG Data">
              <option value="eegtrace">EEG Trace</option>
              <option value="multichannel">Multi-Channel EEG</option>
              <option value="epochs">Epoch View</option>
            </optgroup>
            <optgroup label="Noise & Generative">
              <option value="perlinNoise">Perlin Noise</option>
              <option value="organicHeatmap">Organic Heatmap</option>
              <option value="noiseDetail">Noise With Detail</option>
              <option value="discreteColors">Discrete Colors</option>
              <option value="smoothColors">Smooth Colors</option>
              <option value="animatingNoise">Animating Noise</option>
            </optgroup>
            <optgroup label="Animation & Motion">
              <option value="bouncingCircles">Bouncing Circles</option>
              <option value="waveAnimation">Wave Animation</option>
              <option value="colorfulGrid">Animated Grid</option>
              <option value="webcamInput">Webcam Input</option>
            </optgroup>
            <optgroup label="Sound & Music">
              <option value="brainBeats">Brain Beats (Sound Test)</option>
              <option value="alphaMusic">Alpha Wave Music</option>
              <option value="brainSynth">Brain Synthesizer</option>
            </optgroup>
              </select>
            </div>
            <div class="code-editor" id="code-editor"></div>
            <div class="error-console" id="error-console"></div>
          </div>

          <!-- System Log View -->
          <div class="code-panel-view" id="log-view">
            <div class="console-log-panel" id="console-log-panel">
              <div class="console-log-header">
                <div class="console-log-title">📋 System Log</div>
                <button class="console-log-clear" id="clear-log-btn">Clear</button>
              </div>
              <div class="console-log-messages" id="log-messages">
                <div class="log-message log-info">
                  <span class="log-timestamp">[Ready]</span>
                  System Log initialized. Messages appear from oldest (top) to newest (bottom). Scroll to view history.
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Reference Panel -->
      <div class="reference-panel" id="reference-panel">
        <div class="reference-tabs">
          <div class="reference-tab active" data-tab="p5js">P5.js</div>
          <div class="reference-tab" data-tab="sound">Sound</div>
          <div class="reference-tab" data-tab="input">Input</div>
          <div class="reference-tab" data-tab="eeg">EEG Data</div>
          <div class="reference-tab" data-tab="ai">AI Helper</div>
        </div>
        
        <div class="reference-content" id="reference-content">
          <!-- Content will be dynamically loaded -->
        </div>
        
        <!-- AI Assistant at bottom -->
        <div class="ai-assistant" id="ai-assistant" style="display: none;">
          <div style="font-size: 12px; font-weight: 600; color: var(--accent);">🤖 AI Code Assistant</div>
          <textarea class="ai-input" id="ai-prompt" placeholder="Describe what you want to change or add...&#10;e.g., 'Add a particle system that responds to alpha waves'&#10;'Change the colors to be more vibrant'&#10;'Make the animation slower'"></textarea>
          <div class="ai-buttons">
            <button class="btn btn-primary" id="ai-generate-btn" style="flex: 1;">Generate Code</button>
            <button class="btn btn-secondary" id="ai-config-btn">⚙️</button>
          </div>
          <div class="ai-status" id="ai-status">Configure API key to use AI features</div>
        </div>
      </div>

      <!-- EEG Data Display -->
      <div class="eeg-data">
        <div class="panel-header">Real-time Brain Data</div>
        <div class="data-grid">
          <div class="data-item">
            <div class="data-label">Alpha</div>
            <div class="data-value" id="alpha-value">0.0</div>
          </div>
          <div class="data-item">
            <div class="data-label">Beta</div>
            <div class="data-value" id="beta-value">0.0</div>
          </div>
          <div class="data-item">
            <div class="data-label">Theta</div>
            <div class="data-value" id="theta-value">0.0</div>
          </div>
          <div class="data-item">
            <div class="data-label">Delta</div>
            <div class="data-value" id="delta-value">0.0</div>
          </div>
          <div class="wave-viz" id="wave-viz"></div>
        </div>
        
        <!-- Simulation Controls -->
        <div id="sim-controls" style="display: none; padding: 12px; border-top: 1px solid var(--muted); background: var(--bg-2);">
          <div style="font-size: 11px; color: var(--accent-2); margin-bottom: 8px; font-weight: 600;">🎛️ SIMULATION CONTROLS</div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
            <div>
              <label style="color: var(--muted);">Attention:</label>
              <input type="range" id="sim-attention" min="0" max="1" step="0.1" value="0.5" 
                     style="width: 100%; margin-top: 2px;">
              <span id="sim-attention-val" style="color: var(--accent-2);">0.5</span>
            </div>
            <div>
              <label style="color: var(--muted);">Meditation:</label>
              <input type="range" id="sim-meditation" min="0" max="1" step="0.1" value="0.3" 
                     style="width: 100%; margin-top: 2px;">
              <span id="sim-meditation-val" style="color: var(--accent-2);">0.3</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ============================================
      // VISIBLE CONSOLE LOGGING SYSTEM
      // ============================================
      class ConsoleLogger {
        constructor() {
          this.logContainer = null;
          this.maxMessages = 100;
          this.originalConsole = {
            log: console.log.bind(console),
            error: console.error.bind(console),
            warn: console.warn.bind(console),
            info: console.info.bind(console)
          };
          this.init();
        }

        init() {
          // Wait for DOM to be ready
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.setupLogging());
          } else {
            this.setupLogging();
          }
        }

        setupLogging() {
          this.logContainer = document.getElementById('log-messages');
          
          // Setup clear button
          const clearBtn = document.getElementById('clear-log-btn');
          if (clearBtn) {
            clearBtn.addEventListener('click', () => this.clear());
          }

          // Override console methods
          console.log = (...args) => {
            this.originalConsole.log(...args);
            this.addMessage(this.formatArgs(args), 'info');
          };

          console.error = (...args) => {
            this.originalConsole.error(...args);
            this.addMessage(this.formatArgs(args), 'error');
          };

          console.warn = (...args) => {
            this.originalConsole.warn(...args);
            this.addMessage(this.formatArgs(args), 'warning');
          };

          console.info = (...args) => {
            this.originalConsole.info(...args);
            this.addMessage(this.formatArgs(args), 'info');
          };

          // Catch uncaught runtime errors
          window.addEventListener('error', (event) => {
            const errorMsg = `❌ Runtime Error: ${event.message}`;
            const location = event.filename ? ` at line ${event.lineno}` : '';
            this.addMessage(errorMsg + location, 'error');
            
            // Try to extract more details about the error
            if (event.error && event.error.stack) {
              const stackLines = event.error.stack.split('\n').slice(0, 3); // First 3 lines
              stackLines.forEach(line => {
                if (line.trim()) {
                  this.addMessage('  ' + line.trim(), 'error');
                }
              });
            }
          });

          // Catch unhandled promise rejections
          window.addEventListener('unhandledrejection', (event) => {
            const errorMsg = `❌ Unhandled Promise Rejection: ${event.reason}`;
            this.addMessage(errorMsg, 'error');
          });

          this.log('✅ Console logging system initialized', 'success');
        }

        formatArgs(args) {
          return args.map(arg => {
            if (typeof arg === 'object') {
              try {
                return JSON.stringify(arg, null, 2);
              } catch (e) {
                return String(arg);
              }
            }
            return String(arg);
          }).join(' ');
        }

        addMessage(message, type = 'info') {
          if (!this.logContainer) return;

          const logEntry = document.createElement('div');
          logEntry.className = `log-message log-${type}`;
          
          const timestamp = new Date().toLocaleTimeString('en-US', { 
            hour12: false, 
            hour: '2-digit', 
            minute: '2-digit', 
            second: '2-digit' 
          });
          
          logEntry.innerHTML = `
            <span class="log-timestamp">[${timestamp}]</span>
            ${this.escapeHtml(message)}
          `;

          // Check if user was scrolled to bottom before adding message
          const wasAtBottom = this.logContainer.scrollHeight - this.logContainer.scrollTop <= this.logContainer.clientHeight + 50;

          // Add new message at the bottom
          this.logContainer.appendChild(logEntry);

          // Keep only last N messages
          while (this.logContainer.children.length > this.maxMessages) {
            this.logContainer.removeChild(this.logContainer.firstChild);
          }

          // Auto-scroll to bottom only if user was at bottom (or close to it)
          // This prevents interrupting if user is reading older messages
          if (wasAtBottom || type === 'error') {
            // Small delay to ensure DOM has updated
            requestAnimationFrame(() => {
              this.logContainer.scrollTop = this.logContainer.scrollHeight;
            });
          }

          // Auto-switch to log tab on errors
          if (type === 'error' && window.codePanelTabs) {
            // Small delay to ensure tab manager is initialized
            setTimeout(() => {
              if (codePanelTabs.currentTab !== 'log') {
                codePanelTabs.switchTab('log');
                // Add a visual indicator
                const logTab = document.querySelector('[data-panel="log"]');
                if (logTab) {
                  logTab.style.animation = 'pulse 1s ease-in-out 3';
                }
              }
            }, 100);
          }
        }

        log(message, type = 'info') {
          this.addMessage(message, type);
        }

        escapeHtml(text) {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        }

        clear() {
          if (this.logContainer) {
            this.logContainer.innerHTML = '';
            this.addMessage('Console cleared', 'info');
            // Ensure we're at the bottom after clearing
            requestAnimationFrame(() => {
              this.logContainer.scrollTop = this.logContainer.scrollHeight;
            });
          }
        }
      }

      // Initialize the logger immediately
      const logger = new ConsoleLogger();

      // ============================================
      // BRAINIMATION - MAIN APPLICATION
      // ============================================
      // Note: Console logging is now handled by the ConsoleLogger class above
      // All console.log, console.error, console.warn messages will appear in the System Log panel
      
      // Global variables for EEG data access in p5 sketches
      let eegData = {
        // Frequency bands (existing)
        alpha: 0,
        beta: 0,
        theta: 0,
        delta: 0,
        gamma: 0,
        
        // Current samples (existing - keep for compatibility)
        raw: [0, 0, 0, 0], // TP9, AF7, AF8, TP10 current values
        
        // Enhanced raw data access (NEW)
        rawHistory: {
          TP9: [],    // Array of recent samples
          AF7: [],    // Array of recent samples  
          AF8: [],    // Array of recent samples
          TP10: []    // Array of recent samples
        },
        
        // Configuration
        historyLength: 1000,  // ~4 seconds at 256Hz
        sampleRate: 256,      // Samples per second
        
        // Derived metrics (existing)
        attention: 0,
        meditation: 0,
        connected: false,
        
        // Helper functions for accessing raw data in animations
        getRawChannel: function(channel, numSamples = 100) {
          const channelData = this.rawHistory[channel] || [];
          return channelData.slice(-numSamples);
        },
        
        getAllChannels: function(numSamples = 100) {
          return {
            TP9: this.getRawChannel('TP9', numSamples),
            AF7: this.getRawChannel('AF7', numSamples),
            AF8: this.getRawChannel('AF8', numSamples),
            TP10: this.getRawChannel('TP10', numSamples)
          };
        },
        
        getChannelNames: function() {
          return ['TP9', 'AF7', 'AF8', 'TP10'];
        },
        
        // Get the most recent N samples across all channels
        getRecentEpoch: function(numSamples = 100) {
          const channels = this.getAllChannels(numSamples);
          const epoch = [];
          
          // Transpose data so each time point has all 4 channels
          for (let i = 0; i < numSamples; i++) {
            epoch.push([
              channels.TP9[i] || 0,
              channels.AF7[i] || 0,
              channels.AF8[i] || 0,
              channels.TP10[i] || 0
            ]);
          }
          return epoch;
        }
      };

      // EEG Data Simulator for demonstration purposes
      class EEGSimulator {
        constructor() {
          this.isRunning = false;
          this.startTime = Date.now();
          this.updateInterval = null;
          this.baseAttention = 0.5;
          this.baseMeditation = 0.3;
          this.noiseLevel = 0.1;
        }

        start() {
          this.isRunning = true;
          this.startTime = Date.now();
          
          // Update data every 50ms (20 Hz)
          this.updateInterval = setInterval(() => {
            this.generateData();
          }, 50);
        }

        stop() {
          this.isRunning = false;
          if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
          }
        }

        setAttention(value) {
          this.baseAttention = parseFloat(value);
        }

        setMeditation(value) {
          this.baseMeditation = parseFloat(value);
        }

        generateData() {
          const time = (Date.now() - this.startTime) / 1000; // seconds
          
          // Generate realistic brain wave patterns with some natural variation
          const noise = () => (Math.random() - 0.5) * this.noiseLevel;
          
          // Alpha waves (8-12 Hz) - stronger during meditation/relaxed attention
          const alphaBase = this.baseMeditation * 0.8 + 0.1;
          eegData.alpha = Math.max(0, Math.min(1, 
            alphaBase + Math.sin(time * 10) * 0.1 + noise()
          ));
          
          // Beta waves (13-30 Hz) - stronger during active attention/concentration
          const betaBase = this.baseAttention * 0.7 + 0.2;
          eegData.beta = Math.max(0, Math.min(1, 
            betaBase + Math.sin(time * 20) * 0.15 + noise()
          ));
          
          // Theta waves (4-8 Hz) - stronger during deep meditation/creativity
          const thetaBase = this.baseMeditation * 0.6 + 0.1;
          eegData.theta = Math.max(0, Math.min(1, 
            thetaBase + Math.sin(time * 6) * 0.12 + noise()
          ));
          
          // Delta waves (0.5-4 Hz) - low during awake states
          eegData.delta = Math.max(0, Math.min(1, 
            0.1 + Math.sin(time * 2) * 0.05 + noise()
          ));
          
          // Gamma waves (30+ Hz) - bursts during high-level cognition
          eegData.gamma = Math.max(0, Math.min(1, 
            0.2 + Math.sin(time * 40) * this.baseAttention * 0.3 + noise()
          ));
          
          // Generate realistic raw EEG samples for each channel
          const channels = ['TP9', 'AF7', 'AF8', 'TP10'];
          for (let i = 0; i < 4; i++) {
            const channel = channels[i];
            
            // Create realistic EEG signal combining multiple frequency components
            let sample = 0;
            
            // Alpha component (8-12 Hz)
            sample += Math.sin(time * 2 * Math.PI * (9 + i * 0.5)) * eegData.alpha * 30;
            
            // Beta component (15-25 Hz)  
            sample += Math.sin(time * 2 * Math.PI * (18 + i * 1.5)) * eegData.beta * 20;
            
            // Theta component (4-8 Hz)
            sample += Math.sin(time * 2 * Math.PI * (6 + i * 0.3)) * eegData.theta * 25;
            
            // Delta component (1-4 Hz)
            sample += Math.sin(time * 2 * Math.PI * (2 + i * 0.2)) * eegData.delta * 40;
            
            // Gamma component (30-40 Hz)
            sample += Math.sin(time * 2 * Math.PI * (35 + i * 2)) * eegData.gamma * 10;
            
            // Add some 1/f noise and artifacts
            sample += noise() * 15; // High-frequency noise
            sample += Math.sin(time * 2 * Math.PI * 0.1) * 5; // Slow drift
            
            // Occasional "blink" artifacts (more prominent in frontal channels)
            if (i >= 1 && i <= 2 && Math.random() < 0.001) { // AF7, AF8
              sample += (Math.random() - 0.5) * 200;
            }
            
            // Store current sample for compatibility
            eegData.raw[i] = sample;
            
            // Add to history buffer
            if (!eegData.rawHistory[channel]) {
              eegData.rawHistory[channel] = [];
            }
            eegData.rawHistory[channel].push(sample);
            
            // Maintain buffer size
            if (eegData.rawHistory[channel].length > eegData.historyLength) {
              eegData.rawHistory[channel] = eegData.rawHistory[channel].slice(-eegData.historyLength);
            }
          }
          
          // Calculate derived metrics
          eegData.attention = Math.max(0, Math.min(1, 
            this.baseAttention + Math.sin(time * 0.5) * 0.1 + noise() * 0.05
          ));
          
          eegData.meditation = Math.max(0, Math.min(1, 
            this.baseMeditation + Math.cos(time * 0.3) * 0.1 + noise() * 0.05
          ));
          
          eegData.connected = true;
          this.updateDataDisplay();
        }

        updateDataDisplay() {
          document.getElementById('alpha-value').textContent = eegData.alpha.toFixed(2);
          document.getElementById('beta-value').textContent = eegData.beta.toFixed(2);
          document.getElementById('theta-value').textContent = eegData.theta.toFixed(2);
          document.getElementById('delta-value').textContent = eegData.delta.toFixed(2);
        }
      }

      // Muse connection and data processing
      class MuseEEGManager {
        constructor() {
          this.muse = null;
          this.isConnected = false;
          this.dataBuffer = [];
          this.samplingRate = 256;
          this.bufferSize = 256; // 1 second of data
          this.subscriptions = [];
        }

        async connect() {
          try {
            logger.log('🔌 === ATTEMPTING TO CONNECT TO MUSE ===', 'info');
            
            // Step 1: Check Web Bluetooth support
            logger.log('Step 1: Checking Web Bluetooth support...', 'info');
            if (!navigator.bluetooth) {
              throw new Error('Web Bluetooth is not supported in this browser. Please use Chrome, Edge, or Opera.');
            }
            logger.log('✅ Web Bluetooth is supported', 'success');
            
            // Step 2: Verify the library is loaded
            logger.log('Step 2: Checking if muse-js library is loaded...', 'info');
            if (!window.muse) {
              throw new Error('muse-js library not loaded! The script may have failed to load from CDN. Check your internet connection.');
            }
            
            if (!window.muse.MuseClient) {
              throw new Error('MuseClient not found in muse-js library! The library may be corrupted or outdated.');
            }
            
            logger.log('✅ muse-js library is loaded correctly', 'success');
            
            // Step 3: Create MuseClient instance
            logger.log('Step 3: Creating MuseClient instance...', 'info');
            this.muse = new window.muse.MuseClient();
            logger.log('✅ MuseClient created successfully', 'success');
            
            // Don't enable PPG by default - it's only available on Muse 2 and Muse S
            // Enabling it causes connection failures on Muse 2016 devices
            // this.muse.enablePpg = false; // Default is already false
            
            // Step 4: Request device pairing
            logger.log('Step 4: Opening Bluetooth device selector...', 'info');
            logger.log('👉 Please select your Muse device from the popup', 'info');
            
            await this.muse.connect();
            logger.log('✅ Device paired successfully', 'success');
            
            // Step 5: Set up data subscriptions
            logger.log('Step 5: Setting up data subscriptions...', 'info');
            
            // EEG data subscription
            const eegSubscription = this.muse.eegReadings.subscribe(reading => {
              this.processEEGReading(reading);
            });
            this.subscriptions.push(eegSubscription);
            logger.log('✅ EEG data subscription active', 'success');

            // Accelerometer subscription (optional)
            const accelSubscription = this.muse.accelerometerData.subscribe(accel => {
              // Movement detection could be added here
            });
            this.subscriptions.push(accelSubscription);

            // Telemetry subscription (battery, temperature, etc.)
            const telemetrySubscription = this.muse.telemetryData.subscribe(telemetry => {
              if (telemetry.batteryLevel !== undefined) {
                logger.log(`🔋 Battery Level: ${telemetry.batteryLevel.toFixed(1)}%`, 'success');
              }
            });
            this.subscriptions.push(telemetrySubscription);

            // Connection status subscription
            const statusSubscription = this.muse.connectionStatus.subscribe(status => {
              if (!status) {
                logger.log('⚠️ Connection lost! Please check your device.', 'error');
                this.isConnected = false;
                eegData.connected = false;
                this.updateStatus('Connection lost', 'error');
              }
            });
            this.subscriptions.push(statusSubscription);
            
            logger.log('✅ All subscriptions configured', 'success');

            // Step 6: Start the data stream
            logger.log('Step 6: Starting EEG data stream...', 'info');
            await this.muse.start();
            
            this.isConnected = true;
            eegData.connected = true;
            this.updateStatus('Connected to Muse', 'connected');

            logger.log('🎉 SUCCESS! Muse is connected and streaming data', 'success');
            logger.log('You should now see brain wave data updating above', 'success');
            
          } catch (error) {
            logger.log('❌ Connection failed: ' + error.message, 'error');
            this.isConnected = false;
            eegData.connected = false;
            
            // Provide helpful error messages based on error type
            let errorMsg = 'Connection failed';
            let helpText = '';
            
            if (error.name === 'NotFoundError' || error.message.includes('cancelled')) {
              errorMsg = 'No device selected';
              helpText = '💡 Tip: Make sure to select a Muse device from the Bluetooth pairing dialog.';
            } else if (error.message.includes('Bluetooth') || error.message.includes('GATT')) {
              errorMsg = 'Bluetooth connection failed';
              helpText = '💡 Troubleshooting steps:\n' +
                        '1. Make sure your Muse device is charged and turned on\n' +
                        '2. Ensure Bluetooth is enabled on your computer\n' +
                        '3. Try turning the Muse device off and on again\n' +
                        '4. Move closer to the device (within 10 feet)';
            } else if (error.message.includes('not supported')) {
              errorMsg = 'Browser not compatible';
              helpText = '💡 Please use Chrome, Edge, or Opera browser to connect to Muse devices.';
            } else if (error.message.includes('library')) {
              errorMsg = 'Library loading error';
              helpText = '💡 The muse-js library failed to load. Check your internet connection and refresh the page.';
            } else {
              errorMsg = `Connection error: ${error.message}`;
              helpText = '💡 Try refreshing the page and attempting to connect again.';
            }
            
            this.updateStatus(errorMsg, 'error');
            logger.log(helpText, 'warning');
            
            throw error;
          }
        }

        processEEGReading(reading) {
          // Map numeric electrode indices to channel names
          // Muse sends: 0 = TP9, 1 = AF7, 2 = AF8, 3 = TP10
          const electrodeMap = ['TP9', 'AF7', 'AF8', 'TP10'];
          const electrodeName = typeof reading.electrode === 'number' 
            ? electrodeMap[reading.electrode] 
            : reading.electrode;
          
          // Log first few readings to confirm data flow
          if (this.dataBuffer.length < 5) {
            logger.log(`📊 EEG data received from ${electrodeName}: ${reading.samples.length} samples, first value: ${reading.samples[0]?.toFixed(2)} µV`, 'success');
          }
          
          // Log when all channels have sent data
          if (this.dataBuffer.length === 4) {
            logger.log('✅ All 4 EEG channels are transmitting data successfully!', 'success');
          }
          
          // Add to buffer for frequency analysis (use mapped name)
          this.dataBuffer.push({
            electrode: electrodeName,
            samples: reading.samples,
            timestamp: Date.now()
          });

          // Keep buffer size manageable
          if (this.dataBuffer.length > this.bufferSize * 4) { // 4 electrodes
            this.dataBuffer = this.dataBuffer.slice(-this.bufferSize * 4);
          }

          // Update raw values for immediate access (compatibility)
          const electrodeIndex = typeof reading.electrode === 'number' 
            ? reading.electrode 
            : electrodeMap.indexOf(reading.electrode);
          
          if (electrodeIndex !== -1 && reading.samples.length > 0) {
            eegData.raw[electrodeIndex] = reading.samples[reading.samples.length - 1];
          }

          // NEW: Add ALL samples to raw history for time-series access
          if (!eegData.rawHistory[electrodeName]) {
            eegData.rawHistory[electrodeName] = [];
          }
          
          // Add all samples from this reading (usually 12 samples per packet)
          eegData.rawHistory[electrodeName].push(...reading.samples);
          
          // Maintain buffer size (keep last N samples)
          if (eegData.rawHistory[electrodeName].length > eegData.historyLength) {
            eegData.rawHistory[electrodeName] = eegData.rawHistory[electrodeName].slice(-eegData.historyLength);
          }

          // Calculate frequency bands every few samples
          if (this.dataBuffer.length % 32 === 0) {
            this.calculateFrequencyBands();
          }
          
          // Update status to show data is flowing (every 100 packets)
          if (this.dataBuffer.length % 100 === 0) {
            const dataRate = (this.dataBuffer.length / 4).toFixed(0); // packets per electrode
            this.updateStatus(`Connected (${dataRate} packets/ch)`, 'connected');
          }
        }

        calculateFrequencyBands() {
          // Simple frequency band calculation
          // In a real implementation, you'd use FFT
          const recentData = this.dataBuffer.slice(-64); // Last 64 samples per electrode
          
          if (recentData.length < 64) return;

          // Group by electrode
          const electrodeData = { TP9: [], AF7: [], AF8: [], TP10: [] };
          recentData.forEach(reading => {
            if (electrodeData[reading.electrode]) {
              electrodeData[reading.electrode].push(...reading.samples);
            }
          });

          // Calculate power in different bands (simplified)
          // Average across all electrodes for more stable estimates
          let totalVariance = 0;
          let totalMean = 0;
          let electrodeCount = 0;
          
          Object.keys(electrodeData).forEach(electrode => {
            const samples = electrodeData[electrode].slice(-64);
            if (samples.length >= 64) {
              // Simplified band power calculation
              const variance = this.calculateVariance(samples);
              const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
              
              totalVariance += variance;
              totalMean += Math.abs(mean);
              electrodeCount++;
            }
          });
          
          if (electrodeCount > 0) {
            // Average variance and mean across electrodes
            const avgVariance = totalVariance / electrodeCount;
            const avgMean = totalMean / electrodeCount;
            
            // Update frequency bands (this is a simplified approach)
            // Scale factors adjusted based on typical EEG variance values
            eegData.alpha = Math.max(0, Math.min(1, avgVariance * 0.001));
            eegData.beta = Math.max(0, Math.min(1, avgVariance * 0.0008));
            eegData.theta = Math.max(0, Math.min(1, avgVariance * 0.0012));
            eegData.delta = Math.max(0, Math.min(1, avgVariance * 0.0015));
            eegData.gamma = Math.max(0, Math.min(1, avgVariance * 0.0005));
            
            // Calculate attention and meditation (simplified)
            eegData.attention = Math.max(0, Math.min(1, (eegData.beta + eegData.gamma) / 2));
            eegData.meditation = Math.max(0, Math.min(1, (eegData.alpha + eegData.theta) / 2));
            
            // Debug log every 10 calculations
            if (this.dataBuffer.length % 320 === 0) {
              console.log('📊 Frequency bands updated:', {
                alpha: eegData.alpha.toFixed(3),
                beta: eegData.beta.toFixed(3),
                theta: eegData.theta.toFixed(3),
                variance: avgVariance.toFixed(2)
              });
            }
          }

          eegData.connected = this.isConnected;
          this.updateDataDisplay();
        }

        calculateVariance(samples) {
          const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
          const variance = samples.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / samples.length;
          return Math.sqrt(variance);
        }

        updateStatus(text, status) {
          document.getElementById('status-text').textContent = text;
          const indicator = document.getElementById('muse-status');
          indicator.className = `status-indicator ${status}`;
        }

        updateDataDisplay() {
          document.getElementById('alpha-value').textContent = eegData.alpha.toFixed(2);
          document.getElementById('beta-value').textContent = eegData.beta.toFixed(2);
          document.getElementById('theta-value').textContent = eegData.theta.toFixed(2);
          document.getElementById('delta-value').textContent = eegData.delta.toFixed(2);
        }

        disconnect() {
          logger.log('🔌 Disconnecting from Muse...', 'info');
          
          // Unsubscribe from all subscriptions
          if (this.subscriptions && this.subscriptions.length > 0) {
            logger.log(`Unsubscribing from ${this.subscriptions.length} data subscriptions`, 'info');
            this.subscriptions.forEach(sub => {
              try {
                sub.unsubscribe();
              } catch (e) {
                logger.log('Warning during unsubscribe: ' + e.message, 'warning');
              }
            });
            this.subscriptions = [];
            logger.log('✅ All subscriptions closed', 'success');
          }
          
          // Disconnect the device
          if (this.muse) {
            try {
              this.muse.disconnect();
              logger.log('✅ Muse device disconnected successfully', 'success');
            } catch (e) {
              logger.log('Warning during disconnect: ' + e.message, 'warning');
            }
            this.muse = null;
          }
          
          this.isConnected = false;
          eegData.connected = false;
          this.updateStatus('Disconnected', '');
          logger.log('Ready to connect to a new device', 'info');
        }
      }

      // P5.js Function Reference Database
      const p5Reference = {
        'Drawing': {
          'ellipse': {
            signature: 'ellipse(x, y, width, [height])',
            description: 'Draws an ellipse (oval) to the screen. By default, the first two parameters set the location, and the third and fourth parameters set the shape\'s width and height.'
          },
          'circle': {
            signature: 'circle(x, y, diameter)',
            description: 'Draws a circle to the screen. A circle is a simple closed shape, by default drawn from the center point.'
          },
          'rect': {
            signature: 'rect(x, y, width, height, [tl], [tr], [br], [bl])',
            description: 'Draws a rectangle to the screen. Optional parameters for rounded corners.'
          },
          'square': {
            signature: 'square(x, y, size, [tl], [tr], [br], [bl])',
            description: 'Draws a square to the screen. A square is a four-sided shape with equal sides.'
          },
          'triangle': {
            signature: 'triangle(x1, y1, x2, y2, x3, y3)',
            description: 'Draws a triangle to the screen. A triangle is a plane created by connecting three points.'
          },
          'quad': {
            signature: 'quad(x1, y1, x2, y2, x3, y3, x4, y4)',
            description: 'Draws a quadrilateral (four-sided polygon) to the screen.'
          },
          'line': {
            signature: 'line(x1, y1, x2, y2)',
            description: 'Draws a line (a direct path between two points) to the screen.'
          },
          'point': {
            signature: 'point(x, y)',
            description: 'Draws a point, a coordinate in space at the dimension of one pixel.'
          },
          'arc': {
            signature: 'arc(x, y, w, h, start, stop, [mode])',
            description: 'Draws an arc to the screen. Arcs are drawn along the outer edge of an ellipse.'
          }
        },
        'Color': {
          'background': {
            signature: 'background(color) or background(r, g, b, [a])',
            description: 'Sets the color used for the background. Default is light gray.'
          },
          'fill': {
            signature: 'fill(color) or fill(r, g, b, [a])',
            description: 'Sets the color used to fill shapes.'
          },
          'stroke': {
            signature: 'stroke(color) or stroke(r, g, b, [a])',
            description: 'Sets the color used to draw lines and borders around shapes.'
          },
          'noFill': {
            signature: 'noFill()',
            description: 'Disables filling geometry. If both noStroke() and noFill() are called, nothing will be drawn.'
          },
          'noStroke': {
            signature: 'noStroke()',
            description: 'Disables drawing the stroke (outline).'
          },
          'color': {
            signature: 'color(gray, [alpha]) or color(r, g, b, [a])',
            description: 'Creates a color object. Can be used with fill(), stroke(), and background().'
          },
          'lerpColor': {
            signature: 'lerpColor(c1, c2, amt)',
            description: 'Blends two colors to find a third color between them. The amt parameter is between 0.0 and 1.0.'
          },
          'colorMode': {
            signature: 'colorMode(mode, [max1], [max2], [max3], [maxA])',
            description: 'Changes the way p5.js interprets color data. Modes: RGB or HSB.'
          }
        },
        'Transform': {
          'translate': {
            signature: 'translate(x, y)',
            description: 'Specifies an amount to displace objects within the display window.'
          },
          'rotate': {
            signature: 'rotate(angle)',
            description: 'Rotates shapes around the origin (0,0). Angle should be in radians unless angleMode(DEGREES) is used.'
          },
          'scale': {
            signature: 'scale(s) or scale(x, y)',
            description: 'Increases or decreases the size of shapes by expanding and contracting vertices.'
          },
          'push': {
            signature: 'push()',
            description: 'Saves the current drawing style settings and transformations.'
          },
          'pop': {
            signature: 'pop()',
            description: 'Restores the previous drawing style settings and transformations.'
          }
        },
        'Math': {
          'map': {
            signature: 'map(value, start1, stop1, start2, stop2)',
            description: 'Re-maps a number from one range to another.'
          },
          'random': {
            signature: 'random([min], [max]) or random(choices)',
            description: 'Returns a random floating-point number or element from an array.'
          },
          'noise': {
            signature: 'noise(x, [y], [z])',
            description: 'Returns the Perlin noise value at specified coordinates. Creates smooth random values.'
          },
          'noiseSeed': {
            signature: 'noiseSeed(seed)',
            description: 'Sets the seed value for noise(). Use same seed for consistent noise patterns.'
          },
          'randomSeed': {
            signature: 'randomSeed(seed)',
            description: 'Sets the seed value for random(). Use same seed for consistent random values.'
          },
          'constrain': {
            signature: 'constrain(n, low, high)',
            description: 'Constrains a value between a minimum and maximum value.'
          },
          'lerp': {
            signature: 'lerp(start, stop, amt)',
            description: 'Calculates a number between two numbers at a specific increment.'
          },
          'dist': {
            signature: 'dist(x1, y1, x2, y2)',
            description: 'Calculates the distance between two points.'
          }
        },
        'Control': {
          'loop': {
            signature: 'loop()',
            description: 'Causes draw() to execute continuously. By default, draw() loops.'
          },
          'noLoop': {
            signature: 'noLoop()',
            description: 'Stops draw() from continuously executing. Can restart with loop() or redraw().'
          },
          'redraw': {
            signature: 'redraw([n])',
            description: 'Executes draw() one time. Can specify number of times to redraw.'
          },
          'frameRate': {
            signature: 'frameRate([fps])',
            description: 'Sets the number of frames per second or gets the current framerate.'
          }
        },
        'Text': {
          'text': {
            signature: 'text(str, x, y, [width], [height])',
            description: 'Draws text to the screen at the specified position.'
          },
          'textAlign': {
            signature: 'textAlign(horizAlign, [vertAlign])',
            description: 'Sets the current alignment for drawing text. Values: LEFT, CENTER, RIGHT, TOP, BOTTOM.'
          },
          'textSize': {
            signature: 'textSize(size)',
            description: 'Sets the size of the text in pixels.'
          },
          'textWidth': {
            signature: 'textWidth(str)',
            description: 'Calculates and returns the width of any character or text string.'
          }
        }
      };

      // Sound Reference - p5.sound library
      const soundReference = {
        'Synthesizers': {
          'p5.Oscillator': {
            signature: 'new p5.Oscillator([freq], [type])',
            description: 'Creates an oscillator for generating tones. Types: "sine", "triangle", "square", "sawtooth". Use .start() to begin, .freq() to set frequency, .amp() to set volume.'
          },
          'p5.PolySynth': {
            signature: 'new p5.PolySynth([synth], [maxVoices])',
            description: 'Polyphonic synthesizer for playing multiple notes simultaneously. Use .play(note, velocity, time, duration) to trigger notes.'
          },
          'p5.MonoSynth': {
            signature: 'new p5.MonoSynth()',
            description: 'Monophonic synthesizer with ADSR envelope. Use .play(note, velocity, time) to trigger sounds.'
          }
        },
        'Sound Files': {
          'loadSound': {
            signature: 'loadSound(path, [successCallback], [errorCallback])',
            description: 'Loads an audio file (mp3, wav, ogg). Returns p5.SoundFile object. Use in preload() or with callback.'
          },
          'p5.SoundFile': {
            signature: 'soundFile.play(), .pause(), .stop()',
            description: 'Object for playing audio files. Methods: play(), pause(), stop(), loop(), setVolume(), rate(), duration().'
          }
        },
        'Analysis': {
          'p5.FFT': {
            signature: 'new p5.FFT([smoothing], [bins])',
            description: 'Fast Fourier Transform for frequency analysis. Use .analyze() for frequency spectrum, .waveform() for time-domain data.'
          },
          'p5.Amplitude': {
            signature: 'new p5.Amplitude([smoothing])',
            description: 'Measures volume/amplitude of audio. Use .getLevel() to get current amplitude (0.0 to 1.0).'
          }
        },
        'Effects': {
          'p5.Reverb': {
            signature: 'new p5.Reverb()',
            description: 'Reverb effect for spatial depth. Use .process(sound, duration, decayRate) to apply.'
          },
          'p5.Delay': {
            signature: 'new p5.Delay()',
            description: 'Delay/echo effect. Use .process(sound, delayTime, feedback, filterFreq) to apply.'
          },
          'p5.Filter': {
            signature: 'new p5.Filter([type])',
            description: 'Audio filter (lowpass, highpass, bandpass). Use .freq() to set cutoff frequency.'
          },
          'p5.Distortion': {
            signature: 'new p5.Distortion([amount], [oversample])',
            description: 'Distortion effect. Use .process(sound, amount) to add harmonic distortion.'
          },
          'p5.Compressor': {
            signature: 'new p5.Compressor()',
            description: 'Dynamic range compressor. Balances loud and quiet parts of audio.'
          }
        },
        'Control': {
          'userStartAudio': {
            signature: 'userStartAudio()',
            description: '⚠️ REQUIRED: Call this in mousePressed() or touchStarted() before playing any sound. Enables audio context after user interaction.'
          },
          'getAudioContext': {
            signature: 'getAudioContext()',
            description: 'Returns the Web Audio API AudioContext. Advanced: for custom audio processing.'
          },
          'masterVolume': {
            signature: 'masterVolume([volume], [rampTime])',
            description: 'Sets or gets master volume for all sounds (0.0 to 1.0). Can ramp smoothly over time.'
          },
          'soundFormats': {
            signature: 'soundFormats("mp3", "ogg")',
            description: 'Defines which audio formats to try when loading. Place before loadSound() in preload().'
          }
        }
      };

      // Input Reference - Mouse, Keyboard, Touch
      const inputReference = {
        'Mouse Events': {
          'mousePressed': {
            signature: 'function mousePressed() { }',
            description: 'Called once when mouse button is pressed. Use mouseButton to check which button (LEFT, RIGHT, CENTER).'
          },
          'mouseReleased': {
            signature: 'function mouseReleased() { }',
            description: 'Called once when mouse button is released.'
          },
          'mouseClicked': {
            signature: 'function mouseClicked() { }',
            description: 'Called once after mouse is pressed and released.'
          },
          'mouseMoved': {
            signature: 'function mouseMoved() { }',
            description: 'Called every time the mouse moves (while not pressed).'
          },
          'mouseDragged': {
            signature: 'function mouseDragged() { }',
            description: 'Called every time the mouse moves while a button is pressed.'
          },
          'mouseWheel': {
            signature: 'function mouseWheel(event) { }',
            description: 'Called when mouse wheel is scrolled. Access event.delta for scroll amount.'
          }
        },
        'Mouse Variables': {
          'mouseX': {
            signature: 'mouseX',
            description: 'Current horizontal position of the mouse, relative to (0, 0) of the canvas.'
          },
          'mouseY': {
            signature: 'mouseY',
            description: 'Current vertical position of the mouse, relative to (0, 0) of the canvas.'
          },
          'pmouseX': {
            signature: 'pmouseX',
            description: 'Previous horizontal position of the mouse (from last frame).'
          },
          'pmouseY': {
            signature: 'pmouseY',
            description: 'Previous vertical position of the mouse (from last frame).'
          },
          'mouseButton': {
            signature: 'mouseButton',
            description: 'Which mouse button is pressed: LEFT, RIGHT, or CENTER.'
          },
          'mouseIsPressed': {
            signature: 'mouseIsPressed',
            description: 'Boolean: true if any mouse button is currently pressed, false otherwise.'
          }
        },
        'Keyboard Events': {
          'keyPressed': {
            signature: 'function keyPressed() { }',
            description: 'Called once when any key is pressed. Return false to prevent default browser behavior.'
          },
          'keyReleased': {
            signature: 'function keyReleased() { }',
            description: 'Called once when any key is released.'
          },
          'keyTyped': {
            signature: 'function keyTyped() { }',
            description: 'Called once when any printable key is pressed (letters, numbers, symbols).'
          }
        },
        'Keyboard Variables': {
          'key': {
            signature: 'key',
            description: 'The character of the most recently pressed key. For letters: lowercase (\'a\', \'b\'). For special keys, see keyCode.'
          },
          'keyCode': {
            signature: 'keyCode',
            description: 'Numeric code for special keys: BACKSPACE, DELETE, ENTER, RETURN, TAB, ESCAPE, SHIFT, CONTROL, OPTION, ALT, UP_ARROW, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW.'
          },
          'keyIsPressed': {
            signature: 'keyIsPressed',
            description: 'Boolean: true if any key is currently pressed, false otherwise.'
          }
        },
        'Touch Events': {
          'touchStarted': {
            signature: 'function touchStarted() { }',
            description: 'Called once when screen is touched. Return false to prevent default browser behavior (like scrolling).'
          },
          'touchMoved': {
            signature: 'function touchMoved() { }',
            description: 'Called every time a touch point moves. Return false to prevent default behavior.'
          },
          'touchEnded': {
            signature: 'function touchEnded() { }',
            description: 'Called once when touch is released. Return false to prevent default behavior.'
          }
        },
        'Touch Variables': {
          'touches': {
            signature: 'touches[]',
            description: 'Array of current touch points. Each has properties: x, y, id. Use touches.length to count simultaneous touches.'
          },
          'touchX': {
            signature: 'touchX',
            description: 'Horizontal position of first touch point (or mouseX if no touches). Convenient for single-touch interactions.'
          },
          'touchY': {
            signature: 'touchY',
            description: 'Vertical position of first touch point (or mouseY if no touches). Convenient for single-touch interactions.'
          }
        },
        'Examples': {
          'Multi-touch': {
            signature: 'for (let touch of touches) { ellipse(touch.x, touch.y, 50); }',
            description: 'Access all touch points for multi-touch interactions. Each touch has x, y, and id properties.'
          },
          'Prevent Scrolling': {
            signature: 'function touchMoved() { return false; }',
            description: 'Return false from touch events to prevent default browser behavior like scrolling or zooming.'
          },
          'Sound Activation': {
            signature: 'function mousePressed() { userStartAudio(); }',
            description: 'Call userStartAudio() in mousePressed() or touchStarted() before playing sounds (browser requirement).'
          }
        }
      };

      // EEG Data Reference
      const eegReference = {
        'Frequency Bands': {
          'eegData.alpha': {
            signature: 'eegData.alpha (0.0 - 1.0)',
            description: 'Alpha waves (8-12 Hz). Higher during relaxation, meditation, and eyes closed.'
          },
          'eegData.beta': {
            signature: 'eegData.beta (0.0 - 1.0)',
            description: 'Beta waves (13-30 Hz). Higher during active thinking, focus, and concentration.'
          },
          'eegData.theta': {
            signature: 'eegData.theta (0.0 - 1.0)',
            description: 'Theta waves (4-8 Hz). Higher during deep meditation, creativity, and drowsiness.'
          },
          'eegData.delta': {
            signature: 'eegData.delta (0.0 - 1.0)',
            description: 'Delta waves (0.5-4 Hz). Higher during deep sleep (low when awake).'
          },
          'eegData.gamma': {
            signature: 'eegData.gamma (0.0 - 1.0)',
            description: 'Gamma waves (30+ Hz). Associated with high-level cognition and information processing.'
          }
        },
        'Derived Metrics': {
          'eegData.attention': {
            signature: 'eegData.attention (0.0 - 1.0)',
            description: 'Attention level derived from beta and gamma activity.'
          },
          'eegData.meditation': {
            signature: 'eegData.meditation (0.0 - 1.0)',
            description: 'Meditation/relaxation level derived from alpha and theta activity.'
          }
        },
        'Raw Data Access': {
          'eegData.getRawChannel': {
            signature: 'eegData.getRawChannel(channel, numSamples)',
            description: 'Get recent raw EEG samples from a channel. Channels: "TP9", "AF7", "AF8", "TP10".'
          },
          'eegData.getAllChannels': {
            signature: 'eegData.getAllChannels(numSamples)',
            description: 'Get recent samples from all 4 channels as an object.'
          },
          'eegData.getRecentEpoch': {
            signature: 'eegData.getRecentEpoch(numSamples)',
            description: 'Get a time-aligned epoch with all channels. Returns array where each element has 4 channel values.'
          },
          'eegData.getChannelNames': {
            signature: 'eegData.getChannelNames()',
            description: 'Returns array of channel names: ["TP9", "AF7", "AF8", "TP10"].'
          }
        },
        'Connection Status': {
          'eegData.connected': {
            signature: 'eegData.connected (boolean)',
            description: 'True if Muse is connected or simulation is running, false otherwise.'
          },
          'eegData.sampleRate': {
            signature: 'eegData.sampleRate (256)',
            description: 'Sample rate in Hz (samples per second).'
          }
        }
      };

      // Monaco Editor setup and management
      class CodeEditor {
        constructor() {
          this.editor = null;
          this.currentSketch = null;
          this.autoRun = true;
          this.lastLoadedCode = null; // Track last loaded/selected code
          this.lastLoadedFilename = null; // Track filename
          this.setupEditor();
        }

        setupAutocomplete() {
          // Create completion items for p5.js functions
          const p5CompletionItems = [];
          
          Object.keys(p5Reference).forEach(category => {
            Object.keys(p5Reference[category]).forEach(funcName => {
              const func = p5Reference[category][funcName];
              p5CompletionItems.push({
                label: funcName,
                kind: monaco.languages.CompletionItemKind.Function,
                documentation: `${func.signature}\n\n${func.description}`,
                insertText: funcName,
                detail: category
              });
            });
          });
          
          // Create completion items for sound functions
          const soundCompletionItems = [];
          Object.keys(soundReference).forEach(category => {
            Object.keys(soundReference[category]).forEach(funcName => {
              const func = soundReference[category][funcName];
              soundCompletionItems.push({
                label: funcName,
                kind: monaco.languages.CompletionItemKind.Function,
                documentation: `${func.signature}\n\n${func.description}`,
                insertText: funcName,
                detail: `Sound: ${category}`
              });
            });
          });
          
          // Create completion items for input events/variables
          const inputCompletionItems = [];
          Object.keys(inputReference).forEach(category => {
            Object.keys(inputReference[category]).forEach(itemName => {
              const item = inputReference[category][itemName];
              const isEvent = category.includes('Events');
              inputCompletionItems.push({
                label: itemName,
                kind: isEvent ? monaco.languages.CompletionItemKind.Function : monaco.languages.CompletionItemKind.Variable,
                documentation: `${item.signature}\n\n${item.description}`,
                insertText: itemName,
                detail: `Input: ${category}`
              });
            });
          });
          
          // Create completion items for eegData
          const eegCompletionItems = [];
          Object.keys(eegReference).forEach(category => {
            Object.keys(eegReference[category]).forEach(propName => {
              const prop = eegReference[category][propName];
              eegCompletionItems.push({
                label: propName,
                kind: monaco.languages.CompletionItemKind.Property,
                documentation: `${prop.signature}\n\n${prop.description}`,
                insertText: propName,
                detail: category
              });
            });
          });
          
          // Register completion provider
          monaco.languages.registerCompletionItemProvider('javascript', {
            provideCompletionItems: (model, position) => {
              const word = model.getWordUntilPosition(position);
              const range = {
                startLineNumber: position.lineNumber,
                endLineNumber: position.lineNumber,
                startColumn: word.startColumn,
                endColumn: word.endColumn
              };
              
              // Check if we're typing after "eegData."
              const lineContent = model.getLineContent(position.lineNumber);
              const textBeforeCursor = lineContent.substring(0, position.column - 1);
              
              if (textBeforeCursor.includes('eegData.')) {
                return {
                  suggestions: eegCompletionItems.map(item => ({
                    ...item,
                    range: range
                  }))
                };
              }
              
              // Otherwise show all completions (p5.js, sound, input, and eegData)
              return {
                suggestions: [
                  ...p5CompletionItems, 
                  ...soundCompletionItems,
                  ...inputCompletionItems,
                  ...eegCompletionItems
                ].map(item => ({
                  ...item,
                  range: range
                }))
              };
            }
          });
          
          console.log('✅ Autocomplete registered for p5.js, sound, input, and eegData');
        }

        setupEditor() {
          require.config({ 
            paths: { 
              'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' 
            } 
          });

          require(['vs/editor/editor.main'], () => {
            this.editor = monaco.editor.create(document.getElementById('code-editor'), {
              value: this.getDefaultCode(),
              language: 'javascript',
              theme: 'vs-dark',
              fontSize: 12,
              minimap: { enabled: false },
              scrollBeyondLastLine: false,
              automaticLayout: true,
              wordWrap: 'on',
              suggestOnTriggerCharacters: true,
              quickSuggestions: true
            });

            // Register p5.js autocomplete
            this.setupAutocomplete();

            // Auto-run on change with debounce
            let timeout;
            this.editor.onDidChangeModelContent(() => {
              clearTimeout(timeout);
              timeout = setTimeout(() => {
                if (this.autoRun) {
                  this.runCode();
                }
              }, 1000);
            });

            // Initial run
            setTimeout(() => {
              console.log('Auto-running initial code...');
              this.runCode();
            }, 500);
          });
        }

        getDefaultCode() {
          return `// 🧠 BrainImation: Live EEG + P5.js
// Access real-time brain data through the 'eegData' object:
// eegData.alpha, eegData.beta, eegData.theta, eegData.delta
// eegData.attention, eegData.meditation, eegData.raw[]

let particles = [];
let time = 0;

function setup() {
  // Canvas is already created by the system
  // Just set up the drawing mode and initialize
  colorMode(HSB, 360, 100, 100, 1);
  
  // Initialize particles
  for (let i = 0; i < 50; i++) {
    particles.push({
      x: random(width),
      y: random(height),
      vx: random(-1, 1),
      vy: random(-1, 1),
      hue: random(360)
    });
  }
}

function draw() {
  // Background responds to meditation
  let bgAlpha = map(eegData.meditation, 0, 1, 0.05, 0.2);
  background(220, 30, 10, bgAlpha);
  
  time += 0.01;
  
  // Draw neural network
  stroke(180, 80, 90, 0.3);
  strokeWeight(1);
  
  for (let i = 0; i < particles.length; i++) {
    let p = particles[i];
    
    // Movement influenced by alpha waves
    let alphaForce = eegData.alpha * 2;
    p.vx += random(-alphaForce, alphaForce) * 0.01;
    p.vy += random(-alphaForce, alphaForce) * 0.01;
    
    // Damping
    p.vx *= 0.99;
    p.vy *= 0.99;
    
    // Update position
    p.x += p.vx;
    p.y += p.vy;
    
    // Wrap around edges
    if (p.x < 0) p.x = width;
    if (p.x > width) p.x = 0;
    if (p.y < 0) p.y = height;
    if (p.y > height) p.y = 0;
    
    // Color influenced by attention
    let hue = (p.hue + eegData.attention * 50 + time * 10) % 360;
    let brightness = map(eegData.beta, 0, 1, 30, 90);
    
    fill(hue, 70, brightness, 0.8);
    noStroke();
    
    // Size influenced by theta waves
    let size = 5 + eegData.theta * 15;
    ellipse(p.x, p.y, size);
    
    // Connect nearby particles
    for (let j = i + 1; j < particles.length; j++) {
      let p2 = particles[j];
      let d = dist(p.x, p.y, p2.x, p2.y);
      
      if (d < 80) {
        let alpha = map(d, 0, 80, 0.5, 0) * eegData.alpha;
        stroke(hue, 50, 70, alpha);
        strokeWeight(1);
        line(p.x, p.y, p2.x, p2.y);
      }
    }
  }
  
  // Display connection status
  if (!eegData.connected) {
    fill(0, 0, 100, 0.8);
    textAlign(CENTER, CENTER);
    textSize(20);
    text("Connect your Muse headset or use 'Simulate Data'", width/2, height/2 - 10);
    textSize(16);
    fill(0, 0, 70, 0.6);
    text("to see brain-controlled animation", width/2, height/2 + 20);
  }
}`;
        }

        runCode() {
          console.log('🚀 Running code...');
          try {
            // Clear any existing sketch
            if (this.currentSketch) {
              console.log('Removing existing sketch');
              this.currentSketch.remove();
            }

            // Clear the canvas container
            const container = document.getElementById('canvas-container');
            container.innerHTML = '';
            console.log('Canvas container cleared');

            // Hide error console
            document.getElementById('error-console').style.display = 'none';

            // Get code from editor
            const code = this.editor.getValue();
            console.log('Code retrieved from editor:', code.length, 'characters');

            // Get container dimensions
            const containerRect = container.getBoundingClientRect();
            const containerWidth = containerRect.width || 800;
            const containerHeight = containerRect.height || 600;
            console.log('Container dimensions:', containerWidth, 'x', containerHeight);

              // Execute the sketch with proper p5.js instance mode
              console.log('Creating p5 sketch...');
              this.currentSketch = new p5((p) => {
                // Store original p5 functions
                let userSetup, userDraw, userWindowResized;
                
                // Store user event handlers
                let userMousePressed, userMouseReleased, userMouseClicked;
                let userMouseMoved, userMouseDragged, userMouseWheel;
                let userKeyPressed, userKeyReleased, userKeyTyped;
                let userTouchStarted, userTouchMoved, userTouchEnded;

              // Make p5 functions available globally within the sketch context
              const bindP5Functions = () => {
                console.log('🔧 Auto-binding ALL p5.js functions and constants...');
                
                // AUTOMATIC BINDING APPROACH:
                // Instead of manually listing every function, iterate through all p5 properties
                // and bind them automatically. This supports ALL p5 libraries without modification!
                
                const excludedProps = new Set([
                  // Internal p5 properties that shouldn't be exposed
                  '_setupDone', '_renderer', '_curElement', '_elements', 
                  '_accessibleOutputs', '_events', '_registeredMethods',
                  'constructor', 'prototype', '_start', '_setup', '_draw',
                  '_onBlur', '_onFocus', 'setup', 'draw', 'preload',
                  // Properties we handle specially
                  'width', 'height', 'windowWidth', 'windowHeight', 'frameCount'
                ]);
                
                let boundCount = 0;
                let soundFunctionsFound = 0;
                
                // Iterate through all properties of the p5 instance
                for (let prop in p) {
                  // Skip excluded properties and properties already on window
                  if (excludedProps.has(prop)) continue;
                  
                  try {
                    const value = p[prop];
                    
                    // Bind functions
                    if (typeof value === 'function') {
                      window[prop] = value.bind(p);
                      boundCount++;
                      
                      // Track if we found sound functions
                      if (prop.toLowerCase().includes('sound') || 
                          prop === 'loadSound' || prop === 'getAudioContext' ||
                          prop === 'userStartAudio') {
                        soundFunctionsFound++;
                        console.log(`  ✅ Found p5.sound function: ${prop}`);
                      }
                    }
                    // Copy constants and properties (numbers, strings, objects)
                    else if (typeof value !== 'object' || value === null || 
                             value.constructor === Object || value.constructor === Array) {
                      window[prop] = value;
                      boundCount++;
                    }
                    // For special objects (like constants), copy by value
                    else {
                      window[prop] = value;
                    }
                  } catch (e) {
                    // Some properties may throw errors when accessed, skip them
                    console.log(`  ⚠️ Could not bind property: ${prop}`);
                  }
                }
                
                console.log(`✅ Auto-bound ${boundCount} p5.js functions and constants`);
                if (soundFunctionsFound > 0) {
                  console.log(`🔊 Found ${soundFunctionsFound} p5.sound functions - audio is ready!`);
                } else {
                  console.log('⚠️ No p5.sound functions detected. Make sure p5.sound.js is loaded.');
                }
                
                // Manually set dimensions (these need special handling)
                window.width = containerWidth;
                window.height = containerHeight;
                window.windowWidth = containerWidth;
                window.windowHeight = containerHeight;
                
                // Log some key functions to verify
                console.log('📋 Sample bound functions:', {
                  drawing: typeof window.ellipse === 'function',
                  sound: typeof window.loadSound === 'function',
                  color: typeof window.colorMode === 'function',
                  math: typeof window.noise === 'function'
                });
              };

              // Bind p5 functions
              bindP5Functions();

              // Execute user code to get their setup/draw functions
              try {
                console.log('Executing user code...');
                console.log('Code to execute:', code.substring(0, 200) + '...');
                
                // Clear any existing user functions
                window.setup = undefined;
                window.draw = undefined;
                window.windowResized = undefined;
                window.mousePressed = undefined;
                window.mouseReleased = undefined;
                window.mouseClicked = undefined;
                window.mouseMoved = undefined;
                window.mouseDragged = undefined;
                window.mouseWheel = undefined;
                window.keyPressed = undefined;
                window.keyReleased = undefined;
                window.keyTyped = undefined;
                window.touchStarted = undefined;
                window.touchMoved = undefined;
                window.touchEnded = undefined;
                
                // Use eval with 'this' bound to window to ensure global scope
                eval.call(window, code);
                
                console.log('User code executed successfully');
                console.log('window.setup type:', typeof window.setup);
                console.log('window.draw type:', typeof window.draw);
                
                // Capture user-defined functions
                if (typeof window.setup === 'function') {
                  userSetup = window.setup;
                  console.log('✅ User setup function captured');
                } else {
                  console.log('❌ No setup function found in user code');
                }
                
                if (typeof window.draw === 'function') {
                  userDraw = window.draw;
                  console.log('✅ User draw function captured');
                } else {
                  console.log('❌ No draw function found in user code');
                }
                
                if (typeof window.windowResized === 'function') {
                  userWindowResized = window.windowResized;
                  console.log('✅ User windowResized function captured');
                }
                
                // Capture mouse event handlers (assign to existing variables, not const)
                userMousePressed = window.mousePressed;
                userMouseReleased = window.mouseReleased;
                userMouseClicked = window.mouseClicked;
                userMouseMoved = window.mouseMoved;
                userMouseDragged = window.mouseDragged;
                userMouseWheel = window.mouseWheel;
                
                // Capture keyboard event handlers
                userKeyPressed = window.keyPressed;
                userKeyReleased = window.keyReleased;
                userKeyTyped = window.keyTyped;
                
                // Capture touch event handlers
                userTouchStarted = window.touchStarted;
                userTouchMoved = window.touchMoved;
                userTouchEnded = window.touchEnded;
                
                // Log captured interaction events
                if (userMousePressed) console.log('✅ User mousePressed function captured');
                if (userKeyPressed) console.log('✅ User keyPressed function captured');
                if (userTouchStarted) console.log('✅ User touchStarted function captured');
              } catch (error) {
                console.error('Error in user code:', error);
                showError('Error in user code: ' + error.message);
                return;
              }

              // p5.js setup function
              p.setup = function() {
                console.log('p5.js setup() called');
                // Create canvas and attach to container
                const canvas = p.createCanvas(containerWidth, containerHeight);
                canvas.parent('canvas-container');
                console.log('Canvas created:', containerWidth, 'x', containerHeight);
                
                // Update global dimensions
                window.width = p.width;
                window.height = p.height;
                window.windowWidth = containerWidth;
                window.windowHeight = containerHeight;
                
                // Call user setup if it exists
                if (userSetup) {
                  console.log('Calling user setup function');
                  try {
                    userSetup();
                  } catch (error) {
                    console.error('❌ Error in setup() function: ' + error.message);
                    if (error.stack) {
                      const stackLine = error.stack.split('\n')[1];
                      if (stackLine) {
                        console.error('   ' + stackLine.trim());
                      }
                    }
                    console.warn('💡 Tip: Check your setup() function in the Code Editor tab for syntax or logic errors.');
                  }
                } else {
                  console.log('No user setup function found');
                }
              };

              // p5.js draw function
              p.draw = function() {
                // Update frame count and dimensions
                window.frameCount = p.frameCount;
                window.width = p.width;
                window.height = p.height;
                
                // Update mouse position variables
                window.mouseX = p.mouseX;
                window.mouseY = p.mouseY;
                window.pmouseX = p.pmouseX;
                window.pmouseY = p.pmouseY;
                window.mouseButton = p.mouseButton;
                window.mouseIsPressed = p.mouseIsPressed;
                
                // Update touch variables
                window.touches = p.touches;
                if (p.touches && p.touches.length > 0) {
                  window.touchX = p.touches[0].x;
                  window.touchY = p.touches[0].y;
                } else {
                  // Fallback to mouse position if no touches
                  window.touchX = p.mouseX;
                  window.touchY = p.mouseY;
                }
                
                // Update keyboard variables
                window.keyIsPressed = p.keyIsPressed;
                window.key = p.key;
                window.keyCode = p.keyCode;
                
                // Call user draw if it exists
                if (userDraw) {
                  try {
                    userDraw();
                  } catch (error) {
                    console.error('❌ Error in draw() function: ' + error.message);
                    if (error.stack) {
                      const stackLine = error.stack.split('\n')[1];
                      if (stackLine) {
                        console.error('   ' + stackLine.trim());
                      }
                    }
                    console.warn('💡 Tip: Check your code in the Code Editor tab. The animation has been paused to prevent error spam.');
                    // Stop the sketch to prevent error spam
                    p.noLoop();
                  }
                } else {
                  // Show a test pattern if no user draw function
                  p.background(50);
                  p.fill(255);
                  p.textAlign(p.CENTER, p.CENTER);
                  p.textSize(20);
                  p.text('Canvas is working! Add your draw() function.', p.width/2, p.height/2);
                }
              };

              // Handle window resize
              p.windowResized = function() {
                const newRect = container.getBoundingClientRect();
                const newWidth = newRect.width || 800;
                const newHeight = newRect.height || 600;
                
                p.resizeCanvas(newWidth, newHeight);
                window.width = p.width;
                window.height = p.height;
                window.windowWidth = newWidth;
                window.windowHeight = newHeight;
                
                if (userWindowResized) {
                  userWindowResized();
                }
              };

              // Mouse event handlers
              p.mousePressed = function() {
                // Update mouse position globals
                window.mouseX = p.mouseX;
                window.mouseY = p.mouseY;
                window.pmouseX = p.pmouseX;
                window.pmouseY = p.pmouseY;
                window.mouseButton = p.mouseButton;
                
                if (userMousePressed && typeof userMousePressed === 'function') {
                  try {
                    return userMousePressed();
                  } catch (error) {
                    console.error('❌ Error in mousePressed(): ' + error.message);
                  }
                }
              };

              p.mouseReleased = function() {
                window.mouseX = p.mouseX;
                window.mouseY = p.mouseY;
                window.mouseButton = p.mouseButton;
                
                if (userMouseReleased && typeof userMouseReleased === 'function') {
                  try {
                    return userMouseReleased();
                  } catch (error) {
                    console.error('❌ Error in mouseReleased(): ' + error.message);
                  }
                }
              };

              p.mouseClicked = function() {
                window.mouseX = p.mouseX;
                window.mouseY = p.mouseY;
                window.mouseButton = p.mouseButton;
                
                if (userMouseClicked && typeof userMouseClicked === 'function') {
                  try {
                    return userMouseClicked();
                  } catch (error) {
                    console.error('❌ Error in mouseClicked(): ' + error.message);
                  }
                }
              };

              p.mouseMoved = function() {
                window.mouseX = p.mouseX;
                window.mouseY = p.mouseY;
                window.pmouseX = p.pmouseX;
                window.pmouseY = p.pmouseY;
                
                if (userMouseMoved && typeof userMouseMoved === 'function') {
                  try {
                    return userMouseMoved();
                  } catch (error) {
                    console.error('❌ Error in mouseMoved(): ' + error.message);
                  }
                }
              };

              p.mouseDragged = function() {
                window.mouseX = p.mouseX;
                window.mouseY = p.mouseY;
                window.pmouseX = p.pmouseX;
                window.pmouseY = p.pmouseY;
                window.mouseButton = p.mouseButton;
                
                if (userMouseDragged && typeof userMouseDragged === 'function') {
                  try {
                    return userMouseDragged();
                  } catch (error) {
                    console.error('❌ Error in mouseDragged(): ' + error.message);
                  }
                }
              };

              p.mouseWheel = function(event) {
                if (userMouseWheel && typeof userMouseWheel === 'function') {
                  try {
                    return userMouseWheel(event);
                  } catch (error) {
                    console.error('❌ Error in mouseWheel(): ' + error.message);
                  }
                }
              };

              // Keyboard event handlers
              p.keyPressed = function() {
                window.key = p.key;
                window.keyCode = p.keyCode;
                
                if (userKeyPressed && typeof userKeyPressed === 'function') {
                  try {
                    return userKeyPressed();
                  } catch (error) {
                    console.error('❌ Error in keyPressed(): ' + error.message);
                  }
                }
              };

              p.keyReleased = function() {
                window.key = p.key;
                window.keyCode = p.keyCode;
                
                if (userKeyReleased && typeof userKeyReleased === 'function') {
                  try {
                    return userKeyReleased();
                  } catch (error) {
                    console.error('❌ Error in keyReleased(): ' + error.message);
                  }
                }
              };

              p.keyTyped = function() {
                window.key = p.key;
                
                if (userKeyTyped && typeof userKeyTyped === 'function') {
                  try {
                    return userKeyTyped();
                  } catch (error) {
                    console.error('❌ Error in keyTyped(): ' + error.message);
                  }
                }
              };

              // Touch event handlers
              p.touchStarted = function() {
                // Update touch variables
                window.touches = p.touches;
                if (p.touches && p.touches.length > 0) {
                  window.touchX = p.touches[0].x;
                  window.touchY = p.touches[0].y;
                }
                
                if (userTouchStarted && typeof userTouchStarted === 'function') {
                  try {
                    const result = userTouchStarted();
                    // If the function returns false, prevent default behavior
                    if (result === false) {
                      return false;
                    }
                  } catch (error) {
                    console.error('❌ Error in touchStarted(): ' + error.message);
                  }
                }
                // Prevent default touch behavior (like scrolling) on canvas
                return false;
              };

              p.touchMoved = function() {
                // Update touch variables
                window.touches = p.touches;
                if (p.touches && p.touches.length > 0) {
                  window.touchX = p.touches[0].x;
                  window.touchY = p.touches[0].y;
                }
                
                if (userTouchMoved && typeof userTouchMoved === 'function') {
                  try {
                    const result = userTouchMoved();
                    if (result === false) {
                      return false;
                    }
                  } catch (error) {
                    console.error('❌ Error in touchMoved(): ' + error.message);
                  }
                }
                // Prevent default touch behavior
                return false;
              };

              p.touchEnded = function() {
                // Update touch variables
                window.touches = p.touches;
                if (p.touches && p.touches.length > 0) {
                  window.touchX = p.touches[0].x;
                  window.touchY = p.touches[0].y;
                }
                
                if (userTouchEnded && typeof userTouchEnded === 'function') {
                  try {
                    const result = userTouchEnded();
                    if (result === false) {
                      return false;
                    }
                  } catch (error) {
                    console.error('❌ Error in touchEnded(): ' + error.message);
                  }
                }
                // Prevent default touch behavior
                return false;
              };

            });

          } catch (error) {
            console.error('Error creating p5 sketch:', error);
            this.showError('Error creating sketch: ' + error.message);
          }
        }

        showError(message) {
          const errorConsole = document.getElementById('error-console');
          errorConsole.textContent = message;
          errorConsole.style.display = 'block';
          
          // Also log to System Log
          if (window.logger) {
            logger.log('❌ Code Error: ' + message, 'error');
          }
        }

        saveCode() {
          const code = this.editor.getValue();
          const blob = new Blob([code], { type: 'text/javascript' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          
          // Generate filename with timestamp
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
          const filename = this.lastLoadedFilename || `brainimation-${timestamp}.js`;
          
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          
          console.log('Code saved as:', filename);
        }

        loadCodeFromFile(file) {
          const reader = new FileReader();
          
          reader.onload = (e) => {
            const code = e.target.result;
            this.editor.setValue(code);
            this.lastLoadedCode = code;
            this.lastLoadedFilename = file.name;
            
            // Enable reload button
            document.getElementById('reload-btn').disabled = false;
            
            console.log('Code loaded from:', file.name);
            
            // Auto-run the loaded code
            if (this.autoRun) {
              this.runCode();
            }
          };
          
          reader.onerror = (e) => {
            this.showError('Error loading file: ' + e.target.error);
          };
          
          reader.readAsText(file);
        }

        reloadCode() {
          if (this.lastLoadedCode) {
            this.editor.setValue(this.lastLoadedCode);
            console.log('Code reloaded:', this.lastLoadedFilename || 'last loaded code');
            
            // Auto-run the reloaded code
            if (this.autoRun) {
              this.runCode();
            }
          } else {
            console.log('No code to reload');
          }
        }

        loadExample(exampleName) {
          const examples = {
            basic: `// Basic animated background
function setup() {
  console.log('User setup() function called!');
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  let hue = map(eegData.alpha, 0, 1, 180, 300);
  background(hue, 50, 20);
  
  fill(hue + 60, 80, 90);
  let size = 50 + eegData.attention * 100;
  ellipse(width/2, height/2, size);
}`,

            alpha: `// Alpha wave visualization
let waves = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(220, 30, 10, 0.1);
  
  // Add new wave based on alpha strength
  if (frameCount % 10 === 0) {
    waves.push({
      x: width/2,
      y: height/2,
      r: 0,
      alpha: eegData.alpha
    });
  }
  
  // Draw and update waves
  for (let i = waves.length - 1; i >= 0; i--) {
    let w = waves[i];
    
    noFill();
    stroke(200, 70, 90, w.alpha);
    strokeWeight(2);
    ellipse(w.x, w.y, w.r * 2);
    
    w.r += w.alpha * 5 + 1;
    w.alpha *= 0.98;
    
    if (w.alpha < 0.01) {
      waves.splice(i, 1);
    }
  }
}`,

            attention: `// Attention meter
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Attention bar
  let barWidth = width * 0.8;
  let barHeight = 40;
  let x = (width - barWidth) / 2;
  let y = height / 2;
  
  // Background bar
  fill(0, 0, 20);
  rect(x, y, barWidth, barHeight);
  
  // Attention level
  let attentionWidth = barWidth * eegData.attention;
  let hue = map(eegData.attention, 0, 1, 0, 120);
  fill(hue, 80, 90);
  rect(x, y, attentionWidth, barHeight);
  
  // Text
  fill(0, 0, 100);
  textAlign(CENTER, CENTER);
  textSize(20);
  text("Attention: " + (eegData.attention * 100).toFixed(1) + "%", width/2, y - 60);
}`,

            particles: `// Brain particle system
let particles = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  for (let i = 0; i < 100; i++) {
    particles.push({
      x: random(width),
      y: random(height),
      vx: random(-2, 2),
      vy: random(-2, 2),
      life: 1.0
    });
  }
}

function draw() {
  background(0, 0, 5, 0.1);
  
  for (let p of particles) {
    // Movement influenced by brain waves
    p.vx += (random(-1, 1) * eegData.alpha * 0.1);
    p.vy += (random(-1, 1) * eegData.beta * 0.1);
    
    p.x += p.vx;
    p.y += p.vy;
    
    // Wrap around
    if (p.x < 0) p.x = width;
    if (p.x > width) p.x = 0;
    if (p.y < 0) p.y = height;
    if (p.y > height) p.y = 0;
    
    // Draw particle
    let hue = map(eegData.theta, 0, 1, 180, 300);
    fill(hue, 70, 90, p.life);
    noStroke();
    ellipse(p.x, p.y, 5 + eegData.gamma * 10);
    
    p.life *= 0.995;
    if (p.life < 0.1) p.life = 1.0;
  }
}`,

            mandala: `// Neural mandala
let angle = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 0, 0.05);
  
  translate(width/2, height/2);
  
  let layers = 5;
  for (let layer = 0; layer < layers; layer++) {
    let radius = 50 + layer * 40;
    let points = 6 + layer * 2;
    
    for (let i = 0; i < points; i++) {
      let a = angle + (TWO_PI / points) * i;
      let x = cos(a) * radius;
      let y = sin(a) * radius;
      
      let hue = (angle * 57.3 + layer * 60) % 360;
      let brightness = 50 + eegData.attention * 40;
      let size = 5 + eegData.alpha * layer * 2;
      
      fill(hue, 80, brightness, 0.7);
      noStroke();
      ellipse(x, y, size);
    }
  }
  
  angle += eegData.meditation * 0.02 + 0.005;
}`,

            waves: `// EEG wave visualization
let waveHistory = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  
  // Add current values to history
  waveHistory.push({
    alpha: eegData.alpha,
    beta: eegData.beta,
    theta: eegData.theta,
    delta: eegData.delta
  });
  
  // Keep history manageable
  if (waveHistory.length > width / 2) {
    waveHistory.shift();
  }
  
  // Draw waves
  let waves = ['alpha', 'beta', 'theta', 'delta'];
  let colors = [300, 180, 60, 0];
  
  for (let w = 0; w < waves.length; w++) {
    let wave = waves[w];
    let hue = colors[w];
    
    stroke(hue, 70, 90);
    strokeWeight(2);
    noFill();
    
    beginShape();
    for (let i = 0; i < waveHistory.length; i++) {
      let x = map(i, 0, waveHistory.length - 1, 0, width);
      let y = height/2 + (w - 1.5) * 80 + waveHistory[i][wave] * -50;
      vertex(x, y);
    }
    endShape();
    
    // Label
    fill(hue, 70, 90);
    noStroke();
    textAlign(LEFT, CENTER);
    text(wave.toUpperCase(), 10, height/2 + (w - 1.5) * 80);
  }
}`,

            eegtrace: `// Raw EEG trace visualization
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Get raw EEG data from TP9 electrode (left temporal)
  let tp9Data = eegData.getRawChannel('TP9', 300);
  
  if (tp9Data.length > 10) {
    // Draw EEG trace
    stroke(180, 80, 90);
    strokeWeight(2);
    noFill();
    
    beginShape();
    for (let i = 0; i < tp9Data.length; i++) {
      let x = map(i, 0, tp9Data.length - 1, 50, width - 50);
      let y = map(tp9Data[i], -100, 100, height - 50, 50);
      vertex(x, y);
    }
    endShape();
    
    // Add grid lines
    stroke(0, 0, 30);
    strokeWeight(1);
    
    // Horizontal lines (voltage levels)
    for (let v = -100; v <= 100; v += 50) {
      let y = map(v, -100, 100, height - 50, 50);
      line(50, y, width - 50, y);
    }
    
    // Vertical time markers
    for (let t = 0; t < tp9Data.length; t += 50) {
      let x = map(t, 0, tp9Data.length - 1, 50, width - 50);
      line(x, 50, x, height - 50);
    }
    
    // Labels
    fill(0, 0, 100);
    noStroke();
    textAlign(LEFT, TOP);
    textSize(16);
    text("TP9 Raw EEG Trace", 50, 20);
    
    textAlign(RIGHT, CENTER);
    textSize(12);
    text("100μV", 45, map(100, -100, 100, height - 50, 50));
    text("0μV", 45, map(0, -100, 100, height - 50, 50));
    text("-100μV", 45, map(-100, -100, 100, height - 50, 50));
  } else {
    // No data message
    fill(0, 0, 70);
    textAlign(CENTER, CENTER);
    textSize(20);
    text("Waiting for EEG data...", width/2, height/2);
  }
}`,

            multichannel: `// Multi-channel EEG visualization
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  let channels = eegData.getChannelNames();
  let colors = [300, 180, 60, 120]; // Purple, Cyan, Yellow, Green
  
  // Draw each channel
  for (let c = 0; c < channels.length; c++) {
    let channelData = eegData.getRawChannel(channels[c], 200);
    
    if (channelData.length > 10) {
      let yOffset = (c + 1) * height / (channels.length + 1);
      
      // Channel trace
      stroke(colors[c], 80, 90);
      strokeWeight(1.5);
      noFill();
      
      beginShape();
      for (let i = 0; i < channelData.length; i++) {
        let x = map(i, 0, channelData.length - 1, 80, width - 20);
        let y = yOffset + map(channelData[i], -100, 100, -40, 40);
        vertex(x, y);
      }
      endShape();
      
      // Channel label
      fill(colors[c], 80, 90);
      noStroke();
      textAlign(LEFT, CENTER);
      textSize(14);
      text(channels[c], 10, yOffset);
      
      // Zero line
      stroke(0, 0, 20);
      strokeWeight(1);
      line(80, yOffset, width - 20, yOffset);
    }
  }
  
  // Title
  fill(0, 0, 100);
  noStroke();
  textAlign(CENTER, TOP);
  textSize(16);
  text("Multi-Channel EEG (All 4 Electrodes)", width/2, 10);
  
  // Real-time indicator
  if (eegData.connected) {
    fill(120, 80, 90);
    ellipse(width - 30, 30, 10);
    textAlign(RIGHT, CENTER);
    textSize(12);
    text("LIVE", width - 40, 30);
  }
}`,

            epochs: `// EEG epoch visualization (like ERP analysis)
let epochData = [];
let epochLength = 128; // ~0.5 seconds at 256Hz

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 8);
  
  // Collect epochs when attention changes significantly
  if (frameCount % 60 === 0) { // Every second
    let recentEpoch = eegData.getRecentEpoch(epochLength);
    if (recentEpoch.length >= epochLength) {
      epochData.push({
        data: recentEpoch,
        attention: eegData.attention,
        timestamp: millis()
      });
      
      // Keep last 20 epochs
      if (epochData.length > 20) {
        epochData.shift();
      }
    }
  }
  
  if (epochData.length > 0) {
    // Draw averaged epoch
    let avgEpoch = [];
    for (let i = 0; i < epochLength; i++) {
      let sum = [0, 0, 0, 0]; // 4 channels
      let count = 0;
      
      for (let e = 0; e < epochData.length; e++) {
        if (epochData[e].data[i]) {
          for (let ch = 0; ch < 4; ch++) {
            sum[ch] += epochData[e].data[i][ch] || 0;
          }
          count++;
        }
      }
      
      if (count > 0) {
        avgEpoch.push([
          sum[0] / count,
          sum[1] / count,
          sum[2] / count,
          sum[3] / count
        ]);
      }
    }
    
    // Draw the averaged epoch for each channel
    let channelNames = ['TP9', 'AF7', 'AF8', 'TP10'];
    let colors = [300, 180, 60, 120];
    
    for (let ch = 0; ch < 4; ch++) {
      stroke(colors[ch], 80, 90);
      strokeWeight(2);
      noFill();
      
      beginShape();
      for (let i = 0; i < avgEpoch.length; i++) {
        let x = map(i, 0, avgEpoch.length - 1, 60, width - 60);
        let y = height/2 + (ch - 1.5) * 60 + map(avgEpoch[i][ch], -50, 50, 30, -30);
        vertex(x, y);
      }
      endShape();
      
      // Channel label
      fill(colors[ch], 80, 90);
      noStroke();
      textAlign(LEFT, CENTER);
      textSize(12);
      text(channelNames[ch], 10, height/2 + (ch - 1.5) * 60);
    }
    
    // Zero line
    stroke(0, 0, 30);
    strokeWeight(1);
    line(60, height/2, width - 60, height/2);
    
    // Time markers
    textAlign(CENTER, BOTTOM);
    textSize(10);
    fill(0, 0, 60);
    text("0ms", 60, height - 10);
    text("250ms", width/2, height - 10);
    text("500ms", width - 60, height - 10);
    
    // Title and info
    fill(0, 0, 100);
    textAlign(CENTER, TOP);
    textSize(16);
    text("Averaged Epochs (n=" + epochData.length + ")", width/2, 10);
    
    textSize(12);
    text("Grand average across all channels", width/2, 30);
  } else {
    // Waiting message
    fill(0, 0, 70);
    textAlign(CENTER, CENTER);
    textSize(18);
    text("Collecting epochs...", width/2, height/2);
    textSize(14);
    text("Epochs will appear as data accumulates", width/2, height/2 + 30);
  }
}`,

            // New examples from p5.eegedu.art repository
            basicShapes: `// Basic shapes with brain control
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  
  // Circle size controlled by alpha
  let circleSize = 50 + eegData.alpha * 150;
  fill(180, 70, 90);
  ellipse(width/4, height/2, circleSize);
  
  // Rectangle size controlled by beta
  let rectSize = 30 + eegData.beta * 100;
  fill(270, 70, 90);
  rect(width/2 - rectSize/2, height/2 - rectSize/2, rectSize, rectSize);
  
  // Triangle controlled by theta
  let triSize = 40 + eegData.theta * 120;
  fill(60, 70, 90);
  triangle(
    3*width/4, height/2 + triSize/2,
    3*width/4 - triSize/2, height/2 - triSize/2,
    3*width/4 + triSize/2, height/2 - triSize/2
  );
}`,

            functionExample: `// Function example with EEG
function setup() {
  colorMode(HSB, 360, 100, 100);
  frameRate(30);
}

function draw() {
  background(0, 0, 5);
  
  // Draw grid of brain-controlled shapes
  for (let x = 0; x < 5; x++) {
    for (let y = 0; y < 5; y++) {
      drawBrainShape(
        x * width/5 + width/10,
        y * height/5 + height/10,
        x, y
      );
    }
  }
}

function drawBrainShape(x, y, gridX, gridY) {
  push();
  translate(x, y);
  
  let size = 20 + eegData.attention * 40;
  let hue = (gridX * 60 + gridY * 30 + frameCount) % 360;
  let brightness = 50 + eegData.meditation * 40;
  
  fill(hue, 70, brightness);
  noStroke();
  ellipse(0, 0, size);
  pop();
}`,

            BasicFrequencyBands: `// Basic frequency bands visualization
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Draw bars for each frequency band
  let bands = [
    {name: 'Delta', value: eegData.delta, hue: 0},
    {name: 'Theta', value: eegData.theta, hue: 60},
    {name: 'Alpha', value: eegData.alpha, hue: 180},
    {name: 'Beta', value: eegData.beta, hue: 270},
    {name: 'Gamma', value: eegData.gamma, hue: 300}
  ];
  
  let barWidth = width / bands.length;
  
  for (let i = 0; i < bands.length; i++) {
    let band = bands[i];
    let x = i * barWidth;
    let barHeight = band.value * height * 0.8;
    
    // Draw bar
    fill(band.hue, 70, 90);
    rect(x, height - barHeight, barWidth - 10, barHeight);
    
    // Draw label
    fill(0, 0, 100);
    textAlign(CENTER, BOTTOM);
    textSize(12);
    text(band.name, x + barWidth/2, height - 5);
    
    // Draw value
    textAlign(CENTER, TOP);
    textSize(10);
    text(band.value.toFixed(2), x + barWidth/2, height - barHeight - 5);
  }
}`,

            bandOrbitz: `// Band orbitz - frequency bands as orbiting circles
let angle = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5, 0.1);
  translate(width/2, height/2);
  
  let bands = [
    {name: 'Delta', value: eegData.delta, hue: 0, radius: 50},
    {name: 'Theta', value: eegData.theta, hue: 60, radius: 100},
    {name: 'Alpha', value: eegData.alpha, hue: 180, radius: 150},
    {name: 'Beta', value: eegData.beta, hue: 270, radius: 200},
    {name: 'Gamma', value: eegData.gamma, hue: 300, radius: 250}
  ];
  
  for (let i = 0; i < bands.length; i++) {
    let band = bands[i];
    let a = angle + (i * TWO_PI / bands.length);
    let r = band.radius;
    let size = 10 + band.value * 40;
    
    let x = cos(a) * r;
    let y = sin(a) * r;
    
    fill(band.hue, 70, 90, 0.8);
    noStroke();
    ellipse(x, y, size);
    
    // Draw orbit path
    noFill();
    stroke(band.hue, 30, 50, 0.3);
    ellipse(0, 0, r * 2);
  }
  
  angle += 0.02 * eegData.attention;
}`,

            piWedges: `// Pi wedges - frequency bands as pie chart
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  translate(width/2, height/2);
  
  let bands = [
    {name: 'Delta', value: eegData.delta, hue: 0},
    {name: 'Theta', value: eegData.theta, hue: 60},
    {name: 'Alpha', value: eegData.alpha, hue: 180},
    {name: 'Beta', value: eegData.beta, hue: 270},
    {name: 'Gamma', value: eegData.gamma, hue: 300}
  ];
  
  let total = bands.reduce((sum, b) => sum + b.value, 0);
  let startAngle = 0;
  let radius = min(width, height) * 0.35;
  
  for (let i = 0; i < bands.length; i++) {
    let band = bands[i];
    let angle = (band.value / total) * TWO_PI;
    
    // Draw wedge
    fill(band.hue, 70, 90);
    arc(0, 0, radius * 2, radius * 2, startAngle, startAngle + angle, PIE);
    
    // Draw label
    let midAngle = startAngle + angle / 2;
    let labelX = cos(midAngle) * radius * 0.6;
    let labelY = sin(midAngle) * radius * 0.6;
    
    fill(0, 0, 100);
    textAlign(CENTER, CENTER);
    textSize(12);
    text(band.name, labelX, labelY);
    
    startAngle += angle;
  }
}`,

            spectra: `// Spectra - frequency spectrum visualization
let spectrumHistory = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Add current spectrum to history
  spectrumHistory.push({
    delta: eegData.delta,
    theta: eegData.theta,
    alpha: eegData.alpha,
    beta: eegData.beta,
    gamma: eegData.gamma
  });
  
  if (spectrumHistory.length > 100) {
    spectrumHistory.shift();
  }
  
  // Draw spectrum over time
  let bands = ['delta', 'theta', 'alpha', 'beta', 'gamma'];
  let hues = [0, 60, 180, 270, 300];
  
  for (let b = 0; b < bands.length; b++) {
    stroke(hues[b], 70, 90);
    strokeWeight(2);
    noFill();
    
    beginShape();
    for (let i = 0; i < spectrumHistory.length; i++) {
      let x = map(i, 0, spectrumHistory.length - 1, 50, width - 50);
      let y = height/2 + (b - 2) * 60 - spectrumHistory[i][bands[b]] * 40;
      vertex(x, y);
    }
    endShape();
    
    // Label
    fill(hues[b], 70, 90);
    noStroke();
    textAlign(LEFT, CENTER);
    textSize(10);
    text(bands[b].toUpperCase(), 10, height/2 + (b - 2) * 60);
  }
}`,

            ColourBalls: `// Colour balls - attention-controlled bouncing balls
let balls = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  for (let i = 0; i < 20; i++) {
    balls.push({
      x: random(width),
      y: random(height),
      vx: random(-3, 3),
      vy: random(-3, 3),
      size: random(10, 40),
      hue: random(360)
    });
  }
}

function draw() {
  background(0, 0, 5, 0.2);
  
  for (let ball of balls) {
    // Update position
    ball.x += ball.vx * (1 + eegData.attention);
    ball.y += ball.vy * (1 + eegData.attention);
    
    // Bounce off edges
    if (ball.x < 0 || ball.x > width) ball.vx *= -1;
    if (ball.y < 0 || ball.y > height) ball.vy *= -1;
    
    // Keep in bounds
    ball.x = constrain(ball.x, 0, width);
    ball.y = constrain(ball.y, 0, height);
    
    // Rotate hue based on meditation
    ball.hue = (ball.hue + eegData.meditation * 2) % 360;
    
    // Draw ball
    fill(ball.hue, 70, 90, 0.8);
    noStroke();
    ellipse(ball.x, ball.y, ball.size);
  }
}`,

            MultipleBalls: `// Multiple balls with different behaviors
let balls = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      balls.push({
        x: (i + 1) * width / 4,
        y: (j + 1) * height / 4,
        vx: random(-2, 2),
        vy: random(-2, 2),
        type: (i * 3 + j) % 5,
        phase: random(TWO_PI)
      });
    }
  }
}

function draw() {
  background(0, 0, 10, 0.1);
  
  let bands = [eegData.delta, eegData.theta, eegData.alpha, eegData.beta, eegData.gamma];
  let hues = [0, 60, 180, 270, 300];
  
  for (let ball of balls) {
    let bandValue = bands[ball.type];
    let hue = hues[ball.type];
    
    // Update with different behavior per type
    ball.x += ball.vx * (1 + bandValue);
    ball.y += ball.vy * (1 + bandValue);
    
    // Bounce
    if (ball.x < 0 || ball.x > width) ball.vx *= -1;
    if (ball.y < 0 || ball.y > height) ball.vy *= -1;
    
    ball.x = constrain(ball.x, 0, width);
    ball.y = constrain(ball.y, 0, height);
    
    // Draw
    let size = 15 + bandValue * 30;
    fill(hue, 70, 90, 0.7);
    noStroke();
    ellipse(ball.x, ball.y, size);
  }
}`,

            '3dTorus': `// 3D Torus controlled by brain waves
let rotX = 0;
let rotY = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Setup 3D
  push();
  translate(width/2, height/2);
  
  // Rotate based on brain waves
  rotX += eegData.alpha * 0.02;
  rotY += eegData.beta * 0.02;
  
  rotateX(rotX);
  rotateY(rotY);
  
  // Draw torus with changing parameters
  let radius = 50 + eegData.meditation * 50;
  let tubeRadius = 10 + eegData.attention * 20;
  
  // Color based on theta
  let hue = eegData.theta * 360;
  fill(hue, 70, 90);
  noStroke();
  
  torus(radius, tubeRadius);
  pop();
  
  // Info text
  fill(0, 0, 100);
  textAlign(LEFT, TOP);
  textSize(10);
  text("Alpha: rotation X", 10, 10);
  text("Beta: rotation Y", 10, 25);
  text("Meditation: radius", 10, 40);
  text("Attention: tube", 10, 55);
}`,

            AlphaSnake: `// Alpha snake - snake controlled by alpha waves
let snake = [];
let angle = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  // Initialize snake
  for (let i = 0; i < 50; i++) {
    snake.push({x: width/2, y: height/2});
  }
}

function draw() {
  background(0, 0, 5, 0.1);
  
  // Move snake head based on alpha
  angle += map(eegData.alpha, 0, 1, -0.1, 0.1);
  let speed = 2 + eegData.beta * 3;
  
  let headX = snake[0].x + cos(angle) * speed;
  let headY = snake[0].y + sin(angle) * speed;
  
  // Wrap around
  headX = (headX + width) % width;
  headY = (headY + height) % height;
  
  // Add new head
  snake.unshift({x: headX, y: headY});
  snake.pop();
  
  // Draw snake
  for (let i = 0; i < snake.length; i++) {
    let hue = (i * 5 + frameCount) % 360;
    let size = map(i, 0, snake.length - 1, 20, 5);
    let brightness = 50 + eegData.attention * 40;
    
    fill(hue, 70, brightness);
    noStroke();
    ellipse(snake[i].x, snake[i].y, size);
  }
}`,

            SplineBounce: `// Spline bounce - smooth curves with EEG
let points = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  // Initialize points
  for (let i = 0; i < 8; i++) {
    points.push({
      x: random(width),
      y: random(height),
      vx: random(-2, 2),
      vy: random(-2, 2)
    });
  }
}

function draw() {
  background(0, 0, 10);
  
  // Update points
  for (let p of points) {
    p.x += p.vx * (1 + eegData.attention * 0.5);
    p.y += p.vy * (1 + eegData.attention * 0.5);
    
    if (p.x < 0 || p.x > width) p.vx *= -1;
    if (p.y < 0 || p.y > height) p.vy *= -1;
    
    p.x = constrain(p.x, 0, width);
    p.y = constrain(p.y, 0, height);
  }
  
  // Draw smooth curve through points
  stroke(180 + eegData.alpha * 180, 70, 90);
  strokeWeight(2 + eegData.meditation * 5);
  noFill();
  
  beginShape();
  for (let i = 0; i < points.length; i++) {
    curveVertex(points[i].x, points[i].y);
  }
  // Repeat first points to close curve
  curveVertex(points[0].x, points[0].y);
  curveVertex(points[1].x, points[1].y);
  endShape();
  
  // Draw control points
  for (let p of points) {
    fill(60, 70, 90);
    noStroke();
    ellipse(p.x, p.y, 8);
  }
}`,

            BrainDraw: `// Brain draw - draw with your mind
let drawing = [];
let x, y;

function setup() {
  colorMode(HSB, 360, 100, 100);
  x = width/2;
  y = height/2;
}

function draw() {
  // Fade background slowly
  background(0, 0, 5, 0.02);
  
  // Move based on brain waves
  let dx = map(eegData.alpha - 0.5, -0.5, 0.5, -3, 3);
  let dy = map(eegData.beta - 0.5, -0.5, 0.5, -3, 3);
  
  x += dx;
  y += dy;
  
  // Keep in bounds
  x = constrain(x, 0, width);
  y = constrain(y, 0, height);
  
  // Draw if attention is high
  if (eegData.attention > 0.3) {
    let hue = eegData.theta * 360;
    let size = 5 + eegData.meditation * 20;
    
    fill(hue, 70, 90, 0.6);
    noStroke();
    ellipse(x, y, size);
    
    drawing.push({x: x, y: y, hue: hue, size: size});
    
    // Limit history
    if (drawing.length > 500) {
      drawing.shift();
    }
  }
  
  // Draw cursor
  stroke(0, 0, 100);
  strokeWeight(2);
  noFill();
  ellipse(x, y, 20);
  
  // Instructions
  fill(0, 0, 100);
  textAlign(LEFT, TOP);
  textSize(10);
  text("Alpha: move X | Beta: move Y", 10, 10);
  text("Attention: draw | Theta: color | Meditation: size", 10, 25);
}`,

            bouncingLine: `// Bouncing line with brain control
let x1, y1, x2, y2;
let vx1, vy1, vx2, vy2;

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  x1 = width/4;
  y1 = height/2;
  x2 = 3*width/4;
  y2 = height/2;
  
  vx1 = random(-3, 3);
  vy1 = random(-3, 3);
  vx2 = random(-3, 3);
  vy2 = random(-3, 3);
}

function draw() {
  background(0, 0, 5, 0.1);
  
  // Update endpoints
  let speed = 1 + eegData.attention;
  x1 += vx1 * speed;
  y1 += vy1 * speed;
  x2 += vx2 * speed;
  y2 += vy2 * speed;
  
  // Bounce
  if (x1 < 0 || x1 > width) vx1 *= -1;
  if (y1 < 0 || y1 > height) vy1 *= -1;
  if (x2 < 0 || x2 > width) vx2 *= -1;
  if (y2 < 0 || y2 > height) vy2 *= -1;
  
  x1 = constrain(x1, 0, width);
  y1 = constrain(y1, 0, height);
  x2 = constrain(x2, 0, width);
  y2 = constrain(y2, 0, height);
  
  // Draw line with varying thickness
  let weight = 1 + eegData.alpha * 20;
  let hue = eegData.theta * 360;
  
  stroke(hue, 70, 90);
  strokeWeight(weight);
  line(x1, y1, x2, y2);
  
  // Draw endpoints
  noStroke();
  fill(hue, 90, 90);
  ellipse(x1, y1, 15);
  ellipse(x2, y2, 15);
}`,

            ghostLines: `// Ghost lines - trailing line patterns
let lines = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5, 0.05);
  
  // Add new line
  if (frameCount % 3 === 0) {
    lines.push({
      x1: width/2 + cos(frameCount * 0.05) * 100,
      y1: height/2 + sin(frameCount * 0.05) * 100,
      x2: width/2 + cos(frameCount * 0.05 + PI) * 100,
      y2: height/2 + sin(frameCount * 0.05 + PI) * 100,
      life: 1.0,
      hue: (frameCount + eegData.alpha * 360) % 360
    });
  }
  
  // Draw and update lines
  for (let i = lines.length - 1; i >= 0; i--) {
    let line = lines[i];
    
    // Expand line
    let expansion = (1 - line.life) * eegData.attention * 50;
    let x1 = line.x1 + cos(atan2(line.y1 - height/2, line.x1 - width/2)) * expansion;
    let y1 = line.y1 + sin(atan2(line.y1 - height/2, line.x1 - width/2)) * expansion;
    let x2 = line.x2 + cos(atan2(line.y2 - height/2, line.x2 - width/2)) * expansion;
    let y2 = line.y2 + sin(atan2(line.y2 - height/2, line.x2 - width/2)) * expansion;
    
    stroke(line.hue, 70, 90, line.life);
    strokeWeight(2 + eegData.meditation * 5);
    stroke(line.hue, 70, 90, line.life);
    line(x1, y1, x2, y2);
    
    line.life -= 0.01;
    if (line.life <= 0) {
      lines.splice(i, 1);
    }
  }
}`,

            // Examples inspired by PerThirtySix creative coding
            perlinNoise: `// Perlin noise visualization with EEG control
function setup() {
  colorMode(HSB, 360, 100, 100);
  noLoop();
}

function draw() {
  background(0, 0, 10);
  
  let scale = 0.01 + eegData.alpha * 0.02;
  let detail = floor(1 + eegData.attention * 7);
  
  noiseDetail(detail, 0.5);
  
  // Draw noise field
  for (let x = 0; x < width; x += 5) {
    for (let y = 0; y < height; y += 5) {
      let noiseVal = noise(x * scale, y * scale, frameCount * 0.01);
      
      let hue = map(noiseVal, 0, 1, 180, 300);
      let brightness = map(noiseVal, 0, 1, 30, 90);
      
      fill(hue, 70, brightness);
      noStroke();
      rect(x, y, 5, 5);
    }
  }
  
  // Info
  fill(0, 0, 100);
  textAlign(LEFT, TOP);
  textSize(10);
  text("Alpha: scale | Attention: detail", 10, 10);
}

function mousePressed() {
  redraw();
}`,

            organicHeatmap: `// Organic heatmap using Perlin noise
function setup() {
  colorMode(HSB, 360, 100, 100);
  frameRate(30);
}

function draw() {
  background(0, 0, 5);
  
  let scale = 0.005 + eegData.meditation * 0.01;
  let timeOffset = frameCount * 0.02 * (1 + eegData.beta);
  
  // Create organic heatmap
  for (let x = 0; x < width; x += 8) {
    for (let y = 0; y < height; y += 8) {
      let noiseVal = noise(x * scale, y * scale, timeOffset);
      
      // Map noise to heat colors
      let hue = map(noiseVal, 0, 1, 0, 60); // Red to yellow
      let saturation = 80 + eegData.attention * 20;
      let brightness = map(noiseVal, 0, 1, 20, 90);
      
      fill(hue, saturation, brightness, 0.8);
      noStroke();
      ellipse(x, y, 10, 10);
    }
  }
}`,

            noiseDetail: `// Noise with varying detail levels
let noiseScale = 0.01;
let detailLevel = 4;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  
  // EEG controls noise detail
  detailLevel = 1 + floor(eegData.attention * 7);
  noiseScale = 0.005 + eegData.alpha * 0.015;
  
  noiseDetail(detailLevel, 0.5);
  
  // Draw noise patterns
  loadPixels();
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      let noiseVal = noise(
        x * noiseScale,
        y * noiseScale,
        frameCount * 0.01
      );
      
      let brightness = map(noiseVal, 0, 1, 0, 100);
      let hue = 200 + eegData.theta * 160;
      
      let index = (x + y * width) * 4;
      let c = color(hue, 70, brightness);
      
      pixels[index] = red(c);
      pixels[index + 1] = green(c);
      pixels[index + 2] = blue(c);
      pixels[index + 3] = 255;
    }
  }
  updatePixels();
  
  // Info overlay
  fill(0, 0, 100);
  textAlign(LEFT, TOP);
  textSize(12);
  text(\`Detail: \${detailLevel} octaves\`, 10, 10);
  text(\`Scale: \${noiseScale.toFixed(3)}\`, 10, 25);
}`,

            discreteColors: `// Discrete colors from noise
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  
  let scale = 0.01 + eegData.alpha * 0.02;
  let colorSteps = 3 + floor(eegData.attention * 7);
  
  // Draw with discrete color steps
  for (let x = 0; x < width; x += 10) {
    for (let y = 0; y < height; y += 10) {
      let noiseVal = noise(x * scale, y * scale, frameCount * 0.01);
      
      // Discretize the noise value
      let step = floor(noiseVal * colorSteps) / colorSteps;
      
      let hue = step * 360;
      let brightness = 50 + eegData.meditation * 40;
      
      fill(hue, 70, brightness);
      noStroke();
      rect(x, y, 10, 10);
    }
  }
  
  // Show color steps
  fill(0, 0, 100);
  textAlign(LEFT, TOP);
  textSize(12);
  text(\`Color steps: \${colorSteps}\`, 10, 10);
}`,

            smoothColors: `// Smooth color transitions from noise
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  let scale = 0.005 + eegData.meditation * 0.01;
  let speed = 0.01 + eegData.beta * 0.05;
  
  // Smooth color field
  for (let x = 0; x < width; x += 5) {
    for (let y = 0; y < height; y += 5) {
      let noiseVal = noise(
        x * scale,
        y * scale,
        frameCount * speed
      );
      
      // Smooth color mapping
      let hue = noiseVal * 360;
      let saturation = 60 + eegData.alpha * 30;
      let brightness = 40 + noiseVal * 50;
      
      fill(hue, saturation, brightness);
      noStroke();
      rect(x, y, 6, 6);
    }
  }
}`,

            animatingNoise: `// Animating noise field
let time = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5, 0.1);
  
  let scale = 0.008;
  let speed = 0.02 + eegData.attention * 0.08;
  
  time += speed;
  
  // Draw animated noise
  for (let i = 0; i < 30; i++) {
    for (let j = 0; j < 30; j++) {
      let x = i * width / 30;
      let y = j * height / 30;
      
      let noiseVal = noise(
        i * scale,
        j * scale,
        time
      );
      
      let size = noiseVal * 40 * (1 + eegData.alpha);
      let hue = (noiseVal * 120 + time * 50) % 360;
      let brightness = 50 + eegData.meditation * 40;
      
      fill(hue, 70, brightness, 0.7);
      noStroke();
      ellipse(x + width/60, y + height/60, size, size);
    }
  }
}`,

            bouncingCircles: `// Bouncing circles with brain control
let circles = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  // Create bouncing circles
  for (let i = 0; i < 10; i++) {
    circles.push({
      x: random(width),
      y: random(height),
      vx: random(-3, 3),
      vy: random(-3, 3),
      size: random(20, 60),
      hue: random(360)
    });
  }
}

function draw() {
  background(0, 0, 5, 0.1);
  
  for (let circle of circles) {
    // Update position with attention multiplier
    let speedMult = 0.5 + eegData.attention * 1.5;
    circle.x += circle.vx * speedMult;
    circle.y += circle.vy * speedMult;
    
    // Bounce off edges with energy from brain
    if (circle.x < 0 || circle.x > width) {
      circle.vx *= -1;
      circle.hue = (circle.hue + eegData.alpha * 60) % 360;
    }
    if (circle.y < 0 || circle.y > height) {
      circle.vy *= -1;
      circle.hue = (circle.hue + eegData.beta * 60) % 360;
    }
    
    circle.x = constrain(circle.x, 0, width);
    circle.y = constrain(circle.y, 0, height);
    
    // Draw with alpha affecting size
    let displaySize = circle.size * (0.7 + eegData.meditation * 0.6);
    fill(circle.hue, 70, 90, 0.7);
    noStroke();
    ellipse(circle.x, circle.y, displaySize);
  }
}`,

            waveAnimation: `// Wave animation controlled by brain
let waveOffset = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  
  let speed = 0.02 + eegData.beta * 0.08;
  waveOffset += speed;
  
  // Draw multiple wave layers
  for (let layer = 0; layer < 5; layer++) {
    let waveAmplitude = 30 + eegData.alpha * 70;
    let waveFrequency = 0.01 + layer * 0.005;
    let yBase = (layer + 1) * height / 6;
    
    let hue = (layer * 60 + eegData.theta * 120) % 360;
    
    fill(hue, 70, 90, 0.5);
    noStroke();
    
    beginShape();
    vertex(0, height);
    for (let x = 0; x <= width; x += 5) {
      let y = yBase + sin((x * waveFrequency) + waveOffset + layer) * waveAmplitude;
      vertex(x, y);
    }
    vertex(width, height);
    endShape(CLOSE);
  }
  
  // Draw wave on top showing meditation
  stroke(0, 0, 100);
  strokeWeight(2);
  noFill();
  
  beginShape();
  for (let x = 0; x <= width; x += 5) {
    let y = height/2 + sin((x * 0.02) + waveOffset) * 
            (50 + eegData.meditation * 100);
    vertex(x, y);
  }
  endShape();
}`,

            colorfulGrid: `// Animated colorful grid
let gridSize = 20;
let time = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  
  let speed = 0.05 + eegData.attention * 0.15;
  time += speed;
  
  let cols = floor(width / gridSize);
  let rows = floor(height / gridSize);
  
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let x = i * gridSize;
      let y = j * gridSize;
      
      // Animated properties
      let distance = dist(i, j, cols/2, rows/2);
      let offset = distance * 0.1 - time;
      
      let hue = (i * 10 + j * 10 + time * 50 + eegData.theta * 180) % 360;
      let brightness = 50 + sin(offset) * 25 + eegData.alpha * 25;
      let size = gridSize * (0.5 + (sin(offset) * 0.3 + 0.5) * 
                 (0.5 + eegData.meditation * 0.5));
      
      fill(hue, 70, brightness);
      noStroke();
      
      push();
      translate(x + gridSize/2, y + gridSize/2);
      rotate(offset);
      rectMode(CENTER);
      rect(0, 0, size, size);
      pop();
    }
  }
}`,

            webcamInput: `// Webcam input with brain-controlled effects
let capture;
let pixelDensity = 10;

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  // Create video capture
  capture = createCapture(VIDEO);
  capture.size(width/pixelDensity, height/pixelDensity);
  capture.hide();
}

function draw() {
  background(0, 0, 10);
  
  capture.loadPixels();
  
  // Process webcam pixels
  for (let y = 0; y < capture.height; y++) {
    for (let x = 0; x < capture.width; x++) {
      let index = (x + y * capture.width) * 4;
      
      let r = capture.pixels[index];
      let g = capture.pixels[index + 1];
      let b = capture.pixels[index + 2];
      
      let bright = (r + g + b) / 3;
      
      // Apply brain-controlled effects
      let hueShift = eegData.alpha * 180;
      let size = map(bright, 0, 255, 0, pixelDensity * (1 + eegData.attention));
      
      let pixelHue = (bright + hueShift) % 360;
      let saturation = 60 + eegData.theta * 40;
      let pixelBrightness = map(bright, 0, 255, 20, 90);
      
      fill(pixelHue, saturation, pixelBrightness);
      noStroke();
      
      ellipse(
        x * pixelDensity + pixelDensity/2,
        y * pixelDensity + pixelDensity/2,
        size, size
      );
    }
  }
  
  // Info
  fill(0, 0, 100);
  textAlign(LEFT, BOTTOM);
  textSize(10);
  text("Alpha: hue shift | Attention: size | Theta: saturation", 10, height - 10);
  
  if (!capture.loadedmetadata) {
    textAlign(CENTER, CENTER);
    textSize(14);
    text("Waiting for webcam...", width/2, height/2);
  }
}`,

            brainBeats: `// Brain Beats - Simple sound test with EEG
let osc;
let isPlaying = false;

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  // Create oscillator for brain-controlled tones
  osc = new p5.Oscillator('sine');
  osc.amp(0); // Start silent
  osc.start();
  
  console.log('🔊 === Brain Beats Sound Test ===');
  console.log('✅ Oscillator created successfully');
  console.log('👆 CLICK ANYWHERE ON THE CANVAS to enable sound');
  console.log('📊 Alpha waves control the tone frequency (200-800 Hz)');
  console.log('📊 Beta waves control the volume');
  console.log('');
  console.log('💡 TIP: If you don\'t hear anything after clicking:');
  console.log('   1. Check your computer volume');
  console.log('   2. Click the "Test Sound" button in the header');
  console.log('   3. Make sure you clicked inside the black canvas area');
}

function draw() {
  background(0, 0, 10);
  
  // Visual feedback
  let visualAlpha = eegData.alpha;
  let visualBeta = eegData.beta;
  
  // Draw sound wave visualization
  translate(width/2, height/2);
  
  // Outer circle - attention level (pulsing)
  let outerSize = 100 + eegData.attention * 200;
  noFill();
  stroke(180, 70, 90, 0.8);
  strokeWeight(3);
  ellipse(0, 0, outerSize);
  
  // Inner circle - frequency indicator
  let freq = map(visualAlpha, 0, 1, 200, 800);
  let innerSize = 50 + visualAlpha * 150;
  let hue = map(visualAlpha, 0, 1, 200, 320);
  
  fill(hue, 80, 90, 0.5);
  noStroke();
  ellipse(0, 0, innerSize);
  
  // Volume indicator (small circle)
  let volumeSize = 10 + visualBeta * 30;
  fill(60, 80, 90, 0.8);
  ellipse(0, 0, volumeSize);
  
  // Update sound if playing
  if (isPlaying) {
    osc.freq(freq);
    let volume = map(visualBeta, 0, 1, 0, 0.3);
    osc.amp(volume, 0.1);
  }
  
  // Instructions
  resetMatrix();
  fill(0, 0, 100);
  textAlign(CENTER, TOP);
  textSize(18);
  text(isPlaying ? "🔊 Sound is ON" : "🔇 CLICK HERE to start sound", width/2, 20);
  
  textSize(14);
  text("Alpha controls frequency: " + freq.toFixed(0) + " Hz", width/2, 50);
  text("Beta controls volume: " + (visualBeta * 100).toFixed(0) + "%", width/2, 70);
  
  // Add a pulsing border when not playing to indicate clickability
  if (!isPlaying) {
    noFill();
    stroke(255, 100, 100, sin(frameCount * 0.1) * 0.3 + 0.5);
    strokeWeight(4);
    rect(5, 5, width - 10, height - 10);
  }
  
  if (!eegData.connected) {
    textSize(14);
    fill(0, 0, 70);
    text("⚠️ Connect Muse or use Simulate Data for brain control", width/2, height - 30);
  }
}

function mousePressed() {
  console.log('👆 Canvas clicked!');
  
  // User interaction required to start audio
  console.log('Attempting to start audio context...');
  userStartAudio();
  
  // Toggle sound
  isPlaying = !isPlaying;
  
  if (isPlaying) {
    console.log('🔊 Sound enabled!');
    console.log('You should hear a tone that changes with your brain waves');
  } else {
    osc.amp(0, 0.1);
    console.log('🔇 Sound disabled');
  }
}`,

            alphaMusic: `// Alpha Wave Music - Generative music from brain waves
let notes = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25]; // C major scale (C4-C5)
let noteNames = ['C4', 'D4', 'E4', 'G4', 'A4', 'C5'];
let synth;
let reverb;
let lastNoteTime = 0;
let isPlaying = false;

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  console.log('🎵 === Alpha Wave Music ===');
  console.log('Creating polyphonic synthesizer...');
  
  // Create synthesizer
  synth = new p5.PolySynth();
  console.log('✅ Synthesizer created');
  
  // Add reverb effect
  reverb = new p5.Reverb();
  reverb.process(synth, 3, 2);
  console.log('✅ Reverb effect added');
  
  console.log('');
  console.log('👆 CLICK THE CANVAS to start generative music');
  console.log('📊 Your brain waves control the music:');
  console.log('   - Alpha: selects which note to play');
  console.log('   - Attention: controls tempo (speed)');
  console.log('   - Beta: note duration');
  console.log('   - Meditation: note velocity (loudness)');
  console.log('');
  console.log('💡 Use "Simulate Data" to control the music without a Muse');
}

function draw() {
  background(0, 0, 5, 0.1);
  
  // Generate music based on brain waves
  if (isPlaying && millis() - lastNoteTime > map(eegData.attention, 0, 1, 800, 200)) {
    playBrainNote();
    lastNoteTime = millis();
  }
  
  // Visualize music
  translate(width/2, height/2);
  
  // Draw concentric circles for each frequency band
  let bands = [
    {value: eegData.delta, color: 0, radius: 50, name: 'Delta'},
    {value: eegData.theta, color: 60, radius: 100, name: 'Theta'},
    {value: eegData.alpha, color: 180, radius: 150, name: 'Alpha'},
    {value: eegData.beta, color: 270, radius: 200, name: 'Beta'},
    {value: eegData.gamma, color: 300, radius: 250, name: 'Gamma'}
  ];
  
  for (let band of bands) {
    let size = band.radius + band.value * 50;
    stroke(band.color, 70, 90, 0.6);
    strokeWeight(2 + band.value * 5);
    noFill();
    ellipse(0, 0, size * 2);
  }
  
  // Info
  resetMatrix();
  
  // Add pulsing border when not playing
  if (!isPlaying) {
    noFill();
    stroke(180, 100, 100, sin(frameCount * 0.1) * 0.3 + 0.5);
    strokeWeight(4);
    rect(5, 5, width - 10, height - 10);
  }
  
  fill(0, 0, 100);
  textAlign(CENTER, TOP);
  textSize(18);
  text(isPlaying ? "🎵 Music Playing" : "🎵 CLICK HERE to start music", width/2, 20);
  
  textSize(12);
  text("Alpha: note selection | Attention: tempo | Beta: duration | Meditation: volume", width/2, 45);
  
  // Show current parameters
  if (isPlaying) {
    textSize(11);
    fill(180, 70, 90);
    let currentNote = floor(map(eegData.alpha, 0, 1, 0, notes.length));
    currentNote = constrain(currentNote, 0, notes.length - 1);
    let tempo = map(eegData.attention, 0, 1, 800, 200).toFixed(0);
    text(\`Current: \${noteNames[currentNote]} | Tempo: \${tempo}ms | Duration: \${eegData.beta.toFixed(2)}\`, width/2, 65);
  }
  
  if (!eegData.connected) {
    textSize(14);
    fill(0, 0, 70);
    text("⚠️ Use 'Simulate Data' button to control the music", width/2, height - 30);
  }
}

function playBrainNote() {
  // Select note based on alpha
  let noteIndex = floor(map(eegData.alpha, 0, 1, 0, notes.length));
  noteIndex = constrain(noteIndex, 0, notes.length - 1);
  
  // Duration based on beta
  let duration = map(eegData.beta, 0, 1, 0.1, 0.5);
  
  // Velocity based on meditation
  let velocity = map(eegData.meditation, 0, 1, 0.3, 1.0);
  
  // Play the note
  synth.play(notes[noteIndex], velocity, 0, duration);
  
  // Log occasionally (every 10th note)
  if (frameCount % 10 === 0) {
    console.log(\`🎵 Playing: \${noteNames[noteIndex]} at \${(velocity * 100).toFixed(0)}% volume\`);
  }
}

function mousePressed() {
  console.log('👆 Canvas clicked!');
  console.log('Starting audio context...');
  userStartAudio();
  
  isPlaying = !isPlaying;
  
  if (isPlaying) {
    console.log('🎵 Music started! Listen as your brain waves create melodies...');
  } else {
    console.log('🎵 Music stopped');
  }
}`,

            brainSynth: `// Brain Synthesizer - Full control over sound parameters
let carrier;
let modulator;
let analyzer;
let isPlaying = false;

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  console.log('🎹 === Brain Synthesizer (FM Synthesis) ===');
  console.log('Creating carrier oscillator...');
  
  // Create FM synthesis
  carrier = new p5.Oscillator('sine');
  modulator = new p5.Oscillator('sine');
  console.log('✅ Oscillators created');
  
  // Modulate carrier frequency with modulator
  modulator.disconnect();
  carrier.amp(0);
  modulator.amp(0);
  
  carrier.start();
  modulator.start();
  modulator.disconnect();
  carrier.freq(modulator);
  console.log('✅ FM synthesis configured');
  
  // Analyzer for visualization
  analyzer = new p5.FFT();
  analyzer.setInput(carrier);
  console.log('✅ Audio analyzer ready');
  
  console.log('');
  console.log('👆 CLICK THE CANVAS to start the synthesizer');
  console.log('📊 Brain wave control mapping:');
  console.log('   - Alpha: carrier frequency (pitch)');
  console.log('   - Beta: modulation frequency (timbre)');
  console.log('   - Theta: modulation depth (intensity)');
  console.log('   - Attention: overall volume');
  console.log('');
  console.log('💡 This is FM (Frequency Modulation) synthesis');
  console.log('   The modulator oscillator modulates the carrier frequency');
  console.log('   creating complex harmonic timbres');
}

function draw() {
  background(0, 0, 5);
  
  if (isPlaying) {
    // Map brain waves to synthesis parameters
    
    // Alpha controls carrier frequency (200-800 Hz)
    let carrierFreq = map(eegData.alpha, 0, 1, 200, 800);
    
    // Beta controls modulation frequency (0-100 Hz)
    let modFreq = map(eegData.beta, 0, 1, 0, 100);
    
    // Theta controls modulation depth
    let modDepth = map(eegData.theta, 0, 1, 0, 500);
    
    // Attention controls overall volume
    let volume = map(eegData.attention, 0, 1, 0, 0.2);
    
    // Update synthesis parameters
    carrier.freq(carrierFreq);
    modulator.freq(modFreq);
    modulator.amp(modDepth);
    carrier.amp(volume, 0.1);
    
    // Visualize waveform
    let waveform = analyzer.waveform();
    
    noFill();
    stroke(180 + eegData.theta * 180, 80, 90);
    strokeWeight(2);
    
    beginShape();
    for (let i = 0; i < waveform.length; i++) {
      let x = map(i, 0, waveform.length, 0, width);
      let y = map(waveform[i], -1, 1, height * 0.3, height * 0.7);
      vertex(x, y);
    }
    endShape();
    
    // Draw spectrum
    let spectrum = analyzer.analyze();
    noStroke();
    for (let i = 0; i < spectrum.length; i++) {
      let x = map(i, 0, spectrum.length, 0, width);
      let h = map(spectrum[i], 0, 255, 0, height * 0.3);
      let hue = map(i, 0, spectrum.length, 180, 300);
      fill(hue, 70, 90, 0.8);
      rect(x, height, width / spectrum.length, -h);
    }
  }
  
  // Add pulsing border when not playing
  if (!isPlaying) {
    noFill();
    stroke(180, 100, 100, sin(frameCount * 0.1) * 0.3 + 0.5);
    strokeWeight(4);
    rect(5, 5, width - 10, height - 10);
  }
  
  // Display parameters
  fill(0, 0, 100);
  textAlign(CENTER, TOP);
  textSize(16);
  text(isPlaying ? "🎹 Synthesizer ON" : "🎹 CLICK HERE to start", width/2, 10);
  
  if (isPlaying) {
    textAlign(LEFT, TOP);
    textSize(11);
    fill(180, 70, 90);
    text("Carrier: " + carrier.getFreq().toFixed(1) + " Hz (Alpha)", 10, 35);
    text("Mod Freq: " + modulator.getFreq().toFixed(1) + " Hz (Beta)", 10, 50);
    text("Mod Depth: " + modulator.getAmp().toFixed(1) + " (Theta)", 10, 65);
    text("Volume: " + (carrier.getAmp() * 100).toFixed(0) + "% (Attention)", 10, 80);
  } else {
    textAlign(CENTER, TOP);
    textSize(12);
    fill(0, 0, 70);
    text("Alpha = Pitch | Beta = Timbre | Theta = Intensity | Attention = Volume", width/2, 35);
  }
  
  if (!eegData.connected) {
    textAlign(CENTER, BOTTOM);
    textSize(14);
    fill(0, 0, 70);
    text("⚠️ Use 'Simulate Data' to control the synthesizer", width/2, height - 20);
  }
}

function mousePressed() {
  console.log('👆 Canvas clicked!');
  console.log('Starting audio context...');
  userStartAudio();
  
  isPlaying = !isPlaying;
  
  if (isPlaying) {
    console.log('🎹 Synthesizer started!');
    console.log('Listen to the complex timbres created by FM synthesis');
    console.log('Adjust the simulation sliders to hear different sounds');
  } else {
    carrier.amp(0, 0.1);
    console.log('🎹 Synthesizer stopped');
  }
}`
          };

          if (examples[exampleName]) {
            const exampleCode = examples[exampleName];
            this.editor.setValue(exampleCode);
            this.lastLoadedCode = exampleCode;
            this.lastLoadedFilename = `${exampleName}-example.js`;
            
            // Enable reload button
            document.getElementById('reload-btn').disabled = false;
            
            this.runCode();
          }
        }
      }

      // Reference Panel Manager
      class ReferencePanel {
        constructor() {
          this.currentTab = 'p5js';
          this.setupTabs();
          this.loadContent('p5js');
        }

        setupTabs() {
          document.querySelectorAll('.reference-tab').forEach(tab => {
            tab.addEventListener('click', () => {
              // Update active tab
              document.querySelectorAll('.reference-tab').forEach(t => t.classList.remove('active'));
              tab.classList.add('active');
              
              // Load content
              const tabName = tab.dataset.tab;
              this.loadContent(tabName);
            });
          });
        }

        loadContent(tabName) {
          this.currentTab = tabName;
          const contentDiv = document.getElementById('reference-content');
          const aiAssistant = document.getElementById('ai-assistant');
          
          if (tabName === 'ai') {
            contentDiv.style.display = 'none';
            aiAssistant.style.display = 'flex';
          } else {
            contentDiv.style.display = 'block';
            aiAssistant.style.display = 'none';
            
            if (tabName === 'p5js') {
              contentDiv.innerHTML = this.renderReference(p5Reference);
            } else if (tabName === 'sound') {
              contentDiv.innerHTML = this.renderReference(soundReference);
            } else if (tabName === 'input') {
              contentDiv.innerHTML = this.renderReference(inputReference);
            } else if (tabName === 'eeg') {
              contentDiv.innerHTML = this.renderReference(eegReference);
            }
            
            // Add click handlers for inserting code
            this.setupFunctionClicks();
          }
        }

        renderReference(reference) {
          let html = '';
          
          Object.keys(reference).forEach(groupName => {
            html += `<div class="function-group">`;
            html += `<div class="function-group-title">${groupName}</div>`;
            
            Object.keys(reference[groupName]).forEach(funcName => {
              const func = reference[groupName][funcName];
              html += `
                <div class="function-item" data-function="${funcName}">
                  <span class="function-name">${funcName}</span>
                  <div class="function-tooltip">
                    <div class="tooltip-signature">${func.signature}</div>
                    <div class="tooltip-description">${func.description}</div>
                  </div>
                </div>
              `;
            });
            
            html += `</div>`;
          });
          
          return html;
        }

        setupFunctionClicks() {
          document.querySelectorAll('.function-item').forEach(item => {
            // Handle click/touch to toggle expanded state
            const toggleExpanded = (e) => {
              // If clicking on an already expanded item, insert code
              if (item.classList.contains('expanded')) {
                // Only insert code if not clicking on the tooltip area
                const clickedOnTooltip = e.target.closest('.function-tooltip');
                if (!clickedOnTooltip) {
                  this.insertFunctionCode(item);
                }
              } else {
                // Collapse all other items
                document.querySelectorAll('.function-item.expanded').forEach(expandedItem => {
                  if (expandedItem !== item) {
                    expandedItem.classList.remove('expanded');
                  }
                });
                
                // Expand this item
                item.classList.add('expanded');
                
                // Scroll into view if needed
                item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
              }
              
              e.stopPropagation();
            };
            
            item.addEventListener('click', toggleExpanded);
            item.addEventListener('touchstart', (e) => {
              e.preventDefault();
              toggleExpanded(e);
            });
          });
          
          // Close expanded items when clicking outside
          document.getElementById('reference-content').addEventListener('click', (e) => {
            if (!e.target.closest('.function-item')) {
              document.querySelectorAll('.function-item.expanded').forEach(item => {
                item.classList.remove('expanded');
              });
            }
          });
        }
        
        insertFunctionCode(item) {
          const funcName = item.dataset.function;
          if (codeEditor && codeEditor.editor) {
            // Get the function signature to extract parameters
            let signature = '';
            let reference;
            
            // Determine which reference to use
            if (this.currentTab === 'p5js') {
              reference = p5Reference;
            } else if (this.currentTab === 'sound') {
              reference = soundReference;
            } else if (this.currentTab === 'input') {
              reference = inputReference;
            } else if (this.currentTab === 'eeg') {
              reference = eegReference;
            }
            
            // Find the function in the reference
            for (let group in reference) {
              if (reference[group][funcName]) {
                signature = reference[group][funcName].signature;
                break;
              }
            }
            
            // Parse parameters from signature
            let snippetText = this.createSnippet(funcName, signature);
            
            // Insert as Monaco snippet with placeholders
            const position = codeEditor.editor.getPosition();
            
            // Use Monaco's snippet controller for proper tab-through behavior
            const snippetController = codeEditor.editor.getContribution('snippetController2');
            if (snippetController && snippetText.includes('${')) {
              // Insert with snippet support (allows tab through placeholders)
              snippetController.insert(snippetText);
            } else {
              // Fallback to simple text insertion
              codeEditor.editor.executeEdits('', [{
                range: new monaco.Range(
                  position.lineNumber,
                  position.column,
                  position.lineNumber,
                  position.column
                ),
                text: snippetText,
                forceMoveMarkers: true
              }]);
            }
            
            codeEditor.editor.focus();
            
            // Show feedback
            item.style.animation = 'none';
            setTimeout(() => {
              item.style.animation = '';
              item.classList.add('code-inserted');
              setTimeout(() => item.classList.remove('code-inserted'), 500);
            }, 10);
          }
        }
        
        createSnippet(funcName, signature) {
          // Extract parameters from signature
          // e.g., "ellipse(x, y, width, [height])" -> ["x", "y", "width", "[height]"]
          
          if (!signature) {
            return funcName + '()';
          }
          
          // Find the parameters part (between parentheses)
          const paramsMatch = signature.match(/\(([^)]*)\)/);
          if (!paramsMatch || !paramsMatch[1].trim()) {
            return funcName + '()';
          }
          
          const paramsStr = paramsMatch[1];
          
          // Split by comma, handling nested brackets
          const params = paramsStr.split(',').map(p => p.trim()).filter(p => p);
          
          if (params.length === 0) {
            return funcName + '()';
          }
          
          // Create snippet with numbered placeholders
          let snippetParams = params.map((param, index) => {
            // Remove brackets for optional parameters but keep the name
            let cleanParam = param.replace(/[\[\]]/g, '');
            
            // Handle "or" alternatives (e.g., "color or r, g, b")
            if (cleanParam.includes(' or ')) {
              cleanParam = cleanParam.split(' or ')[0].trim();
            }
            
            return `\${${index + 1}:${cleanParam}}`;
          }).join(', ');
          
          return `${funcName}(${snippetParams})`;
        }
      }

      // AI Assistant Manager
      class AIAssistant {
        constructor() {
          this.apiKey = localStorage.getItem('brainimation_api_key') || '';
          this.apiProvider = localStorage.getItem('brainimation_api_provider') || 'openai';
          this.setupEventListeners();
          this.updateStatus();
        }

        setupEventListeners() {
          document.getElementById('ai-generate-btn').addEventListener('click', () => {
            this.generateCode();
          });

          document.getElementById('ai-config-btn').addEventListener('click', () => {
            this.showConfig();
          });
        }

        updateStatus() {
          const statusEl = document.getElementById('ai-status');
          if (this.apiKey) {
            statusEl.textContent = `Ready to assist (${this.apiProvider})`;
            statusEl.style.color = 'var(--success)';
          } else {
            statusEl.textContent = 'Configure API key to use AI features';
            statusEl.style.color = 'var(--muted)';
          }
        }

        showConfig() {
          const provider = prompt(
            'Select API Provider:\n\n1. OpenAI (ChatGPT)\n2. Anthropic (Claude)\n\nEnter 1 or 2:',
            this.apiProvider === 'anthropic' ? '2' : '1'
          );
          
          if (provider === '1' || provider === '2') {
            this.apiProvider = provider === '2' ? 'anthropic' : 'openai';
            localStorage.setItem('brainimation_api_provider', this.apiProvider);
            
            const key = prompt(
              `Enter your ${this.apiProvider === 'openai' ? 'OpenAI' : 'Anthropic'} API key:\n\n` +
              `(stored locally in browser only)`,
              this.apiKey
            );
            
            if (key !== null) {
              this.apiKey = key.trim();
              localStorage.setItem('brainimation_api_key', this.apiKey);
              this.updateStatus();
              alert('API key saved successfully!');
            }
          }
        }

        async generateCode() {
          if (!this.apiKey) {
            alert('Please configure your API key first (click ⚙️ button)');
            return;
          }

          const prompt = document.getElementById('ai-prompt').value.trim();
          if (!prompt) {
            alert('Please describe what you want to create or modify');
            return;
          }

          const statusEl = document.getElementById('ai-status');
          const generateBtn = document.getElementById('ai-generate-btn');
          
          try {
            generateBtn.disabled = true;
            statusEl.textContent = 'Generating code...';
            statusEl.style.color = 'var(--accent)';

            const currentCode = codeEditor.editor.getValue();
            
            const systemPrompt = `You are a helpful p5.js coding assistant for BrainImation, an EEG-powered creative coding platform. 
Help users create animations that respond to brain data available through the eegData object:
- eegData.alpha, beta, theta, delta, gamma (0.0-1.0)
- eegData.attention, meditation (0.0-1.0)
- eegData.getRawChannel(channel, numSamples) for raw EEG
- eegData.connected (boolean)

Respond ONLY with JavaScript code, no explanations or markdown. Include setup() and draw() functions.`;

            const userMessage = prompt + (currentCode ? `\n\nCurrent code:\n${currentCode}` : '');

            let generatedCode = '';

            if (this.apiProvider === 'openai') {
              const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${this.apiKey}`
                },
                body: JSON.stringify({
                  model: 'gpt-4',
                  messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userMessage }
                  ],
                  temperature: 0.7,
                  max_tokens: 2000
                })
              });

              if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
              }

              const data = await response.json();
              generatedCode = data.choices[0].message.content;
            } else if (this.apiProvider === 'anthropic') {
              const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-api-key': this.apiKey,
                  'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                  model: 'claude-3-5-sonnet-20241022',
                  max_tokens: 2000,
                  system: systemPrompt,
                  messages: [
                    { role: 'user', content: userMessage }
                  ]
                })
              });

              if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
              }

              const data = await response.json();
              generatedCode = data.content[0].text;
            }

            // Clean up code (remove markdown fences if present)
            generatedCode = generatedCode.replace(/```javascript\n?/g, '').replace(/```\n?/g, '').trim();

            // Insert into editor
            codeEditor.editor.setValue(generatedCode);
            
            statusEl.textContent = 'Code generated! Running...';
            statusEl.style.color = 'var(--success)';
            
            // Auto-run the generated code
            setTimeout(() => {
              codeEditor.runCode();
              statusEl.textContent = `Ready to assist (${this.apiProvider})`;
            }, 500);

          } catch (error) {
            console.error('AI generation error:', error);
            statusEl.textContent = `Error: ${error.message}`;
            statusEl.style.color = 'var(--error)';
            alert(`Failed to generate code:\n${error.message}\n\nPlease check your API key and try again.`);
          } finally {
            generateBtn.disabled = false;
          }
        }
      }

      // Code Panel Tab Manager
      class CodePanelTabs {
        constructor() {
          this.currentTab = 'code';
          this.setupTabs();
        }

        setupTabs() {
          document.querySelectorAll('.code-panel-tab').forEach(tab => {
            tab.addEventListener('click', () => {
              const panelName = tab.dataset.panel;
              this.switchTab(panelName);
            });
          });
        }

        switchTab(panelName) {
          this.currentTab = panelName;
          
          // Update tab styling
          document.querySelectorAll('.code-panel-tab').forEach(tab => {
            if (tab.dataset.panel === panelName) {
              tab.classList.add('active');
            } else {
              tab.classList.remove('active');
            }
          });

          // Update view visibility
          document.querySelectorAll('.code-panel-view').forEach(view => {
            if (view.id === `${panelName}-view`) {
              view.classList.add('active');
            } else {
              view.classList.remove('active');
            }
          });

          // If switching to log, scroll to bottom to show most recent messages
          if (panelName === 'log') {
            const logMessages = document.getElementById('log-messages');
            if (logMessages) {
              // Use requestAnimationFrame to ensure DOM is rendered
              requestAnimationFrame(() => {
                logMessages.scrollTop = logMessages.scrollHeight;
              });
            }
          }
        }
      }

      // Sound Testing and Diagnostics
      class SoundTester {
        constructor() {
          this.testOsc = null;
          this.isInitialized = false;
          this.testSketch = null;
        }

        async testSound() {
          logger.log('🔊 === SOUND SYSTEM DIAGNOSTIC ===', 'info');
          
          // Check if p5.sound is loaded
          logger.log('Step 1: Checking if p5.sound library is loaded...', 'info');
          if (typeof p5.Oscillator === 'undefined') {
            logger.log('❌ p5.sound library is NOT loaded!', 'error');
            logger.log('The p5.sound.js script may have failed to load from CDN', 'error');
            alert('❌ Sound library not loaded!\n\nThe p5.sound.js library failed to load. Please check your internet connection and refresh the page.');
            return false;
          }
          logger.log('✅ p5.sound library is loaded', 'success');
          
          // Check browser audio support
          logger.log('Step 2: Checking browser audio support...', 'info');
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          if (!AudioContext) {
            logger.log('❌ Web Audio API not supported in this browser', 'error');
            alert('❌ Your browser does not support the Web Audio API.\n\nPlease use a modern browser like Chrome, Firefox, or Edge.');
            return false;
          }
          logger.log('✅ Web Audio API is supported', 'success');
          
          // Get audio context state (access through p5.soundOut or create our own test)
          logger.log('Step 3: Checking audio context state...', 'info');
          
          // We need to access p5.sound functions - check if they're available globally
          let audioContextState = 'unknown';
          try {
            // Try to get audio context from p5.sound
            if (window.getAudioContext && typeof window.getAudioContext === 'function') {
              const audioContext = window.getAudioContext();
              audioContextState = audioContext.state;
            } else if (p5.soundOut && p5.soundOut.audiocontext) {
              audioContextState = p5.soundOut.audiocontext.state;
            } else {
              // Create a temporary AudioContext to test
              const testCtx = new (window.AudioContext || window.webkitAudioContext)();
              audioContextState = testCtx.state;
              testCtx.close();
            }
          } catch (error) {
            logger.log('⚠️ Could not determine audio context state: ' + error.message, 'warning');
          }
          
          logger.log(`Audio context state: ${audioContextState}`, 'info');
          
          if (audioContextState === 'suspended') {
            logger.log('Audio context is suspended (normal before user interaction)', 'warning');
            logger.log('Will attempt to resume when playing test tone...', 'info');
          } else if (audioContextState === 'running') {
            logger.log('✅ Audio context is already running', 'success');
          }
          
          // Skip master volume check - it's not critical and may not be available
          logger.log('Step 4: Skipping master volume check (will be set when sound plays)', 'info');
          
          // Create and play test tone
          logger.log('Step 5: Playing test tone (440 Hz for 1 second)...', 'info');
          logger.log('🔊 You should hear a beep now!', 'info');
          
          try {
            // Clean up any existing test oscillator
            if (this.testOsc) {
              try {
                this.testOsc.stop();
              } catch (e) {
                // Ignore errors when stopping
              }
              this.testOsc = null;
            }
            
            // Create new oscillator using p5.sound
            this.testOsc = new p5.Oscillator('sine');
            this.testOsc.freq(440); // A4 note
            this.testOsc.amp(0);    // Start at 0
            this.testOsc.start();
            
            logger.log('✅ Test oscillator created and started', 'success');
            
            // Resume audio context if needed and ramp up volume
            try {
              // Try to call userStartAudio if it's available globally
              if (window.userStartAudio && typeof window.userStartAudio === 'function') {
                await window.userStartAudio();
                logger.log('✅ Audio context resumed', 'success');
              } else if (p5.soundOut && p5.soundOut.audiocontext) {
                if (p5.soundOut.audiocontext.state === 'suspended') {
                  await p5.soundOut.audiocontext.resume();
                  logger.log('✅ Audio context resumed', 'success');
                }
              }
            } catch (e) {
              logger.log('⚠️ Audio context resume: ' + e.message, 'warning');
            }
            
            // Ramp up volume
            this.testOsc.amp(0.3, 0.1);
            logger.log('🔊 Playing 440 Hz tone at 30% volume...', 'info');
            
            // Stop after 1 second
            setTimeout(() => {
              if (this.testOsc) {
                try {
                  this.testOsc.amp(0, 0.1);
                  setTimeout(() => {
                    if (this.testOsc) {
                      this.testOsc.stop();
                      this.testOsc = null;
                    }
                  }, 150);
                } catch (e) {
                  logger.log('⚠️ Error stopping oscillator: ' + e.message, 'warning');
                }
                
                logger.log('Test tone stopped', 'info');
                logger.log('', 'info');
                logger.log('=== DIAGNOSTIC COMPLETE ===', 'info');
                logger.log('', 'info');
                logger.log('❓ Did you hear the beep?', 'info');
                logger.log('', 'info');
                logger.log('✅ YES? Great! Your sound system is working correctly!', 'success');
                logger.log('   Now try the sound examples in the dropdown menu.', 'success');
                logger.log('', 'info');
                logger.log('❌ NO? Here are troubleshooting steps:', 'warning');
                logger.log('   1. Check your computer volume is turned up', 'warning');
                logger.log('   2. Check the correct audio output device is selected', 'warning');
                logger.log('   3. Check browser is not muted (look for 🔇 icon in browser tab)', 'warning');
                logger.log('   4. Try clicking the "Test Sound" button again', 'warning');
                logger.log('   5. Open your system sound settings and test audio there', 'warning');
                logger.log('', 'info');
                logger.log('💡 TIP: If system audio works but this doesn\'t, try:', 'info');
                logger.log('   - Refresh the page and test again', 'info');
                logger.log('   - Try a different browser (Chrome recommended)', 'info');
                logger.log('   - Check browser permissions for audio', 'info');
              }
            }, 1000);
            
            this.isInitialized = true;
            return true;
            
          } catch (error) {
            logger.log('❌ Error creating test tone: ' + error.message, 'error');
            if (error.stack) {
              const stackLines = error.stack.split('\n').slice(0, 3);
              stackLines.forEach(line => {
                if (line.trim()) logger.log('   ' + line.trim(), 'error');
              });
            }
            return false;
          }
        }
        
        // Quick check without playing sound
        checkAudioReady() {
          if (typeof p5.Oscillator === 'undefined') {
            return { ready: false, reason: 'p5.sound library not loaded' };
          }
          
          try {
            if (p5.soundOut && p5.soundOut.audiocontext) {
              if (p5.soundOut.audiocontext.state === 'suspended') {
                return { ready: false, reason: 'Audio context suspended (click to activate)' };
              }
              return { ready: true, reason: 'Audio system ready' };
            }
          } catch (e) {
            // If we can't check, assume it needs activation
            return { ready: false, reason: 'Audio may need user interaction' };
          }
          
          return { ready: true, reason: 'Audio system appears ready' };
        }
      }

      // Application initialization
      let museManager;
      let eegSimulator;
      let codeEditor;
      let referencePanel;
      let aiAssistant;
      let codePanelTabs;
      let soundTester;
      let currentDataSource = null; // 'muse' or 'simulator'

      function initApp() {
        museManager = new MuseEEGManager();
        eegSimulator = new EEGSimulator();
        codeEditor = new CodeEditor();
        referencePanel = new ReferencePanel();
        aiAssistant = new AIAssistant();
        codePanelTabs = new CodePanelTabs();
        soundTester = new SoundTester();

        // Toggle reference panel
        document.getElementById('toggle-reference-btn').addEventListener('click', () => {
          const mainContainer = document.querySelector('.main-container');
          const referencePanel = document.getElementById('reference-panel');
          const btn = document.getElementById('toggle-reference-btn');
          
          if (mainContainer.classList.contains('hide-reference')) {
            mainContainer.classList.remove('hide-reference');
            btn.textContent = '📖 Reference';
          } else {
            mainContainer.classList.add('hide-reference');
            btn.textContent = '📖 Show Reference';
          }
        });

        // Event listeners
        const connectBtn = document.getElementById('connect-btn');
        
        connectBtn.addEventListener('click', async () => {
          // If already connected, disconnect
          if (currentDataSource === 'muse' && museManager.isConnected) {
            console.log('User requested disconnect');
            museManager.disconnect();
            currentDataSource = null;
            connectBtn.textContent = 'Connect Muse';
            connectBtn.disabled = false;
            document.getElementById('simulate-btn').disabled = false;
            return;
          }
          
          // Stop simulation if running
          if (currentDataSource === 'simulator') {
            console.log('Stopping simulation before Muse connection');
            stopSimulation();
          }
          
          // Attempt to connect
          connectBtn.disabled = true;
          connectBtn.textContent = 'Connecting...';
          
          try {
            await museManager.connect();
            currentDataSource = 'muse';
            connectBtn.textContent = 'Disconnect Muse';
            connectBtn.disabled = false;
            document.getElementById('simulate-btn').disabled = true;
            console.log('Connection successful, button updated');
          } catch (error) {
            console.error('Connection failed:', error);
            connectBtn.textContent = 'Connect Muse';
            connectBtn.disabled = false;
            currentDataSource = null;
            document.getElementById('simulate-btn').disabled = false;
          }
        });

        document.getElementById('simulate-btn').addEventListener('click', () => {
          if (currentDataSource === 'muse') {
            museManager.disconnect();
          }
          
          if (currentDataSource === 'simulator') {
            stopSimulation();
          } else {
            startSimulation();
          }
        });

        document.getElementById('run-btn').addEventListener('click', () => {
          codeEditor.runCode();
        });

        // Save button
        document.getElementById('save-btn').addEventListener('click', () => {
          codeEditor.saveCode();
        });

        // Load button - trigger file input
        document.getElementById('load-btn').addEventListener('click', () => {
          document.getElementById('file-input').click();
        });

        // File input change handler
        document.getElementById('file-input').addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
            codeEditor.loadCodeFromFile(file);
          }
          // Reset input so same file can be loaded again
          e.target.value = '';
        });

        // Reload button
        document.getElementById('reload-btn').addEventListener('click', () => {
          codeEditor.reloadCode();
        });

        document.getElementById('fullscreen-btn').addEventListener('click', async () => {
          const container = document.getElementById('canvas-container');
          
          try {
            if (!document.fullscreenElement) {
              // Enter fullscreen mode
              await container.requestFullscreen();
              document.getElementById('fullscreen-btn').textContent = 'Exit Fullscreen';
            } else {
              // Exit fullscreen mode
              await document.exitFullscreen();
              document.getElementById('fullscreen-btn').textContent = 'Fullscreen';
            }
          } catch (error) {
            console.error('Fullscreen error:', error);
            alert('Fullscreen mode is not supported or was blocked. Please try pressing F11 or allow fullscreen permissions.');
          }
        });

        // Test Sound button
        document.getElementById('test-sound-btn').addEventListener('click', async () => {
          // Switch to System Log tab to see diagnostic info
          codePanelTabs.switchTab('log');
          
          // Run the sound test
          await soundTester.testSound();
        });

        // Example selector dropdown
        document.getElementById('example-selector').addEventListener('change', (e) => {
          const exampleName = e.target.value;
          if (exampleName) {
            codeEditor.loadExample(exampleName);
          }
        });

        // Simulation control sliders
        const attentionSlider = document.getElementById('sim-attention');
        const meditationSlider = document.getElementById('sim-meditation');
        const attentionVal = document.getElementById('sim-attention-val');
        const meditationVal = document.getElementById('sim-meditation-val');
        
        attentionSlider.addEventListener('input', (e) => {
          const value = e.target.value;
          attentionVal.textContent = value;
          if (eegSimulator && eegSimulator.isRunning) {
            eegSimulator.setAttention(value);
          }
        });
        
        meditationSlider.addEventListener('input', (e) => {
          const value = e.target.value;
          meditationVal.textContent = value;
          if (eegSimulator && eegSimulator.isRunning) {
            eegSimulator.setMeditation(value);
          }
        });

        // Listen for fullscreen changes (e.g., when user presses ESC)
        document.addEventListener('fullscreenchange', () => {
          const btn = document.getElementById('fullscreen-btn');
          if (document.fullscreenElement) {
            btn.textContent = 'Exit Fullscreen';
          } else {
            btn.textContent = 'Fullscreen';
          }
        });

        // Check for Web Bluetooth support first
        if (!navigator.bluetooth) {
          logger.log('⚠️ Web Bluetooth is not supported in this browser', 'error');
          logger.log('Please use Chrome, Edge, or Opera to connect to Muse devices', 'warning');
          document.getElementById('connect-btn').disabled = true;
          document.getElementById('connect-btn').title = 'Web Bluetooth not supported in this browser';
          museManager.updateStatus('Bluetooth not supported', 'error');
        } else {
          logger.log('✅ Web Bluetooth is supported in this browser', 'success');
        }
        
        // Check if muse-js library loaded successfully
        logger.log('🔍 Checking muse-js library...', 'info');
        
        if (window.muse && window.muse.MuseClient) {
          logger.log('✅ muse-js library is ready!', 'success');
          document.getElementById('connect-btn').disabled = false;
          museManager.updateStatus('Ready to connect', '');
          logger.log('Click "Connect Muse" to pair with your device', 'info');
        } else {
          logger.log('❌ muse-js library failed to load!', 'error');
          logger.log('Check your internet connection and refresh the page', 'warning');
          document.getElementById('connect-btn').disabled = true;
          museManager.updateStatus('muse-js library error', 'error');
        }
        
        logger.log('🧠 BrainImation initialized successfully!', 'success');
      }

      // Simulation control functions
      function startSimulation() {
        logger.log('🎮 Starting EEG data simulation...', 'info');
        eegSimulator.start();
        currentDataSource = 'simulator';
        
        document.getElementById('simulate-btn').textContent = 'Stop Simulation';
        document.getElementById('connect-btn').disabled = true;
        document.getElementById('sim-controls').style.display = 'block';
        document.getElementById('status-text').textContent = 'Simulating EEG Data';
        document.getElementById('muse-status').className = 'status-indicator connected';
        
        // Initialize with current slider values
        eegSimulator.setAttention(document.getElementById('sim-attention').value);
        eegSimulator.setMeditation(document.getElementById('sim-meditation').value);
        
        logger.log('✅ Simulation active - Use sliders to control brain wave parameters', 'success');
      }

      function stopSimulation() {
        logger.log('🎮 Stopping EEG data simulation...', 'info');
        eegSimulator.stop();
        currentDataSource = null;
        
        document.getElementById('simulate-btn').textContent = 'Simulate Data';
        document.getElementById('connect-btn').disabled = false;
        document.getElementById('sim-controls').style.display = 'none';
        document.getElementById('status-text').textContent = 'Disconnected';
        document.getElementById('muse-status').className = 'status-indicator';
        
        // Reset eegData
        Object.keys(eegData).forEach(key => {
          if (typeof eegData[key] === 'number') {
            eegData[key] = 0;
          } else if (Array.isArray(eegData[key])) {
            eegData[key] = [0, 0, 0, 0];
          } else if (key === 'connected') {
            eegData[key] = false;
          } else if (key === 'rawHistory') {
            eegData[key] = { TP9: [], AF7: [], AF8: [], TP10: [] };
          }
        });
        
        // Update display
        document.getElementById('alpha-value').textContent = '0.0';
        document.getElementById('beta-value').textContent = '0.0';
        document.getElementById('theta-value').textContent = '0.0';
        document.getElementById('delta-value').textContent = '0.0';
        
        logger.log('✅ Simulation stopped', 'success');
      }

      // Global error handler
      window.showError = function(message) {
        codeEditor?.showError(message);
      };

      // Start the application
      window.addEventListener('load', initApp);
    </script>
  </body>
</html>
