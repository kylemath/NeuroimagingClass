<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="cache-buster" content="20250929-v1">
    <title>BrainImation: Live EEG + P5.js Creative Coding</title>
    <meta name="description" content="Interactive brain-computer interface art platform using real-time EEG data from Muse headsets with live P5.js coding environment.">
    
    <!-- P5.js and required libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/addons/p5.sound.min.js"></script>
    
    <!-- Muse-js for Bluetooth EEG - LOCAL BROWSER BUNDLE -->
    <script src="./muse-browser.js"></script>
    
    <!-- Monaco Editor for live coding -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs/loader.min.js"></script>
    
    <style>
      :root {
        --bg: #0a0a0a;
        --bg-2: #1a1a1a;
        --text: #e0e0e0;
        --muted: #888;
        --accent: #ff6b9d;
        --accent-2: #4ecdc4;
        --success: #4caf50;
        --warning: #ff9800;
        --error: #f44336;
        --neural: rgba(78, 205, 196, 0.3);
      }

      * { box-sizing: border-box; }
      
      body {
        margin: 0;
        padding: 0;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        background: var(--bg);
        color: var(--text);
        overflow: hidden;
        height: 100vh;
      }

      .main-container {
        display: grid;
        grid-template-columns: 1fr 1000px 500px;
        grid-template-rows: 60px 1fr auto;
        height: 100vh;
        gap: 2px;
        background: var(--bg-2);
        overflow: hidden;
      }
      
      .main-container.hide-reference {
        grid-template-columns: 1fr 200px;
      }

      .header {
        grid-column: 1 / -1;
        background: var(--bg-2);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 20px;
        border-bottom: 2px solid var(--accent);
      }

      .logo {
        font-size: 24px;
        font-weight: bold;
        background: linear-gradient(45deg, var(--accent), var(--accent-2));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .controls {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .btn {
        padding: 8px 16px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-family: inherit;
        font-size: 14px;
        font-weight: 600;
        transition: all 0.2s;
      }

      .btn-primary {
        background: var(--accent);
        color: white;
      }
      .btn-primary:hover { background: #e55a8a; }
      .btn-primary:disabled { 
        background: #666; 
        cursor: not-allowed; 
      }

      .btn-success {
        background: var(--success);
        color: white;
      }
      .btn-success:hover { background: #45a049; }

      .btn-secondary {
        background: var(--bg);
        color: var(--text);
        border: 1px solid var(--muted);
      }
      .btn-secondary:hover { background: var(--bg-2); }

      .status {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
      }

      .status-indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--muted);
        animation: pulse 2s infinite;
      }
      .status-indicator.connected { background: var(--success); }
      .status-indicator.error { background: var(--error); }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }

      .canvas-container {
        background: #000;
        position: relative;
        overflow: hidden;
      }

      /* Fullscreen mode styling */
      .canvas-container:fullscreen {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .canvas-container:-webkit-full-screen {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .canvas-container:-moz-full-screen {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .canvas-container:-ms-fullscreen {
        display: flex;
        align-items: center;
        justify-content: center;
        background: #000;
      }

      .code-panel {
        background: var(--bg-2);
        display: flex;
        flex-direction: column;
      }

      .code-panel-tabs {
        display: flex;
        background: var(--bg);
        border-bottom: 2px solid var(--muted);
      }

      .code-panel-tab {
        padding: 10px 20px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 600;
        color: var(--muted);
        border-bottom: 3px solid transparent;
        transition: all 0.2s;
        background: var(--bg);
      }

      .code-panel-tab:hover {
        background: var(--bg-2);
        color: var(--text);
      }

      .code-panel-tab.active {
        color: var(--accent-2);
        border-bottom-color: var(--accent);
      }

      .code-panel-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .code-panel-view {
        flex: 1;
        display: none;
        flex-direction: column;
      }

      .code-panel-view.active {
        display: flex;
      }

      .panel-header {
        background: var(--bg);
        padding: 8px 12px;
        font-size: 12px;
        font-weight: 600;
        color: var(--accent-2);
        border-bottom: 1px solid var(--muted);
      }

      .code-editor {
        flex: 1;
        position: relative;
      }

      .eeg-data {
        background: var(--bg);
        border-top: 1px solid var(--muted);
        max-height: 250px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
      }

      .data-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
        padding: 12px;
      }

      .data-item {
        background: var(--bg-2);
        padding: 8px;
        border-radius: 4px;
        text-align: center;
        font-size: 11px;
      }

      .data-label {
        color: var(--muted);
        text-transform: uppercase;
        margin-bottom: 4px;
      }

      .data-value {
        font-size: 16px;
        font-weight: bold;
        color: var(--accent-2);
      }

      .wave-viz {
        grid-column: 1 / -1;
        height: 60px;
        background: var(--bg-2);
        border-radius: 4px;
        position: relative;
        overflow: hidden;
      }

      .examples-bar {
        background: var(--bg);
        padding: 8px 12px;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 11px;
      }

      .example-selector {
        flex: 1;
        padding: 6px 10px;
        background: var(--bg-2);
        border: 1px solid var(--muted);
        border-radius: 4px;
        color: var(--text);
        font-family: inherit;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .example-selector:hover {
        border-color: var(--accent);
      }
      
      .example-selector:focus {
        outline: none;
        border-color: var(--accent);
        background: var(--bg);
      }
      
      .examples-label {
        color: var(--muted);
        white-space: nowrap;
      }


      .error-console {
        background: var(--bg);
        color: var(--error);
        padding: 8px 12px;
        font-size: 11px;
        border-top: 1px solid var(--error);
        max-height: 100px;
        overflow-y: auto;
        display: none;
      }

      /* Console Log Panel */
      .console-log-panel {
        background: var(--bg);
        padding: 8px;
        max-height: 200px;
        overflow-y: auto;
        font-family: 'Monaco', 'Courier New', monospace;
        font-size: 11px;
        display: flex;
        flex-direction: column;
        gap: 2px;
      }

      /* When in tab view, use full height */
      .code-panel-view .console-log-panel {
        max-height: none;
        height: 100%;
        border-top: none;
      }

      .console-log-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 4px 8px;
        background: var(--bg-2);
        border-radius: 4px;
        margin-bottom: 4px;
      }

      .console-log-title {
        color: var(--accent-2);
        font-weight: 600;
        font-size: 12px;
      }

      .console-log-clear {
        background: var(--bg);
        border: 1px solid var(--muted);
        color: var(--text);
        padding: 2px 8px;
        border-radius: 3px;
        cursor: pointer;
        font-size: 10px;
        transition: all 0.2s;
      }

      .console-log-clear:hover {
        background: var(--accent);
        color: white;
        border-color: var(--accent);
      }

      .console-log-messages {
        flex: 1;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 2px;
        min-height: 0; /* Important for flex scrolling */
      }

      .log-message {
        padding: 4px 8px;
        border-radius: 3px;
        background: var(--bg-2);
        border-left: 3px solid;
        word-wrap: break-word;
        animation: slideIn 0.2s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(-10px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .log-message.log-info {
        border-left-color: var(--accent-2);
        color: var(--text);
      }

      .log-message.log-success {
        border-left-color: var(--success);
        color: var(--success);
      }

      .log-message.log-warning {
        border-left-color: var(--warning);
        color: var(--warning);
      }

      .log-message.log-error {
        border-left-color: var(--error);
        color: var(--error);
        font-weight: 600;
      }

      .log-timestamp {
        opacity: 0.6;
        font-size: 9px;
        margin-right: 6px;
      }

      .reference-panel {
        background: var(--bg-2);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        grid-row: 2 / 4;
      }
      
      .main-container.hide-reference .reference-panel {
        display: none;
      }
      
      .reference-tabs {
        display: flex;
        background: var(--bg);
        border-bottom: 1px solid var(--muted);
      }
      
      .reference-tab {
        padding: 8px 12px;
        cursor: pointer;
        font-size: 11px;
        border-bottom: 2px solid transparent;
        transition: all 0.2s;
        flex: 1;
        text-align: center;
      }
      
      .reference-tab:hover {
        background: var(--bg-2);
      }
      
      .reference-tab.active {
        border-bottom-color: var(--accent);
        color: var(--accent);
      }
      
      .reference-content {
        flex: 1;
        overflow-y: auto;
        padding: 12px;
        font-size: 11px;
      }
      
      .function-group {
        margin-bottom: 16px;
      }
      
      .function-group-title {
        color: var(--accent-2);
        font-weight: 600;
        margin-bottom: 6px;
        font-size: 12px;
      }
      
      .function-item {
        padding: 4px 8px;
        margin: 2px 0;
        background: var(--bg);
        border-radius: 3px;
        cursor: pointer;
        transition: all 0.3s ease;
        border: 1px solid transparent;
        overflow: hidden;
      }
      
      .function-item:hover {
        background: var(--accent);
        color: white;
        border-color: var(--accent);
      }
      
      .function-name {
        font-family: 'Courier New', monospace;
        font-weight: 600;
        display: block;
        padding: 2px 0;
      }
      
      .function-tooltip {
        max-height: 0;
        overflow: hidden;
        transition: max-height 0.3s ease, padding 0.3s ease, margin 0.3s ease;
        padding: 0;
        margin: 0;
      }
      
      .function-item:hover .function-tooltip {
        max-height: 300px;
        padding-top: 8px;
        margin-top: 4px;
        border-top: 1px solid rgba(255,255,255,0.3);
      }
      
      .tooltip-signature {
        font-family: 'Courier New', monospace;
        color: var(--accent-2);
        margin-bottom: 4px;
        font-size: 10px;
        font-weight: 600;
        word-wrap: break-word;
      }
      
      .function-item:hover .tooltip-signature {
        color: white;
        opacity: 0.9;
      }
      
      .tooltip-description {
        color: var(--text);
        line-height: 1.5;
        font-size: 10px;
        word-wrap: break-word;
      }
      
      .function-item:hover .tooltip-description {
        color: white;
        opacity: 0.85;
      }
      
      .ai-assistant {
        background: var(--bg);
        padding: 12px;
        border-top: 2px solid var(--accent);
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      
      .ai-input {
        background: var(--bg-2);
        border: 1px solid var(--muted);
        color: var(--text);
        padding: 8px;
        border-radius: 4px;
        font-family: inherit;
        font-size: 11px;
        resize: vertical;
        min-height: 60px;
      }
      
      .ai-input:focus {
        outline: none;
        border-color: var(--accent);
      }
      
      .ai-buttons {
        display: flex;
        gap: 6px;
      }
      
      .ai-status {
        font-size: 10px;
        color: var(--muted);
        font-style: italic;
      }
      
      .toggle-reference {
        background: var(--bg);
        color: var(--accent-2);
        border: 1px solid var(--accent-2);
        padding: 8px 12px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        transition: all 0.2s;
      }
      
      .toggle-reference:hover {
        background: var(--accent-2);
        color: var(--bg);
      }

      @media (max-width: 1200px) {
        .main-container {
          grid-template-columns: 1fr 400px;
        }
        .reference-panel {
          display: none;
        }
      }

      @media (max-width: 768px) {
        .main-container {
          grid-template-columns: 1fr;
          grid-template-rows: 60px 300px 1fr auto;
          overflow-y: auto;
        }
        .code-panel {
          grid-row: 3;
          min-height: 200px;
        }
        .canvas-container {
          grid-row: 2;
        }
        .eeg-data {
          max-height: 200px;
        }
        .reference-panel {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div class="main-container">
      <!-- Header -->
      <div class="header">
        <div class="logo">🧠 BrainImation</div>
        <div class="controls">
          <div style="display:flex;align-items:center;gap:8px;margin-right:16px;font-size:12px;">
            <a href="./index.html" style="color: var(--accent-2); text-decoration: none;">Course Home</a>
            <span style="color: var(--muted);">|</span>
            <a href="./lecture3.html" style="color: var(--accent-2); text-decoration: none;">← Lecture 3</a>
          </div>
          <div class="status">
            <div class="status-indicator" id="muse-status"></div>
            <span id="status-text">Disconnected</span>
          </div>
          <button class="btn btn-primary" id="connect-btn">Connect Muse</button>
          <button class="btn btn-secondary" id="simulate-btn">Simulate Data</button>
          <button class="btn btn-success" id="run-btn">Run Code</button>
          <button class="btn btn-secondary" id="save-btn">💾 Save</button>
          <button class="btn btn-secondary" id="load-btn">📁 Load</button>
          <button class="btn btn-secondary" id="reload-btn" disabled>🔄 Reload</button>
          <button class="btn btn-secondary" id="fullscreen-btn">Fullscreen</button>
          <button class="toggle-reference" id="toggle-reference-btn">📖 Reference</button>
          <input type="file" id="file-input" accept=".js" style="display: none;">
        </div>
      </div>

      <!-- Canvas -->
      <div class="canvas-container" id="canvas-container"></div>

      <!-- Code Editor Panel -->
      <div class="code-panel">
        <div class="code-panel-tabs">
          <div class="code-panel-tab active" data-panel="code">💻 Code Editor</div>
          <div class="code-panel-tab" data-panel="log">📋 System Log</div>
        </div>
        <div class="code-panel-content">
          <!-- Code Editor View -->
          <div class="code-panel-view active" id="code-view">
            <div class="examples-bar">
              <label for="example-selector" class="examples-label">Example Animations:</label>
              <select id="example-selector" class="example-selector">
                <option value="">-- Select an Example --</option>
                <optgroup label="Getting Started">
                  <option value="basic">Basic Animation</option>
                  <option value="basicShapes">Basic Shapes</option>
                  <option value="functionExample">Function Example</option>
                </optgroup>
            <optgroup label="Brain Wave Visualizations">
              <option value="alpha">Alpha Waves</option>
              <option value="waves">Wave Visualization</option>
              <option value="BasicFrequencyBands">Basic Frequency Bands</option>
              <option value="bandOrbitz">Band Orbitz</option>
              <option value="piWedges">Pi Wedges</option>
              <option value="spectra">Spectra</option>
            </optgroup>
            <optgroup label="Attention & Meditation">
              <option value="attention">Attention Meter</option>
              <option value="mandala">Neural Mandala</option>
            </optgroup>
            <optgroup label="Particle Systems">
              <option value="particles">Brain Particles</option>
              <option value="ColourBalls">Colour Balls</option>
              <option value="MultipleBalls">Multiple Balls</option>
            </optgroup>
            <optgroup label="3D & Advanced">
              <option value="3dTorus">3D Torus</option>
              <option value="AlphaSnake">Alpha Snake</option>
              <option value="SplineBounce">Spline Bounce</option>
            </optgroup>
            <optgroup label="Drawing & Interaction">
              <option value="BrainDraw">Brain Draw</option>
              <option value="bouncingLine">Bouncing Line</option>
              <option value="ghostLines">Ghost Lines</option>
            </optgroup>
            <optgroup label="Raw EEG Data">
              <option value="eegtrace">EEG Trace</option>
              <option value="multichannel">Multi-Channel EEG</option>
              <option value="epochs">Epoch View</option>
            </optgroup>
            <optgroup label="Noise & Generative">
              <option value="perlinNoise">Perlin Noise</option>
              <option value="organicHeatmap">Organic Heatmap</option>
              <option value="noiseDetail">Noise With Detail</option>
              <option value="discreteColors">Discrete Colors</option>
              <option value="smoothColors">Smooth Colors</option>
              <option value="animatingNoise">Animating Noise</option>
            </optgroup>
            <optgroup label="Animation & Motion">
              <option value="bouncingCircles">Bouncing Circles</option>
              <option value="waveAnimation">Wave Animation</option>
              <option value="colorfulGrid">Animated Grid</option>
              <option value="webcamInput">Webcam Input</option>
            </optgroup>
              </select>
            </div>
            <div class="code-editor" id="code-editor"></div>
            <div class="error-console" id="error-console"></div>
          </div>

          <!-- System Log View -->
          <div class="code-panel-view" id="log-view">
            <div class="console-log-panel" id="console-log-panel" style="max-height: none; height: 100%;">
              <div class="console-log-header">
                <div class="console-log-title">📋 System Log</div>
                <button class="console-log-clear" id="clear-log-btn">Clear</button>
              </div>
              <div class="console-log-messages" id="log-messages">
                <div class="log-message log-info">
                  <span class="log-timestamp">[Ready]</span>
                  Console initialized. Connection messages will appear here.
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Reference Panel -->
      <div class="reference-panel" id="reference-panel">
        <div class="reference-tabs">
          <div class="reference-tab active" data-tab="p5js">P5.js</div>
          <div class="reference-tab" data-tab="eeg">EEG Data</div>
          <div class="reference-tab" data-tab="ai">AI Helper</div>
        </div>
        
        <div class="reference-content" id="reference-content">
          <!-- Content will be dynamically loaded -->
        </div>
        
        <!-- AI Assistant at bottom -->
        <div class="ai-assistant" id="ai-assistant" style="display: none;">
          <div style="font-size: 12px; font-weight: 600; color: var(--accent);">🤖 AI Code Assistant</div>
          <textarea class="ai-input" id="ai-prompt" placeholder="Describe what you want to change or add...&#10;e.g., 'Add a particle system that responds to alpha waves'&#10;'Change the colors to be more vibrant'&#10;'Make the animation slower'"></textarea>
          <div class="ai-buttons">
            <button class="btn btn-primary" id="ai-generate-btn" style="flex: 1;">Generate Code</button>
            <button class="btn btn-secondary" id="ai-config-btn">⚙️</button>
          </div>
          <div class="ai-status" id="ai-status">Configure API key to use AI features</div>
        </div>
      </div>

      <!-- EEG Data Display -->
      <div class="eeg-data">
        <div class="panel-header">Real-time Brain Data</div>
        <div class="data-grid">
          <div class="data-item">
            <div class="data-label">Alpha</div>
            <div class="data-value" id="alpha-value">0.0</div>
          </div>
          <div class="data-item">
            <div class="data-label">Beta</div>
            <div class="data-value" id="beta-value">0.0</div>
          </div>
          <div class="data-item">
            <div class="data-label">Theta</div>
            <div class="data-value" id="theta-value">0.0</div>
          </div>
          <div class="data-item">
            <div class="data-label">Delta</div>
            <div class="data-value" id="delta-value">0.0</div>
          </div>
          <div class="wave-viz" id="wave-viz"></div>
        </div>
        
        <!-- Simulation Controls -->
        <div id="sim-controls" style="display: none; padding: 12px; border-top: 1px solid var(--muted); background: var(--bg-2);">
          <div style="font-size: 11px; color: var(--accent-2); margin-bottom: 8px; font-weight: 600;">🎛️ SIMULATION CONTROLS</div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
            <div>
              <label style="color: var(--muted);">Attention:</label>
              <input type="range" id="sim-attention" min="0" max="1" step="0.1" value="0.5" 
                     style="width: 100%; margin-top: 2px;">
              <span id="sim-attention-val" style="color: var(--accent-2);">0.5</span>
            </div>
            <div>
              <label style="color: var(--muted);">Meditation:</label>
              <input type="range" id="sim-meditation" min="0" max="1" step="0.1" value="0.3" 
                     style="width: 100%; margin-top: 2px;">
              <span id="sim-meditation-val" style="color: var(--accent-2);">0.3</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ============================================
      // VISIBLE CONSOLE LOGGING SYSTEM
      // ============================================
      class ConsoleLogger {
        constructor() {
          this.logContainer = null;
          this.maxMessages = 100;
          this.originalConsole = {
            log: console.log.bind(console),
            error: console.error.bind(console),
            warn: console.warn.bind(console),
            info: console.info.bind(console)
          };
          this.init();
        }

        init() {
          // Wait for DOM to be ready
          if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.setupLogging());
          } else {
            this.setupLogging();
          }
        }

        setupLogging() {
          this.logContainer = document.getElementById('log-messages');
          
          // Setup clear button
          const clearBtn = document.getElementById('clear-log-btn');
          if (clearBtn) {
            clearBtn.addEventListener('click', () => this.clear());
          }

          // Override console methods
          console.log = (...args) => {
            this.originalConsole.log(...args);
            this.addMessage(this.formatArgs(args), 'info');
          };

          console.error = (...args) => {
            this.originalConsole.error(...args);
            this.addMessage(this.formatArgs(args), 'error');
          };

          console.warn = (...args) => {
            this.originalConsole.warn(...args);
            this.addMessage(this.formatArgs(args), 'warning');
          };

          console.info = (...args) => {
            this.originalConsole.info(...args);
            this.addMessage(this.formatArgs(args), 'info');
          };

          this.log('✅ Console logging system initialized', 'success');
        }

        formatArgs(args) {
          return args.map(arg => {
            if (typeof arg === 'object') {
              try {
                return JSON.stringify(arg, null, 2);
              } catch (e) {
                return String(arg);
              }
            }
            return String(arg);
          }).join(' ');
        }

        addMessage(message, type = 'info') {
          if (!this.logContainer) return;

          const logEntry = document.createElement('div');
          logEntry.className = `log-message log-${type}`;
          
          const timestamp = new Date().toLocaleTimeString('en-US', { 
            hour12: false, 
            hour: '2-digit', 
            minute: '2-digit', 
            second: '2-digit' 
          });
          
          logEntry.innerHTML = `
            <span class="log-timestamp">[${timestamp}]</span>
            ${this.escapeHtml(message)}
          `;

          this.logContainer.appendChild(logEntry);

          // Keep only last N messages
          while (this.logContainer.children.length > this.maxMessages) {
            this.logContainer.removeChild(this.logContainer.firstChild);
          }

          // Auto-scroll to bottom
          this.logContainer.scrollTop = this.logContainer.scrollHeight;

          // Auto-switch to log tab on errors or important messages
          if ((type === 'error' || type === 'warning') && window.codePanelTabs) {
            // Small delay to ensure tab manager is initialized
            setTimeout(() => {
              if (codePanelTabs.currentTab !== 'log') {
                codePanelTabs.switchTab('log');
              }
            }, 100);
          }
        }

        log(message, type = 'info') {
          this.addMessage(message, type);
        }

        escapeHtml(text) {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        }

        clear() {
          if (this.logContainer) {
            this.logContainer.innerHTML = '';
            this.addMessage('Console cleared', 'info');
          }
        }
      }

      // Initialize the logger immediately
      const logger = new ConsoleLogger();

      // ============================================
      // BRAINIMATION - MAIN APPLICATION
      // ============================================
      // Note: Console logging is now handled by the ConsoleLogger class above
      // All console.log, console.error, console.warn messages will appear in the System Log panel
      
      // Global variables for EEG data access in p5 sketches
      let eegData = {
        // Frequency bands (existing)
        alpha: 0,
        beta: 0,
        theta: 0,
        delta: 0,
        gamma: 0,
        
        // Current samples (existing - keep for compatibility)
        raw: [0, 0, 0, 0], // TP9, AF7, AF8, TP10 current values
        
        // Enhanced raw data access (NEW)
        rawHistory: {
          TP9: [],    // Array of recent samples
          AF7: [],    // Array of recent samples  
          AF8: [],    // Array of recent samples
          TP10: []    // Array of recent samples
        },
        
        // Configuration
        historyLength: 1000,  // ~4 seconds at 256Hz
        sampleRate: 256,      // Samples per second
        
        // Derived metrics (existing)
        attention: 0,
        meditation: 0,
        connected: false,
        
        // Helper functions for accessing raw data in animations
        getRawChannel: function(channel, numSamples = 100) {
          const channelData = this.rawHistory[channel] || [];
          return channelData.slice(-numSamples);
        },
        
        getAllChannels: function(numSamples = 100) {
          return {
            TP9: this.getRawChannel('TP9', numSamples),
            AF7: this.getRawChannel('AF7', numSamples),
            AF8: this.getRawChannel('AF8', numSamples),
            TP10: this.getRawChannel('TP10', numSamples)
          };
        },
        
        getChannelNames: function() {
          return ['TP9', 'AF7', 'AF8', 'TP10'];
        },
        
        // Get the most recent N samples across all channels
        getRecentEpoch: function(numSamples = 100) {
          const channels = this.getAllChannels(numSamples);
          const epoch = [];
          
          // Transpose data so each time point has all 4 channels
          for (let i = 0; i < numSamples; i++) {
            epoch.push([
              channels.TP9[i] || 0,
              channels.AF7[i] || 0,
              channels.AF8[i] || 0,
              channels.TP10[i] || 0
            ]);
          }
          return epoch;
        }
      };

      // EEG Data Simulator for demonstration purposes
      class EEGSimulator {
        constructor() {
          this.isRunning = false;
          this.startTime = Date.now();
          this.updateInterval = null;
          this.baseAttention = 0.5;
          this.baseMeditation = 0.3;
          this.noiseLevel = 0.1;
        }

        start() {
          this.isRunning = true;
          this.startTime = Date.now();
          
          // Update data every 50ms (20 Hz)
          this.updateInterval = setInterval(() => {
            this.generateData();
          }, 50);
        }

        stop() {
          this.isRunning = false;
          if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
          }
        }

        setAttention(value) {
          this.baseAttention = parseFloat(value);
        }

        setMeditation(value) {
          this.baseMeditation = parseFloat(value);
        }

        generateData() {
          const time = (Date.now() - this.startTime) / 1000; // seconds
          
          // Generate realistic brain wave patterns with some natural variation
          const noise = () => (Math.random() - 0.5) * this.noiseLevel;
          
          // Alpha waves (8-12 Hz) - stronger during meditation/relaxed attention
          const alphaBase = this.baseMeditation * 0.8 + 0.1;
          eegData.alpha = Math.max(0, Math.min(1, 
            alphaBase + Math.sin(time * 10) * 0.1 + noise()
          ));
          
          // Beta waves (13-30 Hz) - stronger during active attention/concentration
          const betaBase = this.baseAttention * 0.7 + 0.2;
          eegData.beta = Math.max(0, Math.min(1, 
            betaBase + Math.sin(time * 20) * 0.15 + noise()
          ));
          
          // Theta waves (4-8 Hz) - stronger during deep meditation/creativity
          const thetaBase = this.baseMeditation * 0.6 + 0.1;
          eegData.theta = Math.max(0, Math.min(1, 
            thetaBase + Math.sin(time * 6) * 0.12 + noise()
          ));
          
          // Delta waves (0.5-4 Hz) - low during awake states
          eegData.delta = Math.max(0, Math.min(1, 
            0.1 + Math.sin(time * 2) * 0.05 + noise()
          ));
          
          // Gamma waves (30+ Hz) - bursts during high-level cognition
          eegData.gamma = Math.max(0, Math.min(1, 
            0.2 + Math.sin(time * 40) * this.baseAttention * 0.3 + noise()
          ));
          
          // Generate realistic raw EEG samples for each channel
          const channels = ['TP9', 'AF7', 'AF8', 'TP10'];
          for (let i = 0; i < 4; i++) {
            const channel = channels[i];
            
            // Create realistic EEG signal combining multiple frequency components
            let sample = 0;
            
            // Alpha component (8-12 Hz)
            sample += Math.sin(time * 2 * Math.PI * (9 + i * 0.5)) * eegData.alpha * 30;
            
            // Beta component (15-25 Hz)  
            sample += Math.sin(time * 2 * Math.PI * (18 + i * 1.5)) * eegData.beta * 20;
            
            // Theta component (4-8 Hz)
            sample += Math.sin(time * 2 * Math.PI * (6 + i * 0.3)) * eegData.theta * 25;
            
            // Delta component (1-4 Hz)
            sample += Math.sin(time * 2 * Math.PI * (2 + i * 0.2)) * eegData.delta * 40;
            
            // Gamma component (30-40 Hz)
            sample += Math.sin(time * 2 * Math.PI * (35 + i * 2)) * eegData.gamma * 10;
            
            // Add some 1/f noise and artifacts
            sample += noise() * 15; // High-frequency noise
            sample += Math.sin(time * 2 * Math.PI * 0.1) * 5; // Slow drift
            
            // Occasional "blink" artifacts (more prominent in frontal channels)
            if (i >= 1 && i <= 2 && Math.random() < 0.001) { // AF7, AF8
              sample += (Math.random() - 0.5) * 200;
            }
            
            // Store current sample for compatibility
            eegData.raw[i] = sample;
            
            // Add to history buffer
            if (!eegData.rawHistory[channel]) {
              eegData.rawHistory[channel] = [];
            }
            eegData.rawHistory[channel].push(sample);
            
            // Maintain buffer size
            if (eegData.rawHistory[channel].length > eegData.historyLength) {
              eegData.rawHistory[channel] = eegData.rawHistory[channel].slice(-eegData.historyLength);
            }
          }
          
          // Calculate derived metrics
          eegData.attention = Math.max(0, Math.min(1, 
            this.baseAttention + Math.sin(time * 0.5) * 0.1 + noise() * 0.05
          ));
          
          eegData.meditation = Math.max(0, Math.min(1, 
            this.baseMeditation + Math.cos(time * 0.3) * 0.1 + noise() * 0.05
          ));
          
          eegData.connected = true;
          this.updateDataDisplay();
        }

        updateDataDisplay() {
          document.getElementById('alpha-value').textContent = eegData.alpha.toFixed(2);
          document.getElementById('beta-value').textContent = eegData.beta.toFixed(2);
          document.getElementById('theta-value').textContent = eegData.theta.toFixed(2);
          document.getElementById('delta-value').textContent = eegData.delta.toFixed(2);
        }
      }

      // Muse connection and data processing
      class MuseEEGManager {
        constructor() {
          this.muse = null;
          this.isConnected = false;
          this.dataBuffer = [];
          this.samplingRate = 256;
          this.bufferSize = 256; // 1 second of data
          this.subscriptions = [];
        }

        async connect() {
          try {
            logger.log('🔌 === ATTEMPTING TO CONNECT TO MUSE ===', 'info');
            
            // Step 1: Check Web Bluetooth support
            logger.log('Step 1: Checking Web Bluetooth support...', 'info');
            if (!navigator.bluetooth) {
              throw new Error('Web Bluetooth is not supported in this browser. Please use Chrome, Edge, or Opera.');
            }
            logger.log('✅ Web Bluetooth is supported', 'success');
            
            // Step 2: Verify the library is loaded
            logger.log('Step 2: Checking if muse-js library is loaded...', 'info');
            if (!window.muse) {
              throw new Error('muse-js library not loaded! The script may have failed to load from CDN. Check your internet connection.');
            }
            
            if (!window.muse.MuseClient) {
              throw new Error('MuseClient not found in muse-js library! The library may be corrupted or outdated.');
            }
            
            logger.log('✅ muse-js library is loaded correctly', 'success');
            
            // Step 3: Create MuseClient instance
            logger.log('Step 3: Creating MuseClient instance...', 'info');
            this.muse = new window.muse.MuseClient();
            logger.log('✅ MuseClient created successfully', 'success');
            
            // Enable PPG if available (for better compatibility)
            this.muse.enablePpg = true;
            
            // Step 4: Request device pairing
            logger.log('Step 4: Opening Bluetooth device selector...', 'info');
            logger.log('👉 Please select your Muse device from the popup', 'info');
            
            await this.muse.connect();
            logger.log('✅ Device paired successfully', 'success');
            
            // Step 5: Set up data subscriptions
            logger.log('Step 5: Setting up data subscriptions...', 'info');
            
            // EEG data subscription
            const eegSubscription = this.muse.eegReadings.subscribe(reading => {
              this.processEEGReading(reading);
            });
            this.subscriptions.push(eegSubscription);
            logger.log('✅ EEG data subscription active', 'success');

            // Accelerometer subscription (optional)
            const accelSubscription = this.muse.accelerometerData.subscribe(accel => {
              // Movement detection could be added here
            });
            this.subscriptions.push(accelSubscription);

            // Telemetry subscription (battery, temperature, etc.)
            const telemetrySubscription = this.muse.telemetryData.subscribe(telemetry => {
              if (telemetry.batteryLevel !== undefined) {
                logger.log(`🔋 Battery Level: ${telemetry.batteryLevel.toFixed(1)}%`, 'success');
              }
            });
            this.subscriptions.push(telemetrySubscription);

            // Connection status subscription
            const statusSubscription = this.muse.connectionStatus.subscribe(status => {
              if (!status) {
                logger.log('⚠️ Connection lost! Please check your device.', 'error');
                this.isConnected = false;
                eegData.connected = false;
                this.updateStatus('Connection lost', 'error');
              }
            });
            this.subscriptions.push(statusSubscription);
            
            logger.log('✅ All subscriptions configured', 'success');

            // Step 6: Start the data stream
            logger.log('Step 6: Starting EEG data stream...', 'info');
            await this.muse.start();
            
            this.isConnected = true;
            eegData.connected = true;
            this.updateStatus('Connected to Muse', 'connected');

            logger.log('🎉 SUCCESS! Muse is connected and streaming data', 'success');
            logger.log('You should now see brain wave data updating above', 'success');
            
          } catch (error) {
            logger.log('❌ Connection failed: ' + error.message, 'error');
            this.isConnected = false;
            eegData.connected = false;
            
            // Provide helpful error messages based on error type
            let errorMsg = 'Connection failed';
            let helpText = '';
            
            if (error.name === 'NotFoundError' || error.message.includes('cancelled')) {
              errorMsg = 'No device selected';
              helpText = '💡 Tip: Make sure to select a Muse device from the Bluetooth pairing dialog.';
            } else if (error.message.includes('Bluetooth') || error.message.includes('GATT')) {
              errorMsg = 'Bluetooth connection failed';
              helpText = '💡 Troubleshooting steps:\n' +
                        '1. Make sure your Muse device is charged and turned on\n' +
                        '2. Ensure Bluetooth is enabled on your computer\n' +
                        '3. Try turning the Muse device off and on again\n' +
                        '4. Move closer to the device (within 10 feet)';
            } else if (error.message.includes('not supported')) {
              errorMsg = 'Browser not compatible';
              helpText = '💡 Please use Chrome, Edge, or Opera browser to connect to Muse devices.';
            } else if (error.message.includes('library')) {
              errorMsg = 'Library loading error';
              helpText = '💡 The muse-js library failed to load. Check your internet connection and refresh the page.';
            } else {
              errorMsg = `Connection error: ${error.message}`;
              helpText = '💡 Try refreshing the page and attempting to connect again.';
            }
            
            this.updateStatus(errorMsg, 'error');
            logger.log(helpText, 'warning');
            
            throw error;
          }
        }

        processEEGReading(reading) {
          // Map numeric electrode indices to channel names
          // Muse sends: 0 = TP9, 1 = AF7, 2 = AF8, 3 = TP10
          const electrodeMap = ['TP9', 'AF7', 'AF8', 'TP10'];
          const electrodeName = typeof reading.electrode === 'number' 
            ? electrodeMap[reading.electrode] 
            : reading.electrode;
          
          // Log first few readings to confirm data flow
          if (this.dataBuffer.length < 5) {
            logger.log(`📊 EEG data received from ${electrodeName}: ${reading.samples.length} samples, first value: ${reading.samples[0]?.toFixed(2)} µV`, 'success');
          }
          
          // Log when all channels have sent data
          if (this.dataBuffer.length === 4) {
            logger.log('✅ All 4 EEG channels are transmitting data successfully!', 'success');
          }
          
          // Add to buffer for frequency analysis (use mapped name)
          this.dataBuffer.push({
            electrode: electrodeName,
            samples: reading.samples,
            timestamp: Date.now()
          });

          // Keep buffer size manageable
          if (this.dataBuffer.length > this.bufferSize * 4) { // 4 electrodes
            this.dataBuffer = this.dataBuffer.slice(-this.bufferSize * 4);
          }

          // Update raw values for immediate access (compatibility)
          const electrodeIndex = typeof reading.electrode === 'number' 
            ? reading.electrode 
            : electrodeMap.indexOf(reading.electrode);
          
          if (electrodeIndex !== -1 && reading.samples.length > 0) {
            eegData.raw[electrodeIndex] = reading.samples[reading.samples.length - 1];
          }

          // NEW: Add ALL samples to raw history for time-series access
          if (!eegData.rawHistory[electrodeName]) {
            eegData.rawHistory[electrodeName] = [];
          }
          
          // Add all samples from this reading (usually 12 samples per packet)
          eegData.rawHistory[electrodeName].push(...reading.samples);
          
          // Maintain buffer size (keep last N samples)
          if (eegData.rawHistory[electrodeName].length > eegData.historyLength) {
            eegData.rawHistory[electrodeName] = eegData.rawHistory[electrodeName].slice(-eegData.historyLength);
          }

          // Calculate frequency bands every few samples
          if (this.dataBuffer.length % 32 === 0) {
            this.calculateFrequencyBands();
          }
          
          // Update status to show data is flowing (every 100 packets)
          if (this.dataBuffer.length % 100 === 0) {
            const dataRate = (this.dataBuffer.length / 4).toFixed(0); // packets per electrode
            this.updateStatus(`Connected (${dataRate} packets/ch)`, 'connected');
          }
        }

        calculateFrequencyBands() {
          // Simple frequency band calculation
          // In a real implementation, you'd use FFT
          const recentData = this.dataBuffer.slice(-64); // Last 64 samples per electrode
          
          if (recentData.length < 64) return;

          // Group by electrode
          const electrodeData = { TP9: [], AF7: [], AF8: [], TP10: [] };
          recentData.forEach(reading => {
            if (electrodeData[reading.electrode]) {
              electrodeData[reading.electrode].push(...reading.samples);
            }
          });

          // Calculate power in different bands (simplified)
          // Average across all electrodes for more stable estimates
          let totalVariance = 0;
          let totalMean = 0;
          let electrodeCount = 0;
          
          Object.keys(electrodeData).forEach(electrode => {
            const samples = electrodeData[electrode].slice(-64);
            if (samples.length >= 64) {
              // Simplified band power calculation
              const variance = this.calculateVariance(samples);
              const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
              
              totalVariance += variance;
              totalMean += Math.abs(mean);
              electrodeCount++;
            }
          });
          
          if (electrodeCount > 0) {
            // Average variance and mean across electrodes
            const avgVariance = totalVariance / electrodeCount;
            const avgMean = totalMean / electrodeCount;
            
            // Update frequency bands (this is a simplified approach)
            // Scale factors adjusted based on typical EEG variance values
            eegData.alpha = Math.max(0, Math.min(1, avgVariance * 0.001));
            eegData.beta = Math.max(0, Math.min(1, avgVariance * 0.0008));
            eegData.theta = Math.max(0, Math.min(1, avgVariance * 0.0012));
            eegData.delta = Math.max(0, Math.min(1, avgVariance * 0.0015));
            eegData.gamma = Math.max(0, Math.min(1, avgVariance * 0.0005));
            
            // Calculate attention and meditation (simplified)
            eegData.attention = Math.max(0, Math.min(1, (eegData.beta + eegData.gamma) / 2));
            eegData.meditation = Math.max(0, Math.min(1, (eegData.alpha + eegData.theta) / 2));
            
            // Debug log every 10 calculations
            if (this.dataBuffer.length % 320 === 0) {
              console.log('📊 Frequency bands updated:', {
                alpha: eegData.alpha.toFixed(3),
                beta: eegData.beta.toFixed(3),
                theta: eegData.theta.toFixed(3),
                variance: avgVariance.toFixed(2)
              });
            }
          }

          eegData.connected = this.isConnected;
          this.updateDataDisplay();
        }

        calculateVariance(samples) {
          const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
          const variance = samples.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / samples.length;
          return Math.sqrt(variance);
        }

        updateStatus(text, status) {
          document.getElementById('status-text').textContent = text;
          const indicator = document.getElementById('muse-status');
          indicator.className = `status-indicator ${status}`;
        }

        updateDataDisplay() {
          document.getElementById('alpha-value').textContent = eegData.alpha.toFixed(2);
          document.getElementById('beta-value').textContent = eegData.beta.toFixed(2);
          document.getElementById('theta-value').textContent = eegData.theta.toFixed(2);
          document.getElementById('delta-value').textContent = eegData.delta.toFixed(2);
        }

        disconnect() {
          logger.log('🔌 Disconnecting from Muse...', 'info');
          
          // Unsubscribe from all subscriptions
          if (this.subscriptions && this.subscriptions.length > 0) {
            logger.log(`Unsubscribing from ${this.subscriptions.length} data subscriptions`, 'info');
            this.subscriptions.forEach(sub => {
              try {
                sub.unsubscribe();
              } catch (e) {
                logger.log('Warning during unsubscribe: ' + e.message, 'warning');
              }
            });
            this.subscriptions = [];
            logger.log('✅ All subscriptions closed', 'success');
          }
          
          // Disconnect the device
          if (this.muse) {
            try {
              this.muse.disconnect();
              logger.log('✅ Muse device disconnected successfully', 'success');
            } catch (e) {
              logger.log('Warning during disconnect: ' + e.message, 'warning');
            }
            this.muse = null;
          }
          
          this.isConnected = false;
          eegData.connected = false;
          this.updateStatus('Disconnected', '');
          logger.log('Ready to connect to a new device', 'info');
        }
      }

      // P5.js Function Reference Database
      const p5Reference = {
        'Drawing': {
          'ellipse': {
            signature: 'ellipse(x, y, width, [height])',
            description: 'Draws an ellipse (oval) to the screen. By default, the first two parameters set the location, and the third and fourth parameters set the shape\'s width and height.'
          },
          'circle': {
            signature: 'circle(x, y, diameter)',
            description: 'Draws a circle to the screen. A circle is a simple closed shape, by default drawn from the center point.'
          },
          'rect': {
            signature: 'rect(x, y, width, height, [tl], [tr], [br], [bl])',
            description: 'Draws a rectangle to the screen. Optional parameters for rounded corners.'
          },
          'square': {
            signature: 'square(x, y, size, [tl], [tr], [br], [bl])',
            description: 'Draws a square to the screen. A square is a four-sided shape with equal sides.'
          },
          'triangle': {
            signature: 'triangle(x1, y1, x2, y2, x3, y3)',
            description: 'Draws a triangle to the screen. A triangle is a plane created by connecting three points.'
          },
          'quad': {
            signature: 'quad(x1, y1, x2, y2, x3, y3, x4, y4)',
            description: 'Draws a quadrilateral (four-sided polygon) to the screen.'
          },
          'line': {
            signature: 'line(x1, y1, x2, y2)',
            description: 'Draws a line (a direct path between two points) to the screen.'
          },
          'point': {
            signature: 'point(x, y)',
            description: 'Draws a point, a coordinate in space at the dimension of one pixel.'
          },
          'arc': {
            signature: 'arc(x, y, w, h, start, stop, [mode])',
            description: 'Draws an arc to the screen. Arcs are drawn along the outer edge of an ellipse.'
          }
        },
        'Color': {
          'background': {
            signature: 'background(color) or background(r, g, b, [a])',
            description: 'Sets the color used for the background. Default is light gray.'
          },
          'fill': {
            signature: 'fill(color) or fill(r, g, b, [a])',
            description: 'Sets the color used to fill shapes.'
          },
          'stroke': {
            signature: 'stroke(color) or stroke(r, g, b, [a])',
            description: 'Sets the color used to draw lines and borders around shapes.'
          },
          'noFill': {
            signature: 'noFill()',
            description: 'Disables filling geometry. If both noStroke() and noFill() are called, nothing will be drawn.'
          },
          'noStroke': {
            signature: 'noStroke()',
            description: 'Disables drawing the stroke (outline).'
          },
          'color': {
            signature: 'color(gray, [alpha]) or color(r, g, b, [a])',
            description: 'Creates a color object. Can be used with fill(), stroke(), and background().'
          },
          'lerpColor': {
            signature: 'lerpColor(c1, c2, amt)',
            description: 'Blends two colors to find a third color between them. The amt parameter is between 0.0 and 1.0.'
          },
          'colorMode': {
            signature: 'colorMode(mode, [max1], [max2], [max3], [maxA])',
            description: 'Changes the way p5.js interprets color data. Modes: RGB or HSB.'
          }
        },
        'Transform': {
          'translate': {
            signature: 'translate(x, y)',
            description: 'Specifies an amount to displace objects within the display window.'
          },
          'rotate': {
            signature: 'rotate(angle)',
            description: 'Rotates shapes around the origin (0,0). Angle should be in radians unless angleMode(DEGREES) is used.'
          },
          'scale': {
            signature: 'scale(s) or scale(x, y)',
            description: 'Increases or decreases the size of shapes by expanding and contracting vertices.'
          },
          'push': {
            signature: 'push()',
            description: 'Saves the current drawing style settings and transformations.'
          },
          'pop': {
            signature: 'pop()',
            description: 'Restores the previous drawing style settings and transformations.'
          }
        },
        'Math': {
          'map': {
            signature: 'map(value, start1, stop1, start2, stop2)',
            description: 'Re-maps a number from one range to another.'
          },
          'random': {
            signature: 'random([min], [max]) or random(choices)',
            description: 'Returns a random floating-point number or element from an array.'
          },
          'noise': {
            signature: 'noise(x, [y], [z])',
            description: 'Returns the Perlin noise value at specified coordinates. Creates smooth random values.'
          },
          'noiseSeed': {
            signature: 'noiseSeed(seed)',
            description: 'Sets the seed value for noise(). Use same seed for consistent noise patterns.'
          },
          'randomSeed': {
            signature: 'randomSeed(seed)',
            description: 'Sets the seed value for random(). Use same seed for consistent random values.'
          },
          'constrain': {
            signature: 'constrain(n, low, high)',
            description: 'Constrains a value between a minimum and maximum value.'
          },
          'lerp': {
            signature: 'lerp(start, stop, amt)',
            description: 'Calculates a number between two numbers at a specific increment.'
          },
          'dist': {
            signature: 'dist(x1, y1, x2, y2)',
            description: 'Calculates the distance between two points.'
          }
        },
        'Control': {
          'loop': {
            signature: 'loop()',
            description: 'Causes draw() to execute continuously. By default, draw() loops.'
          },
          'noLoop': {
            signature: 'noLoop()',
            description: 'Stops draw() from continuously executing. Can restart with loop() or redraw().'
          },
          'redraw': {
            signature: 'redraw([n])',
            description: 'Executes draw() one time. Can specify number of times to redraw.'
          },
          'frameRate': {
            signature: 'frameRate([fps])',
            description: 'Sets the number of frames per second or gets the current framerate.'
          }
        },
        'Text': {
          'text': {
            signature: 'text(str, x, y, [width], [height])',
            description: 'Draws text to the screen at the specified position.'
          },
          'textAlign': {
            signature: 'textAlign(horizAlign, [vertAlign])',
            description: 'Sets the current alignment for drawing text. Values: LEFT, CENTER, RIGHT, TOP, BOTTOM.'
          },
          'textSize': {
            signature: 'textSize(size)',
            description: 'Sets the size of the text in pixels.'
          },
          'textWidth': {
            signature: 'textWidth(str)',
            description: 'Calculates and returns the width of any character or text string.'
          }
        }
      };

      // EEG Data Reference
      const eegReference = {
        'Frequency Bands': {
          'eegData.alpha': {
            signature: 'eegData.alpha (0.0 - 1.0)',
            description: 'Alpha waves (8-12 Hz). Higher during relaxation, meditation, and eyes closed.'
          },
          'eegData.beta': {
            signature: 'eegData.beta (0.0 - 1.0)',
            description: 'Beta waves (13-30 Hz). Higher during active thinking, focus, and concentration.'
          },
          'eegData.theta': {
            signature: 'eegData.theta (0.0 - 1.0)',
            description: 'Theta waves (4-8 Hz). Higher during deep meditation, creativity, and drowsiness.'
          },
          'eegData.delta': {
            signature: 'eegData.delta (0.0 - 1.0)',
            description: 'Delta waves (0.5-4 Hz). Higher during deep sleep (low when awake).'
          },
          'eegData.gamma': {
            signature: 'eegData.gamma (0.0 - 1.0)',
            description: 'Gamma waves (30+ Hz). Associated with high-level cognition and information processing.'
          }
        },
        'Derived Metrics': {
          'eegData.attention': {
            signature: 'eegData.attention (0.0 - 1.0)',
            description: 'Attention level derived from beta and gamma activity.'
          },
          'eegData.meditation': {
            signature: 'eegData.meditation (0.0 - 1.0)',
            description: 'Meditation/relaxation level derived from alpha and theta activity.'
          }
        },
        'Raw Data Access': {
          'eegData.getRawChannel': {
            signature: 'eegData.getRawChannel(channel, numSamples)',
            description: 'Get recent raw EEG samples from a channel. Channels: "TP9", "AF7", "AF8", "TP10".'
          },
          'eegData.getAllChannels': {
            signature: 'eegData.getAllChannels(numSamples)',
            description: 'Get recent samples from all 4 channels as an object.'
          },
          'eegData.getRecentEpoch': {
            signature: 'eegData.getRecentEpoch(numSamples)',
            description: 'Get a time-aligned epoch with all channels. Returns array where each element has 4 channel values.'
          },
          'eegData.getChannelNames': {
            signature: 'eegData.getChannelNames()',
            description: 'Returns array of channel names: ["TP9", "AF7", "AF8", "TP10"].'
          }
        },
        'Connection Status': {
          'eegData.connected': {
            signature: 'eegData.connected (boolean)',
            description: 'True if Muse is connected or simulation is running, false otherwise.'
          },
          'eegData.sampleRate': {
            signature: 'eegData.sampleRate (256)',
            description: 'Sample rate in Hz (samples per second).'
          }
        }
      };

      // Monaco Editor setup and management
      class CodeEditor {
        constructor() {
          this.editor = null;
          this.currentSketch = null;
          this.autoRun = true;
          this.lastLoadedCode = null; // Track last loaded/selected code
          this.lastLoadedFilename = null; // Track filename
          this.setupEditor();
        }

        setupAutocomplete() {
          // Create completion items for p5.js functions
          const p5CompletionItems = [];
          
          Object.keys(p5Reference).forEach(category => {
            Object.keys(p5Reference[category]).forEach(funcName => {
              const func = p5Reference[category][funcName];
              p5CompletionItems.push({
                label: funcName,
                kind: monaco.languages.CompletionItemKind.Function,
                documentation: `${func.signature}\n\n${func.description}`,
                insertText: funcName,
                detail: category
              });
            });
          });
          
          // Create completion items for eegData
          const eegCompletionItems = [];
          Object.keys(eegReference).forEach(category => {
            Object.keys(eegReference[category]).forEach(propName => {
              const prop = eegReference[category][propName];
              eegCompletionItems.push({
                label: propName,
                kind: monaco.languages.CompletionItemKind.Property,
                documentation: `${prop.signature}\n\n${prop.description}`,
                insertText: propName,
                detail: category
              });
            });
          });
          
          // Register completion provider
          monaco.languages.registerCompletionItemProvider('javascript', {
            provideCompletionItems: (model, position) => {
              const word = model.getWordUntilPosition(position);
              const range = {
                startLineNumber: position.lineNumber,
                endLineNumber: position.lineNumber,
                startColumn: word.startColumn,
                endColumn: word.endColumn
              };
              
              // Check if we're typing after "eegData."
              const lineContent = model.getLineContent(position.lineNumber);
              const textBeforeCursor = lineContent.substring(0, position.column - 1);
              
              if (textBeforeCursor.includes('eegData.')) {
                return {
                  suggestions: eegCompletionItems.map(item => ({
                    ...item,
                    range: range
                  }))
                };
              }
              
              // Otherwise show p5.js functions
              return {
                suggestions: [...p5CompletionItems, ...eegCompletionItems].map(item => ({
                  ...item,
                  range: range
                }))
              };
            }
          });
          
          console.log('✅ Autocomplete registered for p5.js and eegData');
        }

        setupEditor() {
          require.config({ 
            paths: { 
              'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.44.0/min/vs' 
            } 
          });

          require(['vs/editor/editor.main'], () => {
            this.editor = monaco.editor.create(document.getElementById('code-editor'), {
              value: this.getDefaultCode(),
              language: 'javascript',
              theme: 'vs-dark',
              fontSize: 12,
              minimap: { enabled: false },
              scrollBeyondLastLine: false,
              automaticLayout: true,
              wordWrap: 'on',
              suggestOnTriggerCharacters: true,
              quickSuggestions: true
            });

            // Register p5.js autocomplete
            this.setupAutocomplete();

            // Auto-run on change with debounce
            let timeout;
            this.editor.onDidChangeModelContent(() => {
              clearTimeout(timeout);
              timeout = setTimeout(() => {
                if (this.autoRun) {
                  this.runCode();
                }
              }, 1000);
            });

            // Initial run
            setTimeout(() => {
              console.log('Auto-running initial code...');
              this.runCode();
            }, 500);
          });
        }

        getDefaultCode() {
          return `// 🧠 BrainImation: Live EEG + P5.js
// Access real-time brain data through the 'eegData' object:
// eegData.alpha, eegData.beta, eegData.theta, eegData.delta
// eegData.attention, eegData.meditation, eegData.raw[]

let particles = [];
let time = 0;

function setup() {
  // Canvas is already created by the system
  // Just set up the drawing mode and initialize
  colorMode(HSB, 360, 100, 100, 1);
  
  // Initialize particles
  for (let i = 0; i < 50; i++) {
    particles.push({
      x: random(width),
      y: random(height),
      vx: random(-1, 1),
      vy: random(-1, 1),
      hue: random(360)
    });
  }
}

function draw() {
  // Background responds to meditation
  let bgAlpha = map(eegData.meditation, 0, 1, 0.05, 0.2);
  background(220, 30, 10, bgAlpha);
  
  time += 0.01;
  
  // Draw neural network
  stroke(180, 80, 90, 0.3);
  strokeWeight(1);
  
  for (let i = 0; i < particles.length; i++) {
    let p = particles[i];
    
    // Movement influenced by alpha waves
    let alphaForce = eegData.alpha * 2;
    p.vx += random(-alphaForce, alphaForce) * 0.01;
    p.vy += random(-alphaForce, alphaForce) * 0.01;
    
    // Damping
    p.vx *= 0.99;
    p.vy *= 0.99;
    
    // Update position
    p.x += p.vx;
    p.y += p.vy;
    
    // Wrap around edges
    if (p.x < 0) p.x = width;
    if (p.x > width) p.x = 0;
    if (p.y < 0) p.y = height;
    if (p.y > height) p.y = 0;
    
    // Color influenced by attention
    let hue = (p.hue + eegData.attention * 50 + time * 10) % 360;
    let brightness = map(eegData.beta, 0, 1, 30, 90);
    
    fill(hue, 70, brightness, 0.8);
    noStroke();
    
    // Size influenced by theta waves
    let size = 5 + eegData.theta * 15;
    ellipse(p.x, p.y, size);
    
    // Connect nearby particles
    for (let j = i + 1; j < particles.length; j++) {
      let p2 = particles[j];
      let d = dist(p.x, p.y, p2.x, p2.y);
      
      if (d < 80) {
        let alpha = map(d, 0, 80, 0.5, 0) * eegData.alpha;
        stroke(hue, 50, 70, alpha);
        strokeWeight(1);
        line(p.x, p.y, p2.x, p2.y);
      }
    }
  }
  
  // Display connection status
  if (!eegData.connected) {
    fill(0, 0, 100, 0.8);
    textAlign(CENTER, CENTER);
    textSize(20);
    text("Connect your Muse headset or use 'Simulate Data'", width/2, height/2 - 10);
    textSize(16);
    fill(0, 0, 70, 0.6);
    text("to see brain-controlled animation", width/2, height/2 + 20);
  }
}`;
        }

        runCode() {
          console.log('🚀 Running code...');
          try {
            // Clear any existing sketch
            if (this.currentSketch) {
              console.log('Removing existing sketch');
              this.currentSketch.remove();
            }

            // Clear the canvas container
            const container = document.getElementById('canvas-container');
            container.innerHTML = '';
            console.log('Canvas container cleared');

            // Hide error console
            document.getElementById('error-console').style.display = 'none';

            // Get code from editor
            const code = this.editor.getValue();
            console.log('Code retrieved from editor:', code.length, 'characters');

            // Get container dimensions
            const containerRect = container.getBoundingClientRect();
            const containerWidth = containerRect.width || 800;
            const containerHeight = containerRect.height || 600;
            console.log('Container dimensions:', containerWidth, 'x', containerHeight);

            // Execute the sketch with proper p5.js instance mode
            console.log('Creating p5 sketch...');
            this.currentSketch = new p5((p) => {
              // Store original p5 functions
              let userSetup, userDraw, userWindowResized;
              
              // Override console.error to catch p5 errors
              const originalError = console.error;
              console.error = function(...args) {
                originalError.apply(console, args);
                showError(args.join(' '));
              };

              // Make p5 functions available globally within the sketch context
              const bindP5Functions = () => {
                // Core p5 functions
                window.createCanvas = p.createCanvas.bind(p);
                window.background = p.background.bind(p);
                window.fill = p.fill.bind(p);
                window.stroke = p.stroke.bind(p);
                window.noStroke = p.noStroke.bind(p);
                window.noFill = p.noFill.bind(p);
                window.strokeWeight = p.strokeWeight.bind(p);
                window.ellipse = p.ellipse.bind(p);
                window.rect = p.rect.bind(p);
                window.line = p.line.bind(p);
                window.point = p.point.bind(p);
                window.triangle = p.triangle.bind(p);
                window.quad = p.quad.bind(p);
                window.arc = p.arc.bind(p);
                window.text = p.text.bind(p);
                window.textAlign = p.textAlign.bind(p);
                window.textSize = p.textSize.bind(p);
                window.textFont = p.textFont ? p.textFont.bind(p) : undefined;
                window.textWidth = p.textWidth.bind(p);
                window.beginShape = p.beginShape.bind(p);
                window.endShape = p.endShape.bind(p);
                window.vertex = p.vertex.bind(p);
                window.curveVertex = p.curveVertex ? p.curveVertex.bind(p) : undefined;
                window.bezierVertex = p.bezierVertex ? p.bezierVertex.bind(p) : undefined;
                
                // Loop control
                window.loop = p.loop.bind(p);
                window.noLoop = p.noLoop.bind(p);
                window.redraw = p.redraw.bind(p);
                
                // Math and utility
                window.map = p.map.bind(p);
                window.random = p.random.bind(p);
                window.randomSeed = p.randomSeed.bind(p);
                window.noise = p.noise.bind(p);
                window.noiseSeed = p.noiseSeed.bind(p);
                window.noiseDetail = p.noiseDetail ? p.noiseDetail.bind(p) : undefined;
                window.sin = p.sin.bind(p);
                window.cos = p.cos.bind(p);
                window.tan = p.tan.bind(p);
                window.asin = p.asin ? p.asin.bind(p) : undefined;
                window.acos = p.acos ? p.acos.bind(p) : undefined;
                window.atan = p.atan ? p.atan.bind(p) : undefined;
                window.atan2 = p.atan2 ? p.atan2.bind(p) : undefined;
                window.dist = p.dist.bind(p);
                window.abs = p.abs.bind(p);
                window.max = p.max.bind(p);
                window.min = p.min.bind(p);
                window.floor = p.floor.bind(p);
                window.ceil = p.ceil.bind(p);
                window.round = p.round.bind(p);
                window.sqrt = p.sqrt ? p.sqrt.bind(p) : undefined;
                window.pow = p.pow ? p.pow.bind(p) : undefined;
                window.constrain = p.constrain ? p.constrain.bind(p) : undefined;
                window.lerp = p.lerp ? p.lerp.bind(p) : undefined;
                window.norm = p.norm ? p.norm.bind(p) : undefined;
                
                // Color functions
                window.colorMode = p.colorMode.bind(p);
                window.color = p.color.bind(p);
                window.lerpColor = p.lerpColor.bind(p);
                window.red = p.red ? p.red.bind(p) : undefined;
                window.green = p.green ? p.green.bind(p) : undefined;
                window.blue = p.blue ? p.blue.bind(p) : undefined;
                window.alpha = p.alpha ? p.alpha.bind(p) : undefined;
                window.hue = p.hue ? p.hue.bind(p) : undefined;
                window.saturation = p.saturation ? p.saturation.bind(p) : undefined;
                window.brightness = p.brightness ? p.brightness.bind(p) : undefined;
                
                // Color mode constants
                window.HSB = p.HSB;
                window.RGB = p.RGB;
                window.HSL = p.HSL;
                
                // Transformation functions
                window.translate = p.translate.bind(p);
                window.rotate = p.rotate.bind(p);
                window.rotateX = p.rotateX ? p.rotateX.bind(p) : undefined;
                window.rotateY = p.rotateY ? p.rotateY.bind(p) : undefined;
                window.rotateZ = p.rotateZ ? p.rotateZ.bind(p) : undefined;
                window.scale = p.scale.bind(p);
                window.shearX = p.shearX ? p.shearX.bind(p) : undefined;
                window.shearY = p.shearY ? p.shearY.bind(p) : undefined;
                window.push = p.push.bind(p);
                window.pop = p.pop.bind(p);
                window.resetMatrix = p.resetMatrix ? p.resetMatrix.bind(p) : undefined;
                
                // Shape detail
                window.rectMode = p.rectMode ? p.rectMode.bind(p) : undefined;
                window.ellipseMode = p.ellipseMode ? p.ellipseMode.bind(p) : undefined;
                window.strokeCap = p.strokeCap ? p.strokeCap.bind(p) : undefined;
                window.strokeJoin = p.strokeJoin ? p.strokeJoin.bind(p) : undefined;
                window.smooth = p.smooth ? p.smooth.bind(p) : undefined;
                window.noSmooth = p.noSmooth ? p.noSmooth.bind(p) : undefined;
                
                // Constants
                window.TWO_PI = p.TWO_PI;
                window.PI = p.PI;
                window.HALF_PI = p.HALF_PI;
                window.QUARTER_PI = p.QUARTER_PI;
                window.CENTER = p.CENTER;
                window.LEFT = p.LEFT;
                window.RIGHT = p.RIGHT;
                window.TOP = p.TOP;
                window.BOTTOM = p.BOTTOM;
                window.CORNER = p.CORNER;
                window.CORNERS = p.CORNERS;
                window.RADIUS = p.RADIUS;
                window.CLOSE = p.CLOSE;
                window.OPEN = p.OPEN;
                
                // Frame and time
                window.frameCount = p.frameCount;
                window.millis = p.millis.bind(p);
                window.frameRate = p.frameRate.bind(p);
                
                // Dimensions (will be updated after canvas creation)
                window.width = containerWidth;
                window.height = containerHeight;
                window.windowWidth = containerWidth;
                window.windowHeight = containerHeight;
              };

              // Bind p5 functions
              bindP5Functions();

              // Execute user code to get their setup/draw functions
              try {
                console.log('Executing user code...');
                console.log('Code to execute:', code.substring(0, 200) + '...');
                
                // Clear any existing user functions
                window.setup = undefined;
                window.draw = undefined;
                window.windowResized = undefined;
                
                // Use eval with 'this' bound to window to ensure global scope
                eval.call(window, code);
                
                console.log('User code executed successfully');
                console.log('window.setup type:', typeof window.setup);
                console.log('window.draw type:', typeof window.draw);
                
                // Capture user-defined functions
                if (typeof window.setup === 'function') {
                  userSetup = window.setup;
                  console.log('✅ User setup function captured');
                } else {
                  console.log('❌ No setup function found in user code');
                }
                
                if (typeof window.draw === 'function') {
                  userDraw = window.draw;
                  console.log('✅ User draw function captured');
                } else {
                  console.log('❌ No draw function found in user code');
                }
                
                if (typeof window.windowResized === 'function') {
                  userWindowResized = window.windowResized;
                  console.log('✅ User windowResized function captured');
                }
              } catch (error) {
                console.error('Error in user code:', error);
                showError('Error in user code: ' + error.message);
                return;
              }

              // p5.js setup function
              p.setup = function() {
                console.log('p5.js setup() called');
                // Create canvas and attach to container
                const canvas = p.createCanvas(containerWidth, containerHeight);
                canvas.parent('canvas-container');
                console.log('Canvas created:', containerWidth, 'x', containerHeight);
                
                // Update global dimensions
                window.width = p.width;
                window.height = p.height;
                window.windowWidth = containerWidth;
                window.windowHeight = containerHeight;
                
                // Call user setup if it exists
                if (userSetup) {
                  console.log('Calling user setup function');
                  userSetup();
                } else {
                  console.log('No user setup function found');
                }
              };

              // p5.js draw function
              p.draw = function() {
                // Update frame count and dimensions
                window.frameCount = p.frameCount;
                window.width = p.width;
                window.height = p.height;
                
                // Call user draw if it exists
                if (userDraw) {
                  userDraw();
                } else {
                  // Show a test pattern if no user draw function
                  p.background(50);
                  p.fill(255);
                  p.textAlign(p.CENTER, p.CENTER);
                  p.textSize(20);
                  p.text('Canvas is working! Add your draw() function.', p.width/2, p.height/2);
                }
              };

              // Handle window resize
              p.windowResized = function() {
                const newRect = container.getBoundingClientRect();
                const newWidth = newRect.width || 800;
                const newHeight = newRect.height || 600;
                
                p.resizeCanvas(newWidth, newHeight);
                window.width = p.width;
                window.height = p.height;
                window.windowWidth = newWidth;
                window.windowHeight = newHeight;
                
                if (userWindowResized) {
                  userWindowResized();
                }
              };

            });

          } catch (error) {
            console.error('Error creating p5 sketch:', error);
            this.showError('Error creating sketch: ' + error.message);
          }
        }

        showError(message) {
          const errorConsole = document.getElementById('error-console');
          errorConsole.textContent = message;
          errorConsole.style.display = 'block';
        }

        saveCode() {
          const code = this.editor.getValue();
          const blob = new Blob([code], { type: 'text/javascript' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          
          // Generate filename with timestamp
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
          const filename = this.lastLoadedFilename || `brainimation-${timestamp}.js`;
          
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          
          console.log('Code saved as:', filename);
        }

        loadCodeFromFile(file) {
          const reader = new FileReader();
          
          reader.onload = (e) => {
            const code = e.target.result;
            this.editor.setValue(code);
            this.lastLoadedCode = code;
            this.lastLoadedFilename = file.name;
            
            // Enable reload button
            document.getElementById('reload-btn').disabled = false;
            
            console.log('Code loaded from:', file.name);
            
            // Auto-run the loaded code
            if (this.autoRun) {
              this.runCode();
            }
          };
          
          reader.onerror = (e) => {
            this.showError('Error loading file: ' + e.target.error);
          };
          
          reader.readAsText(file);
        }

        reloadCode() {
          if (this.lastLoadedCode) {
            this.editor.setValue(this.lastLoadedCode);
            console.log('Code reloaded:', this.lastLoadedFilename || 'last loaded code');
            
            // Auto-run the reloaded code
            if (this.autoRun) {
              this.runCode();
            }
          } else {
            console.log('No code to reload');
          }
        }

        loadExample(exampleName) {
          const examples = {
            basic: `// Basic animated background
function setup() {
  console.log('User setup() function called!');
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  let hue = map(eegData.alpha, 0, 1, 180, 300);
  background(hue, 50, 20);
  
  fill(hue + 60, 80, 90);
  let size = 50 + eegData.attention * 100;
  ellipse(width/2, height/2, size);
}`,

            alpha: `// Alpha wave visualization
let waves = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(220, 30, 10, 0.1);
  
  // Add new wave based on alpha strength
  if (frameCount % 10 === 0) {
    waves.push({
      x: width/2,
      y: height/2,
      r: 0,
      alpha: eegData.alpha
    });
  }
  
  // Draw and update waves
  for (let i = waves.length - 1; i >= 0; i--) {
    let w = waves[i];
    
    noFill();
    stroke(200, 70, 90, w.alpha);
    strokeWeight(2);
    ellipse(w.x, w.y, w.r * 2);
    
    w.r += w.alpha * 5 + 1;
    w.alpha *= 0.98;
    
    if (w.alpha < 0.01) {
      waves.splice(i, 1);
    }
  }
}`,

            attention: `// Attention meter
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Attention bar
  let barWidth = width * 0.8;
  let barHeight = 40;
  let x = (width - barWidth) / 2;
  let y = height / 2;
  
  // Background bar
  fill(0, 0, 20);
  rect(x, y, barWidth, barHeight);
  
  // Attention level
  let attentionWidth = barWidth * eegData.attention;
  let hue = map(eegData.attention, 0, 1, 0, 120);
  fill(hue, 80, 90);
  rect(x, y, attentionWidth, barHeight);
  
  // Text
  fill(0, 0, 100);
  textAlign(CENTER, CENTER);
  textSize(20);
  text("Attention: " + (eegData.attention * 100).toFixed(1) + "%", width/2, y - 60);
}`,

            particles: `// Brain particle system
let particles = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  for (let i = 0; i < 100; i++) {
    particles.push({
      x: random(width),
      y: random(height),
      vx: random(-2, 2),
      vy: random(-2, 2),
      life: 1.0
    });
  }
}

function draw() {
  background(0, 0, 5, 0.1);
  
  for (let p of particles) {
    // Movement influenced by brain waves
    p.vx += (random(-1, 1) * eegData.alpha * 0.1);
    p.vy += (random(-1, 1) * eegData.beta * 0.1);
    
    p.x += p.vx;
    p.y += p.vy;
    
    // Wrap around
    if (p.x < 0) p.x = width;
    if (p.x > width) p.x = 0;
    if (p.y < 0) p.y = height;
    if (p.y > height) p.y = 0;
    
    // Draw particle
    let hue = map(eegData.theta, 0, 1, 180, 300);
    fill(hue, 70, 90, p.life);
    noStroke();
    ellipse(p.x, p.y, 5 + eegData.gamma * 10);
    
    p.life *= 0.995;
    if (p.life < 0.1) p.life = 1.0;
  }
}`,

            mandala: `// Neural mandala
let angle = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 0, 0.05);
  
  translate(width/2, height/2);
  
  let layers = 5;
  for (let layer = 0; layer < layers; layer++) {
    let radius = 50 + layer * 40;
    let points = 6 + layer * 2;
    
    for (let i = 0; i < points; i++) {
      let a = angle + (TWO_PI / points) * i;
      let x = cos(a) * radius;
      let y = sin(a) * radius;
      
      let hue = (angle * 57.3 + layer * 60) % 360;
      let brightness = 50 + eegData.attention * 40;
      let size = 5 + eegData.alpha * layer * 2;
      
      fill(hue, 80, brightness, 0.7);
      noStroke();
      ellipse(x, y, size);
    }
  }
  
  angle += eegData.meditation * 0.02 + 0.005;
}`,

            waves: `// EEG wave visualization
let waveHistory = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  
  // Add current values to history
  waveHistory.push({
    alpha: eegData.alpha,
    beta: eegData.beta,
    theta: eegData.theta,
    delta: eegData.delta
  });
  
  // Keep history manageable
  if (waveHistory.length > width / 2) {
    waveHistory.shift();
  }
  
  // Draw waves
  let waves = ['alpha', 'beta', 'theta', 'delta'];
  let colors = [300, 180, 60, 0];
  
  for (let w = 0; w < waves.length; w++) {
    let wave = waves[w];
    let hue = colors[w];
    
    stroke(hue, 70, 90);
    strokeWeight(2);
    noFill();
    
    beginShape();
    for (let i = 0; i < waveHistory.length; i++) {
      let x = map(i, 0, waveHistory.length - 1, 0, width);
      let y = height/2 + (w - 1.5) * 80 + waveHistory[i][wave] * -50;
      vertex(x, y);
    }
    endShape();
    
    // Label
    fill(hue, 70, 90);
    noStroke();
    textAlign(LEFT, CENTER);
    text(wave.toUpperCase(), 10, height/2 + (w - 1.5) * 80);
  }
}`,

            eegtrace: `// Raw EEG trace visualization
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Get raw EEG data from TP9 electrode (left temporal)
  let tp9Data = eegData.getRawChannel('TP9', 300);
  
  if (tp9Data.length > 10) {
    // Draw EEG trace
    stroke(180, 80, 90);
    strokeWeight(2);
    noFill();
    
    beginShape();
    for (let i = 0; i < tp9Data.length; i++) {
      let x = map(i, 0, tp9Data.length - 1, 50, width - 50);
      let y = map(tp9Data[i], -100, 100, height - 50, 50);
      vertex(x, y);
    }
    endShape();
    
    // Add grid lines
    stroke(0, 0, 30);
    strokeWeight(1);
    
    // Horizontal lines (voltage levels)
    for (let v = -100; v <= 100; v += 50) {
      let y = map(v, -100, 100, height - 50, 50);
      line(50, y, width - 50, y);
    }
    
    // Vertical time markers
    for (let t = 0; t < tp9Data.length; t += 50) {
      let x = map(t, 0, tp9Data.length - 1, 50, width - 50);
      line(x, 50, x, height - 50);
    }
    
    // Labels
    fill(0, 0, 100);
    noStroke();
    textAlign(LEFT, TOP);
    textSize(16);
    text("TP9 Raw EEG Trace", 50, 20);
    
    textAlign(RIGHT, CENTER);
    textSize(12);
    text("100μV", 45, map(100, -100, 100, height - 50, 50));
    text("0μV", 45, map(0, -100, 100, height - 50, 50));
    text("-100μV", 45, map(-100, -100, 100, height - 50, 50));
  } else {
    // No data message
    fill(0, 0, 70);
    textAlign(CENTER, CENTER);
    textSize(20);
    text("Waiting for EEG data...", width/2, height/2);
  }
}`,

            multichannel: `// Multi-channel EEG visualization
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  let channels = eegData.getChannelNames();
  let colors = [300, 180, 60, 120]; // Purple, Cyan, Yellow, Green
  
  // Draw each channel
  for (let c = 0; c < channels.length; c++) {
    let channelData = eegData.getRawChannel(channels[c], 200);
    
    if (channelData.length > 10) {
      let yOffset = (c + 1) * height / (channels.length + 1);
      
      // Channel trace
      stroke(colors[c], 80, 90);
      strokeWeight(1.5);
      noFill();
      
      beginShape();
      for (let i = 0; i < channelData.length; i++) {
        let x = map(i, 0, channelData.length - 1, 80, width - 20);
        let y = yOffset + map(channelData[i], -100, 100, -40, 40);
        vertex(x, y);
      }
      endShape();
      
      // Channel label
      fill(colors[c], 80, 90);
      noStroke();
      textAlign(LEFT, CENTER);
      textSize(14);
      text(channels[c], 10, yOffset);
      
      // Zero line
      stroke(0, 0, 20);
      strokeWeight(1);
      line(80, yOffset, width - 20, yOffset);
    }
  }
  
  // Title
  fill(0, 0, 100);
  noStroke();
  textAlign(CENTER, TOP);
  textSize(16);
  text("Multi-Channel EEG (All 4 Electrodes)", width/2, 10);
  
  // Real-time indicator
  if (eegData.connected) {
    fill(120, 80, 90);
    ellipse(width - 30, 30, 10);
    textAlign(RIGHT, CENTER);
    textSize(12);
    text("LIVE", width - 40, 30);
  }
}`,

            epochs: `// EEG epoch visualization (like ERP analysis)
let epochData = [];
let epochLength = 128; // ~0.5 seconds at 256Hz

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 8);
  
  // Collect epochs when attention changes significantly
  if (frameCount % 60 === 0) { // Every second
    let recentEpoch = eegData.getRecentEpoch(epochLength);
    if (recentEpoch.length >= epochLength) {
      epochData.push({
        data: recentEpoch,
        attention: eegData.attention,
        timestamp: millis()
      });
      
      // Keep last 20 epochs
      if (epochData.length > 20) {
        epochData.shift();
      }
    }
  }
  
  if (epochData.length > 0) {
    // Draw averaged epoch
    let avgEpoch = [];
    for (let i = 0; i < epochLength; i++) {
      let sum = [0, 0, 0, 0]; // 4 channels
      let count = 0;
      
      for (let e = 0; e < epochData.length; e++) {
        if (epochData[e].data[i]) {
          for (let ch = 0; ch < 4; ch++) {
            sum[ch] += epochData[e].data[i][ch] || 0;
          }
          count++;
        }
      }
      
      if (count > 0) {
        avgEpoch.push([
          sum[0] / count,
          sum[1] / count,
          sum[2] / count,
          sum[3] / count
        ]);
      }
    }
    
    // Draw the averaged epoch for each channel
    let channelNames = ['TP9', 'AF7', 'AF8', 'TP10'];
    let colors = [300, 180, 60, 120];
    
    for (let ch = 0; ch < 4; ch++) {
      stroke(colors[ch], 80, 90);
      strokeWeight(2);
      noFill();
      
      beginShape();
      for (let i = 0; i < avgEpoch.length; i++) {
        let x = map(i, 0, avgEpoch.length - 1, 60, width - 60);
        let y = height/2 + (ch - 1.5) * 60 + map(avgEpoch[i][ch], -50, 50, 30, -30);
        vertex(x, y);
      }
      endShape();
      
      // Channel label
      fill(colors[ch], 80, 90);
      noStroke();
      textAlign(LEFT, CENTER);
      textSize(12);
      text(channelNames[ch], 10, height/2 + (ch - 1.5) * 60);
    }
    
    // Zero line
    stroke(0, 0, 30);
    strokeWeight(1);
    line(60, height/2, width - 60, height/2);
    
    // Time markers
    textAlign(CENTER, BOTTOM);
    textSize(10);
    fill(0, 0, 60);
    text("0ms", 60, height - 10);
    text("250ms", width/2, height - 10);
    text("500ms", width - 60, height - 10);
    
    // Title and info
    fill(0, 0, 100);
    textAlign(CENTER, TOP);
    textSize(16);
    text("Averaged Epochs (n=" + epochData.length + ")", width/2, 10);
    
    textSize(12);
    text("Grand average across all channels", width/2, 30);
  } else {
    // Waiting message
    fill(0, 0, 70);
    textAlign(CENTER, CENTER);
    textSize(18);
    text("Collecting epochs...", width/2, height/2);
    textSize(14);
    text("Epochs will appear as data accumulates", width/2, height/2 + 30);
  }
}`,

            // New examples from p5.eegedu.art repository
            basicShapes: `// Basic shapes with brain control
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  
  // Circle size controlled by alpha
  let circleSize = 50 + eegData.alpha * 150;
  fill(180, 70, 90);
  ellipse(width/4, height/2, circleSize);
  
  // Rectangle size controlled by beta
  let rectSize = 30 + eegData.beta * 100;
  fill(270, 70, 90);
  rect(width/2 - rectSize/2, height/2 - rectSize/2, rectSize, rectSize);
  
  // Triangle controlled by theta
  let triSize = 40 + eegData.theta * 120;
  fill(60, 70, 90);
  triangle(
    3*width/4, height/2 + triSize/2,
    3*width/4 - triSize/2, height/2 - triSize/2,
    3*width/4 + triSize/2, height/2 - triSize/2
  );
}`,

            functionExample: `// Function example with EEG
function setup() {
  colorMode(HSB, 360, 100, 100);
  frameRate(30);
}

function draw() {
  background(0, 0, 5);
  
  // Draw grid of brain-controlled shapes
  for (let x = 0; x < 5; x++) {
    for (let y = 0; y < 5; y++) {
      drawBrainShape(
        x * width/5 + width/10,
        y * height/5 + height/10,
        x, y
      );
    }
  }
}

function drawBrainShape(x, y, gridX, gridY) {
  push();
  translate(x, y);
  
  let size = 20 + eegData.attention * 40;
  let hue = (gridX * 60 + gridY * 30 + frameCount) % 360;
  let brightness = 50 + eegData.meditation * 40;
  
  fill(hue, 70, brightness);
  noStroke();
  ellipse(0, 0, size);
  pop();
}`,

            BasicFrequencyBands: `// Basic frequency bands visualization
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Draw bars for each frequency band
  let bands = [
    {name: 'Delta', value: eegData.delta, hue: 0},
    {name: 'Theta', value: eegData.theta, hue: 60},
    {name: 'Alpha', value: eegData.alpha, hue: 180},
    {name: 'Beta', value: eegData.beta, hue: 270},
    {name: 'Gamma', value: eegData.gamma, hue: 300}
  ];
  
  let barWidth = width / bands.length;
  
  for (let i = 0; i < bands.length; i++) {
    let band = bands[i];
    let x = i * barWidth;
    let barHeight = band.value * height * 0.8;
    
    // Draw bar
    fill(band.hue, 70, 90);
    rect(x, height - barHeight, barWidth - 10, barHeight);
    
    // Draw label
    fill(0, 0, 100);
    textAlign(CENTER, BOTTOM);
    textSize(12);
    text(band.name, x + barWidth/2, height - 5);
    
    // Draw value
    textAlign(CENTER, TOP);
    textSize(10);
    text(band.value.toFixed(2), x + barWidth/2, height - barHeight - 5);
  }
}`,

            bandOrbitz: `// Band orbitz - frequency bands as orbiting circles
let angle = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5, 0.1);
  translate(width/2, height/2);
  
  let bands = [
    {name: 'Delta', value: eegData.delta, hue: 0, radius: 50},
    {name: 'Theta', value: eegData.theta, hue: 60, radius: 100},
    {name: 'Alpha', value: eegData.alpha, hue: 180, radius: 150},
    {name: 'Beta', value: eegData.beta, hue: 270, radius: 200},
    {name: 'Gamma', value: eegData.gamma, hue: 300, radius: 250}
  ];
  
  for (let i = 0; i < bands.length; i++) {
    let band = bands[i];
    let a = angle + (i * TWO_PI / bands.length);
    let r = band.radius;
    let size = 10 + band.value * 40;
    
    let x = cos(a) * r;
    let y = sin(a) * r;
    
    fill(band.hue, 70, 90, 0.8);
    noStroke();
    ellipse(x, y, size);
    
    // Draw orbit path
    noFill();
    stroke(band.hue, 30, 50, 0.3);
    ellipse(0, 0, r * 2);
  }
  
  angle += 0.02 * eegData.attention;
}`,

            piWedges: `// Pi wedges - frequency bands as pie chart
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  translate(width/2, height/2);
  
  let bands = [
    {name: 'Delta', value: eegData.delta, hue: 0},
    {name: 'Theta', value: eegData.theta, hue: 60},
    {name: 'Alpha', value: eegData.alpha, hue: 180},
    {name: 'Beta', value: eegData.beta, hue: 270},
    {name: 'Gamma', value: eegData.gamma, hue: 300}
  ];
  
  let total = bands.reduce((sum, b) => sum + b.value, 0);
  let startAngle = 0;
  let radius = min(width, height) * 0.35;
  
  for (let i = 0; i < bands.length; i++) {
    let band = bands[i];
    let angle = (band.value / total) * TWO_PI;
    
    // Draw wedge
    fill(band.hue, 70, 90);
    arc(0, 0, radius * 2, radius * 2, startAngle, startAngle + angle, PIE);
    
    // Draw label
    let midAngle = startAngle + angle / 2;
    let labelX = cos(midAngle) * radius * 0.6;
    let labelY = sin(midAngle) * radius * 0.6;
    
    fill(0, 0, 100);
    textAlign(CENTER, CENTER);
    textSize(12);
    text(band.name, labelX, labelY);
    
    startAngle += angle;
  }
}`,

            spectra: `// Spectra - frequency spectrum visualization
let spectrumHistory = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Add current spectrum to history
  spectrumHistory.push({
    delta: eegData.delta,
    theta: eegData.theta,
    alpha: eegData.alpha,
    beta: eegData.beta,
    gamma: eegData.gamma
  });
  
  if (spectrumHistory.length > 100) {
    spectrumHistory.shift();
  }
  
  // Draw spectrum over time
  let bands = ['delta', 'theta', 'alpha', 'beta', 'gamma'];
  let hues = [0, 60, 180, 270, 300];
  
  for (let b = 0; b < bands.length; b++) {
    stroke(hues[b], 70, 90);
    strokeWeight(2);
    noFill();
    
    beginShape();
    for (let i = 0; i < spectrumHistory.length; i++) {
      let x = map(i, 0, spectrumHistory.length - 1, 50, width - 50);
      let y = height/2 + (b - 2) * 60 - spectrumHistory[i][bands[b]] * 40;
      vertex(x, y);
    }
    endShape();
    
    // Label
    fill(hues[b], 70, 90);
    noStroke();
    textAlign(LEFT, CENTER);
    textSize(10);
    text(bands[b].toUpperCase(), 10, height/2 + (b - 2) * 60);
  }
}`,

            ColourBalls: `// Colour balls - attention-controlled bouncing balls
let balls = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  for (let i = 0; i < 20; i++) {
    balls.push({
      x: random(width),
      y: random(height),
      vx: random(-3, 3),
      vy: random(-3, 3),
      size: random(10, 40),
      hue: random(360)
    });
  }
}

function draw() {
  background(0, 0, 5, 0.2);
  
  for (let ball of balls) {
    // Update position
    ball.x += ball.vx * (1 + eegData.attention);
    ball.y += ball.vy * (1 + eegData.attention);
    
    // Bounce off edges
    if (ball.x < 0 || ball.x > width) ball.vx *= -1;
    if (ball.y < 0 || ball.y > height) ball.vy *= -1;
    
    // Keep in bounds
    ball.x = constrain(ball.x, 0, width);
    ball.y = constrain(ball.y, 0, height);
    
    // Rotate hue based on meditation
    ball.hue = (ball.hue + eegData.meditation * 2) % 360;
    
    // Draw ball
    fill(ball.hue, 70, 90, 0.8);
    noStroke();
    ellipse(ball.x, ball.y, ball.size);
  }
}`,

            MultipleBalls: `// Multiple balls with different behaviors
let balls = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      balls.push({
        x: (i + 1) * width / 4,
        y: (j + 1) * height / 4,
        vx: random(-2, 2),
        vy: random(-2, 2),
        type: (i * 3 + j) % 5,
        phase: random(TWO_PI)
      });
    }
  }
}

function draw() {
  background(0, 0, 10, 0.1);
  
  let bands = [eegData.delta, eegData.theta, eegData.alpha, eegData.beta, eegData.gamma];
  let hues = [0, 60, 180, 270, 300];
  
  for (let ball of balls) {
    let bandValue = bands[ball.type];
    let hue = hues[ball.type];
    
    // Update with different behavior per type
    ball.x += ball.vx * (1 + bandValue);
    ball.y += ball.vy * (1 + bandValue);
    
    // Bounce
    if (ball.x < 0 || ball.x > width) ball.vx *= -1;
    if (ball.y < 0 || ball.y > height) ball.vy *= -1;
    
    ball.x = constrain(ball.x, 0, width);
    ball.y = constrain(ball.y, 0, height);
    
    // Draw
    let size = 15 + bandValue * 30;
    fill(hue, 70, 90, 0.7);
    noStroke();
    ellipse(ball.x, ball.y, size);
  }
}`,

            '3dTorus': `// 3D Torus controlled by brain waves
let rotX = 0;
let rotY = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Setup 3D
  push();
  translate(width/2, height/2);
  
  // Rotate based on brain waves
  rotX += eegData.alpha * 0.02;
  rotY += eegData.beta * 0.02;
  
  rotateX(rotX);
  rotateY(rotY);
  
  // Draw torus with changing parameters
  let radius = 50 + eegData.meditation * 50;
  let tubeRadius = 10 + eegData.attention * 20;
  
  // Color based on theta
  let hue = eegData.theta * 360;
  fill(hue, 70, 90);
  noStroke();
  
  torus(radius, tubeRadius);
  pop();
  
  // Info text
  fill(0, 0, 100);
  textAlign(LEFT, TOP);
  textSize(10);
  text("Alpha: rotation X", 10, 10);
  text("Beta: rotation Y", 10, 25);
  text("Meditation: radius", 10, 40);
  text("Attention: tube", 10, 55);
}`,

            AlphaSnake: `// Alpha snake - snake controlled by alpha waves
let snake = [];
let angle = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  // Initialize snake
  for (let i = 0; i < 50; i++) {
    snake.push({x: width/2, y: height/2});
  }
}

function draw() {
  background(0, 0, 5, 0.1);
  
  // Move snake head based on alpha
  angle += map(eegData.alpha, 0, 1, -0.1, 0.1);
  let speed = 2 + eegData.beta * 3;
  
  let headX = snake[0].x + cos(angle) * speed;
  let headY = snake[0].y + sin(angle) * speed;
  
  // Wrap around
  headX = (headX + width) % width;
  headY = (headY + height) % height;
  
  // Add new head
  snake.unshift({x: headX, y: headY});
  snake.pop();
  
  // Draw snake
  for (let i = 0; i < snake.length; i++) {
    let hue = (i * 5 + frameCount) % 360;
    let size = map(i, 0, snake.length - 1, 20, 5);
    let brightness = 50 + eegData.attention * 40;
    
    fill(hue, 70, brightness);
    noStroke();
    ellipse(snake[i].x, snake[i].y, size);
  }
}`,

            SplineBounce: `// Spline bounce - smooth curves with EEG
let points = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  // Initialize points
  for (let i = 0; i < 8; i++) {
    points.push({
      x: random(width),
      y: random(height),
      vx: random(-2, 2),
      vy: random(-2, 2)
    });
  }
}

function draw() {
  background(0, 0, 10);
  
  // Update points
  for (let p of points) {
    p.x += p.vx * (1 + eegData.attention * 0.5);
    p.y += p.vy * (1 + eegData.attention * 0.5);
    
    if (p.x < 0 || p.x > width) p.vx *= -1;
    if (p.y < 0 || p.y > height) p.vy *= -1;
    
    p.x = constrain(p.x, 0, width);
    p.y = constrain(p.y, 0, height);
  }
  
  // Draw smooth curve through points
  stroke(180 + eegData.alpha * 180, 70, 90);
  strokeWeight(2 + eegData.meditation * 5);
  noFill();
  
  beginShape();
  for (let i = 0; i < points.length; i++) {
    curveVertex(points[i].x, points[i].y);
  }
  // Repeat first points to close curve
  curveVertex(points[0].x, points[0].y);
  curveVertex(points[1].x, points[1].y);
  endShape();
  
  // Draw control points
  for (let p of points) {
    fill(60, 70, 90);
    noStroke();
    ellipse(p.x, p.y, 8);
  }
}`,

            BrainDraw: `// Brain draw - draw with your mind
let drawing = [];
let x, y;

function setup() {
  colorMode(HSB, 360, 100, 100);
  x = width/2;
  y = height/2;
}

function draw() {
  // Fade background slowly
  background(0, 0, 5, 0.02);
  
  // Move based on brain waves
  let dx = map(eegData.alpha - 0.5, -0.5, 0.5, -3, 3);
  let dy = map(eegData.beta - 0.5, -0.5, 0.5, -3, 3);
  
  x += dx;
  y += dy;
  
  // Keep in bounds
  x = constrain(x, 0, width);
  y = constrain(y, 0, height);
  
  // Draw if attention is high
  if (eegData.attention > 0.3) {
    let hue = eegData.theta * 360;
    let size = 5 + eegData.meditation * 20;
    
    fill(hue, 70, 90, 0.6);
    noStroke();
    ellipse(x, y, size);
    
    drawing.push({x: x, y: y, hue: hue, size: size});
    
    // Limit history
    if (drawing.length > 500) {
      drawing.shift();
    }
  }
  
  // Draw cursor
  stroke(0, 0, 100);
  strokeWeight(2);
  noFill();
  ellipse(x, y, 20);
  
  // Instructions
  fill(0, 0, 100);
  textAlign(LEFT, TOP);
  textSize(10);
  text("Alpha: move X | Beta: move Y", 10, 10);
  text("Attention: draw | Theta: color | Meditation: size", 10, 25);
}`,

            bouncingLine: `// Bouncing line with brain control
let x1, y1, x2, y2;
let vx1, vy1, vx2, vy2;

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  x1 = width/4;
  y1 = height/2;
  x2 = 3*width/4;
  y2 = height/2;
  
  vx1 = random(-3, 3);
  vy1 = random(-3, 3);
  vx2 = random(-3, 3);
  vy2 = random(-3, 3);
}

function draw() {
  background(0, 0, 5, 0.1);
  
  // Update endpoints
  let speed = 1 + eegData.attention;
  x1 += vx1 * speed;
  y1 += vy1 * speed;
  x2 += vx2 * speed;
  y2 += vy2 * speed;
  
  // Bounce
  if (x1 < 0 || x1 > width) vx1 *= -1;
  if (y1 < 0 || y1 > height) vy1 *= -1;
  if (x2 < 0 || x2 > width) vx2 *= -1;
  if (y2 < 0 || y2 > height) vy2 *= -1;
  
  x1 = constrain(x1, 0, width);
  y1 = constrain(y1, 0, height);
  x2 = constrain(x2, 0, width);
  y2 = constrain(y2, 0, height);
  
  // Draw line with varying thickness
  let weight = 1 + eegData.alpha * 20;
  let hue = eegData.theta * 360;
  
  stroke(hue, 70, 90);
  strokeWeight(weight);
  line(x1, y1, x2, y2);
  
  // Draw endpoints
  noStroke();
  fill(hue, 90, 90);
  ellipse(x1, y1, 15);
  ellipse(x2, y2, 15);
}`,

            ghostLines: `// Ghost lines - trailing line patterns
let lines = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5, 0.05);
  
  // Add new line
  if (frameCount % 3 === 0) {
    lines.push({
      x1: width/2 + cos(frameCount * 0.05) * 100,
      y1: height/2 + sin(frameCount * 0.05) * 100,
      x2: width/2 + cos(frameCount * 0.05 + PI) * 100,
      y2: height/2 + sin(frameCount * 0.05 + PI) * 100,
      life: 1.0,
      hue: (frameCount + eegData.alpha * 360) % 360
    });
  }
  
  // Draw and update lines
  for (let i = lines.length - 1; i >= 0; i--) {
    let line = lines[i];
    
    // Expand line
    let expansion = (1 - line.life) * eegData.attention * 50;
    let x1 = line.x1 + cos(atan2(line.y1 - height/2, line.x1 - width/2)) * expansion;
    let y1 = line.y1 + sin(atan2(line.y1 - height/2, line.x1 - width/2)) * expansion;
    let x2 = line.x2 + cos(atan2(line.y2 - height/2, line.x2 - width/2)) * expansion;
    let y2 = line.y2 + sin(atan2(line.y2 - height/2, line.x2 - width/2)) * expansion;
    
    stroke(line.hue, 70, 90, line.life);
    strokeWeight(2 + eegData.meditation * 5);
    stroke(line.hue, 70, 90, line.life);
    line(x1, y1, x2, y2);
    
    line.life -= 0.01;
    if (line.life <= 0) {
      lines.splice(i, 1);
    }
  }
}`,

            // Examples inspired by PerThirtySix creative coding
            perlinNoise: `// Perlin noise visualization with EEG control
function setup() {
  colorMode(HSB, 360, 100, 100);
  noLoop();
}

function draw() {
  background(0, 0, 10);
  
  let scale = 0.01 + eegData.alpha * 0.02;
  let detail = floor(1 + eegData.attention * 7);
  
  noiseDetail(detail, 0.5);
  
  // Draw noise field
  for (let x = 0; x < width; x += 5) {
    for (let y = 0; y < height; y += 5) {
      let noiseVal = noise(x * scale, y * scale, frameCount * 0.01);
      
      let hue = map(noiseVal, 0, 1, 180, 300);
      let brightness = map(noiseVal, 0, 1, 30, 90);
      
      fill(hue, 70, brightness);
      noStroke();
      rect(x, y, 5, 5);
    }
  }
  
  // Info
  fill(0, 0, 100);
  textAlign(LEFT, TOP);
  textSize(10);
  text("Alpha: scale | Attention: detail", 10, 10);
}

function mousePressed() {
  redraw();
}`,

            organicHeatmap: `// Organic heatmap using Perlin noise
function setup() {
  colorMode(HSB, 360, 100, 100);
  frameRate(30);
}

function draw() {
  background(0, 0, 5);
  
  let scale = 0.005 + eegData.meditation * 0.01;
  let timeOffset = frameCount * 0.02 * (1 + eegData.beta);
  
  // Create organic heatmap
  for (let x = 0; x < width; x += 8) {
    for (let y = 0; y < height; y += 8) {
      let noiseVal = noise(x * scale, y * scale, timeOffset);
      
      // Map noise to heat colors
      let hue = map(noiseVal, 0, 1, 0, 60); // Red to yellow
      let saturation = 80 + eegData.attention * 20;
      let brightness = map(noiseVal, 0, 1, 20, 90);
      
      fill(hue, saturation, brightness, 0.8);
      noStroke();
      ellipse(x, y, 10, 10);
    }
  }
}`,

            noiseDetail: `// Noise with varying detail levels
let noiseScale = 0.01;
let detailLevel = 4;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  
  // EEG controls noise detail
  detailLevel = 1 + floor(eegData.attention * 7);
  noiseScale = 0.005 + eegData.alpha * 0.015;
  
  noiseDetail(detailLevel, 0.5);
  
  // Draw noise patterns
  loadPixels();
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      let noiseVal = noise(
        x * noiseScale,
        y * noiseScale,
        frameCount * 0.01
      );
      
      let brightness = map(noiseVal, 0, 1, 0, 100);
      let hue = 200 + eegData.theta * 160;
      
      let index = (x + y * width) * 4;
      let c = color(hue, 70, brightness);
      
      pixels[index] = red(c);
      pixels[index + 1] = green(c);
      pixels[index + 2] = blue(c);
      pixels[index + 3] = 255;
    }
  }
  updatePixels();
  
  // Info overlay
  fill(0, 0, 100);
  textAlign(LEFT, TOP);
  textSize(12);
  text(\`Detail: \${detailLevel} octaves\`, 10, 10);
  text(\`Scale: \${noiseScale.toFixed(3)}\`, 10, 25);
}`,

            discreteColors: `// Discrete colors from noise
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  
  let scale = 0.01 + eegData.alpha * 0.02;
  let colorSteps = 3 + floor(eegData.attention * 7);
  
  // Draw with discrete color steps
  for (let x = 0; x < width; x += 10) {
    for (let y = 0; y < height; y += 10) {
      let noiseVal = noise(x * scale, y * scale, frameCount * 0.01);
      
      // Discretize the noise value
      let step = floor(noiseVal * colorSteps) / colorSteps;
      
      let hue = step * 360;
      let brightness = 50 + eegData.meditation * 40;
      
      fill(hue, 70, brightness);
      noStroke();
      rect(x, y, 10, 10);
    }
  }
  
  // Show color steps
  fill(0, 0, 100);
  textAlign(LEFT, TOP);
  textSize(12);
  text(\`Color steps: \${colorSteps}\`, 10, 10);
}`,

            smoothColors: `// Smooth color transitions from noise
function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  let scale = 0.005 + eegData.meditation * 0.01;
  let speed = 0.01 + eegData.beta * 0.05;
  
  // Smooth color field
  for (let x = 0; x < width; x += 5) {
    for (let y = 0; y < height; y += 5) {
      let noiseVal = noise(
        x * scale,
        y * scale,
        frameCount * speed
      );
      
      // Smooth color mapping
      let hue = noiseVal * 360;
      let saturation = 60 + eegData.alpha * 30;
      let brightness = 40 + noiseVal * 50;
      
      fill(hue, saturation, brightness);
      noStroke();
      rect(x, y, 6, 6);
    }
  }
}`,

            animatingNoise: `// Animating noise field
let time = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5, 0.1);
  
  let scale = 0.008;
  let speed = 0.02 + eegData.attention * 0.08;
  
  time += speed;
  
  // Draw animated noise
  for (let i = 0; i < 30; i++) {
    for (let j = 0; j < 30; j++) {
      let x = i * width / 30;
      let y = j * height / 30;
      
      let noiseVal = noise(
        i * scale,
        j * scale,
        time
      );
      
      let size = noiseVal * 40 * (1 + eegData.alpha);
      let hue = (noiseVal * 120 + time * 50) % 360;
      let brightness = 50 + eegData.meditation * 40;
      
      fill(hue, 70, brightness, 0.7);
      noStroke();
      ellipse(x + width/60, y + height/60, size, size);
    }
  }
}`,

            bouncingCircles: `// Bouncing circles with brain control
let circles = [];

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  // Create bouncing circles
  for (let i = 0; i < 10; i++) {
    circles.push({
      x: random(width),
      y: random(height),
      vx: random(-3, 3),
      vy: random(-3, 3),
      size: random(20, 60),
      hue: random(360)
    });
  }
}

function draw() {
  background(0, 0, 5, 0.1);
  
  for (let circle of circles) {
    // Update position with attention multiplier
    let speedMult = 0.5 + eegData.attention * 1.5;
    circle.x += circle.vx * speedMult;
    circle.y += circle.vy * speedMult;
    
    // Bounce off edges with energy from brain
    if (circle.x < 0 || circle.x > width) {
      circle.vx *= -1;
      circle.hue = (circle.hue + eegData.alpha * 60) % 360;
    }
    if (circle.y < 0 || circle.y > height) {
      circle.vy *= -1;
      circle.hue = (circle.hue + eegData.beta * 60) % 360;
    }
    
    circle.x = constrain(circle.x, 0, width);
    circle.y = constrain(circle.y, 0, height);
    
    // Draw with alpha affecting size
    let displaySize = circle.size * (0.7 + eegData.meditation * 0.6);
    fill(circle.hue, 70, 90, 0.7);
    noStroke();
    ellipse(circle.x, circle.y, displaySize);
  }
}`,

            waveAnimation: `// Wave animation controlled by brain
let waveOffset = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  
  let speed = 0.02 + eegData.beta * 0.08;
  waveOffset += speed;
  
  // Draw multiple wave layers
  for (let layer = 0; layer < 5; layer++) {
    let waveAmplitude = 30 + eegData.alpha * 70;
    let waveFrequency = 0.01 + layer * 0.005;
    let yBase = (layer + 1) * height / 6;
    
    let hue = (layer * 60 + eegData.theta * 120) % 360;
    
    fill(hue, 70, 90, 0.5);
    noStroke();
    
    beginShape();
    vertex(0, height);
    for (let x = 0; x <= width; x += 5) {
      let y = yBase + sin((x * waveFrequency) + waveOffset + layer) * waveAmplitude;
      vertex(x, y);
    }
    vertex(width, height);
    endShape(CLOSE);
  }
  
  // Draw wave on top showing meditation
  stroke(0, 0, 100);
  strokeWeight(2);
  noFill();
  
  beginShape();
  for (let x = 0; x <= width; x += 5) {
    let y = height/2 + sin((x * 0.02) + waveOffset) * 
            (50 + eegData.meditation * 100);
    vertex(x, y);
  }
  endShape();
}`,

            colorfulGrid: `// Animated colorful grid
let gridSize = 20;
let time = 0;

function setup() {
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  
  let speed = 0.05 + eegData.attention * 0.15;
  time += speed;
  
  let cols = floor(width / gridSize);
  let rows = floor(height / gridSize);
  
  for (let i = 0; i < cols; i++) {
    for (let j = 0; j < rows; j++) {
      let x = i * gridSize;
      let y = j * gridSize;
      
      // Animated properties
      let distance = dist(i, j, cols/2, rows/2);
      let offset = distance * 0.1 - time;
      
      let hue = (i * 10 + j * 10 + time * 50 + eegData.theta * 180) % 360;
      let brightness = 50 + sin(offset) * 25 + eegData.alpha * 25;
      let size = gridSize * (0.5 + (sin(offset) * 0.3 + 0.5) * 
                 (0.5 + eegData.meditation * 0.5));
      
      fill(hue, 70, brightness);
      noStroke();
      
      push();
      translate(x + gridSize/2, y + gridSize/2);
      rotate(offset);
      rectMode(CENTER);
      rect(0, 0, size, size);
      pop();
    }
  }
}`,

            webcamInput: `// Webcam input with brain-controlled effects
let capture;
let pixelDensity = 10;

function setup() {
  colorMode(HSB, 360, 100, 100);
  
  // Create video capture
  capture = createCapture(VIDEO);
  capture.size(width/pixelDensity, height/pixelDensity);
  capture.hide();
}

function draw() {
  background(0, 0, 10);
  
  capture.loadPixels();
  
  // Process webcam pixels
  for (let y = 0; y < capture.height; y++) {
    for (let x = 0; x < capture.width; x++) {
      let index = (x + y * capture.width) * 4;
      
      let r = capture.pixels[index];
      let g = capture.pixels[index + 1];
      let b = capture.pixels[index + 2];
      
      let bright = (r + g + b) / 3;
      
      // Apply brain-controlled effects
      let hueShift = eegData.alpha * 180;
      let size = map(bright, 0, 255, 0, pixelDensity * (1 + eegData.attention));
      
      let pixelHue = (bright + hueShift) % 360;
      let saturation = 60 + eegData.theta * 40;
      let pixelBrightness = map(bright, 0, 255, 20, 90);
      
      fill(pixelHue, saturation, pixelBrightness);
      noStroke();
      
      ellipse(
        x * pixelDensity + pixelDensity/2,
        y * pixelDensity + pixelDensity/2,
        size, size
      );
    }
  }
  
  // Info
  fill(0, 0, 100);
  textAlign(LEFT, BOTTOM);
  textSize(10);
  text("Alpha: hue shift | Attention: size | Theta: saturation", 10, height - 10);
  
  if (!capture.loadedmetadata) {
    textAlign(CENTER, CENTER);
    textSize(14);
    text("Waiting for webcam...", width/2, height/2);
  }
}`
          };

          if (examples[exampleName]) {
            const exampleCode = examples[exampleName];
            this.editor.setValue(exampleCode);
            this.lastLoadedCode = exampleCode;
            this.lastLoadedFilename = `${exampleName}-example.js`;
            
            // Enable reload button
            document.getElementById('reload-btn').disabled = false;
            
            this.runCode();
          }
        }
      }

      // Reference Panel Manager
      class ReferencePanel {
        constructor() {
          this.currentTab = 'p5js';
          this.setupTabs();
          this.loadContent('p5js');
        }

        setupTabs() {
          document.querySelectorAll('.reference-tab').forEach(tab => {
            tab.addEventListener('click', () => {
              // Update active tab
              document.querySelectorAll('.reference-tab').forEach(t => t.classList.remove('active'));
              tab.classList.add('active');
              
              // Load content
              const tabName = tab.dataset.tab;
              this.loadContent(tabName);
            });
          });
        }

        loadContent(tabName) {
          this.currentTab = tabName;
          const contentDiv = document.getElementById('reference-content');
          const aiAssistant = document.getElementById('ai-assistant');
          
          if (tabName === 'ai') {
            contentDiv.style.display = 'none';
            aiAssistant.style.display = 'flex';
          } else {
            contentDiv.style.display = 'block';
            aiAssistant.style.display = 'none';
            
            if (tabName === 'p5js') {
              contentDiv.innerHTML = this.renderReference(p5Reference);
            } else if (tabName === 'eeg') {
              contentDiv.innerHTML = this.renderReference(eegReference);
            }
            
            // Add click handlers for inserting code
            this.setupFunctionClicks();
          }
        }

        renderReference(reference) {
          let html = '';
          
          Object.keys(reference).forEach(groupName => {
            html += `<div class="function-group">`;
            html += `<div class="function-group-title">${groupName}</div>`;
            
            Object.keys(reference[groupName]).forEach(funcName => {
              const func = reference[groupName][funcName];
              html += `
                <div class="function-item" data-function="${funcName}">
                  <span class="function-name">${funcName}</span>
                  <div class="function-tooltip">
                    <div class="tooltip-signature">${func.signature}</div>
                    <div class="tooltip-description">${func.description}</div>
                  </div>
                </div>
              `;
            });
            
            html += `</div>`;
          });
          
          return html;
        }

        setupFunctionClicks() {
          document.querySelectorAll('.function-item').forEach(item => {
            item.addEventListener('click', () => {
              const funcName = item.dataset.function;
              if (codeEditor && codeEditor.editor) {
                // Get the function signature to extract parameters
                let signature = '';
                let reference = this.currentTab === 'p5js' ? p5Reference : eegReference;
                
                // Find the function in the reference
                for (let group in reference) {
                  if (reference[group][funcName]) {
                    signature = reference[group][funcName].signature;
                    break;
                  }
                }
                
                // Parse parameters from signature
                let snippetText = this.createSnippet(funcName, signature);
                
                // Insert as Monaco snippet with placeholders
                const position = codeEditor.editor.getPosition();
                
                // Use Monaco's snippet controller for proper tab-through behavior
                const snippetController = codeEditor.editor.getContribution('snippetController2');
                if (snippetController && snippetText.includes('${')) {
                  // Insert with snippet support (allows tab through placeholders)
                  snippetController.insert(snippetText);
                } else {
                  // Fallback to simple text insertion
                  codeEditor.editor.executeEdits('', [{
                    range: new monaco.Range(
                      position.lineNumber,
                      position.column,
                      position.lineNumber,
                      position.column
                    ),
                    text: snippetText,
                    forceMoveMarkers: true
                  }]);
                }
                
                codeEditor.editor.focus();
              }
            });
          });
        }
        
        createSnippet(funcName, signature) {
          // Extract parameters from signature
          // e.g., "ellipse(x, y, width, [height])" -> ["x", "y", "width", "[height]"]
          
          if (!signature) {
            return funcName + '()';
          }
          
          // Find the parameters part (between parentheses)
          const paramsMatch = signature.match(/\(([^)]*)\)/);
          if (!paramsMatch || !paramsMatch[1].trim()) {
            return funcName + '()';
          }
          
          const paramsStr = paramsMatch[1];
          
          // Split by comma, handling nested brackets
          const params = paramsStr.split(',').map(p => p.trim()).filter(p => p);
          
          if (params.length === 0) {
            return funcName + '()';
          }
          
          // Create snippet with numbered placeholders
          let snippetParams = params.map((param, index) => {
            // Remove brackets for optional parameters but keep the name
            let cleanParam = param.replace(/[\[\]]/g, '');
            
            // Handle "or" alternatives (e.g., "color or r, g, b")
            if (cleanParam.includes(' or ')) {
              cleanParam = cleanParam.split(' or ')[0].trim();
            }
            
            return `\${${index + 1}:${cleanParam}}`;
          }).join(', ');
          
          return `${funcName}(${snippetParams})`;
        }
      }

      // AI Assistant Manager
      class AIAssistant {
        constructor() {
          this.apiKey = localStorage.getItem('brainimation_api_key') || '';
          this.apiProvider = localStorage.getItem('brainimation_api_provider') || 'openai';
          this.setupEventListeners();
          this.updateStatus();
        }

        setupEventListeners() {
          document.getElementById('ai-generate-btn').addEventListener('click', () => {
            this.generateCode();
          });

          document.getElementById('ai-config-btn').addEventListener('click', () => {
            this.showConfig();
          });
        }

        updateStatus() {
          const statusEl = document.getElementById('ai-status');
          if (this.apiKey) {
            statusEl.textContent = `Ready to assist (${this.apiProvider})`;
            statusEl.style.color = 'var(--success)';
          } else {
            statusEl.textContent = 'Configure API key to use AI features';
            statusEl.style.color = 'var(--muted)';
          }
        }

        showConfig() {
          const provider = prompt(
            'Select API Provider:\n\n1. OpenAI (ChatGPT)\n2. Anthropic (Claude)\n\nEnter 1 or 2:',
            this.apiProvider === 'anthropic' ? '2' : '1'
          );
          
          if (provider === '1' || provider === '2') {
            this.apiProvider = provider === '2' ? 'anthropic' : 'openai';
            localStorage.setItem('brainimation_api_provider', this.apiProvider);
            
            const key = prompt(
              `Enter your ${this.apiProvider === 'openai' ? 'OpenAI' : 'Anthropic'} API key:\n\n` +
              `(stored locally in browser only)`,
              this.apiKey
            );
            
            if (key !== null) {
              this.apiKey = key.trim();
              localStorage.setItem('brainimation_api_key', this.apiKey);
              this.updateStatus();
              alert('API key saved successfully!');
            }
          }
        }

        async generateCode() {
          if (!this.apiKey) {
            alert('Please configure your API key first (click ⚙️ button)');
            return;
          }

          const prompt = document.getElementById('ai-prompt').value.trim();
          if (!prompt) {
            alert('Please describe what you want to create or modify');
            return;
          }

          const statusEl = document.getElementById('ai-status');
          const generateBtn = document.getElementById('ai-generate-btn');
          
          try {
            generateBtn.disabled = true;
            statusEl.textContent = 'Generating code...';
            statusEl.style.color = 'var(--accent)';

            const currentCode = codeEditor.editor.getValue();
            
            const systemPrompt = `You are a helpful p5.js coding assistant for BrainImation, an EEG-powered creative coding platform. 
Help users create animations that respond to brain data available through the eegData object:
- eegData.alpha, beta, theta, delta, gamma (0.0-1.0)
- eegData.attention, meditation (0.0-1.0)
- eegData.getRawChannel(channel, numSamples) for raw EEG
- eegData.connected (boolean)

Respond ONLY with JavaScript code, no explanations or markdown. Include setup() and draw() functions.`;

            const userMessage = prompt + (currentCode ? `\n\nCurrent code:\n${currentCode}` : '');

            let generatedCode = '';

            if (this.apiProvider === 'openai') {
              const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${this.apiKey}`
                },
                body: JSON.stringify({
                  model: 'gpt-4',
                  messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userMessage }
                  ],
                  temperature: 0.7,
                  max_tokens: 2000
                })
              });

              if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
              }

              const data = await response.json();
              generatedCode = data.choices[0].message.content;
            } else if (this.apiProvider === 'anthropic') {
              const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-api-key': this.apiKey,
                  'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                  model: 'claude-3-5-sonnet-20241022',
                  max_tokens: 2000,
                  system: systemPrompt,
                  messages: [
                    { role: 'user', content: userMessage }
                  ]
                })
              });

              if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
              }

              const data = await response.json();
              generatedCode = data.content[0].text;
            }

            // Clean up code (remove markdown fences if present)
            generatedCode = generatedCode.replace(/```javascript\n?/g, '').replace(/```\n?/g, '').trim();

            // Insert into editor
            codeEditor.editor.setValue(generatedCode);
            
            statusEl.textContent = 'Code generated! Running...';
            statusEl.style.color = 'var(--success)';
            
            // Auto-run the generated code
            setTimeout(() => {
              codeEditor.runCode();
              statusEl.textContent = `Ready to assist (${this.apiProvider})`;
            }, 500);

          } catch (error) {
            console.error('AI generation error:', error);
            statusEl.textContent = `Error: ${error.message}`;
            statusEl.style.color = 'var(--error)';
            alert(`Failed to generate code:\n${error.message}\n\nPlease check your API key and try again.`);
          } finally {
            generateBtn.disabled = false;
          }
        }
      }

      // Code Panel Tab Manager
      class CodePanelTabs {
        constructor() {
          this.currentTab = 'code';
          this.setupTabs();
        }

        setupTabs() {
          document.querySelectorAll('.code-panel-tab').forEach(tab => {
            tab.addEventListener('click', () => {
              const panelName = tab.dataset.panel;
              this.switchTab(panelName);
            });
          });
        }

        switchTab(panelName) {
          this.currentTab = panelName;
          
          // Update tab styling
          document.querySelectorAll('.code-panel-tab').forEach(tab => {
            if (tab.dataset.panel === panelName) {
              tab.classList.add('active');
            } else {
              tab.classList.remove('active');
            }
          });

          // Update view visibility
          document.querySelectorAll('.code-panel-view').forEach(view => {
            if (view.id === `${panelName}-view`) {
              view.classList.add('active');
            } else {
              view.classList.remove('active');
            }
          });

          // If switching to log, scroll to bottom
          if (panelName === 'log') {
            const logMessages = document.getElementById('log-messages');
            if (logMessages) {
              logMessages.scrollTop = logMessages.scrollHeight;
            }
          }
        }
      }

      // Application initialization
      let museManager;
      let eegSimulator;
      let codeEditor;
      let referencePanel;
      let aiAssistant;
      let codePanelTabs;
      let currentDataSource = null; // 'muse' or 'simulator'

      function initApp() {
        museManager = new MuseEEGManager();
        eegSimulator = new EEGSimulator();
        codeEditor = new CodeEditor();
        referencePanel = new ReferencePanel();
        aiAssistant = new AIAssistant();
        codePanelTabs = new CodePanelTabs();

        // Toggle reference panel
        document.getElementById('toggle-reference-btn').addEventListener('click', () => {
          const mainContainer = document.querySelector('.main-container');
          const referencePanel = document.getElementById('reference-panel');
          const btn = document.getElementById('toggle-reference-btn');
          
          if (mainContainer.classList.contains('hide-reference')) {
            mainContainer.classList.remove('hide-reference');
            btn.textContent = '📖 Reference';
          } else {
            mainContainer.classList.add('hide-reference');
            btn.textContent = '📖 Show Reference';
          }
        });

        // Event listeners
        const connectBtn = document.getElementById('connect-btn');
        
        connectBtn.addEventListener('click', async () => {
          // If already connected, disconnect
          if (currentDataSource === 'muse' && museManager.isConnected) {
            console.log('User requested disconnect');
            museManager.disconnect();
            currentDataSource = null;
            connectBtn.textContent = 'Connect Muse';
            connectBtn.disabled = false;
            document.getElementById('simulate-btn').disabled = false;
            return;
          }
          
          // Stop simulation if running
          if (currentDataSource === 'simulator') {
            console.log('Stopping simulation before Muse connection');
            stopSimulation();
          }
          
          // Attempt to connect
          connectBtn.disabled = true;
          connectBtn.textContent = 'Connecting...';
          
          try {
            await museManager.connect();
            currentDataSource = 'muse';
            connectBtn.textContent = 'Disconnect Muse';
            connectBtn.disabled = false;
            document.getElementById('simulate-btn').disabled = true;
            console.log('Connection successful, button updated');
          } catch (error) {
            console.error('Connection failed:', error);
            connectBtn.textContent = 'Connect Muse';
            connectBtn.disabled = false;
            currentDataSource = null;
            document.getElementById('simulate-btn').disabled = false;
          }
        });

        document.getElementById('simulate-btn').addEventListener('click', () => {
          if (currentDataSource === 'muse') {
            museManager.disconnect();
          }
          
          if (currentDataSource === 'simulator') {
            stopSimulation();
          } else {
            startSimulation();
          }
        });

        document.getElementById('run-btn').addEventListener('click', () => {
          codeEditor.runCode();
        });

        // Save button
        document.getElementById('save-btn').addEventListener('click', () => {
          codeEditor.saveCode();
        });

        // Load button - trigger file input
        document.getElementById('load-btn').addEventListener('click', () => {
          document.getElementById('file-input').click();
        });

        // File input change handler
        document.getElementById('file-input').addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (file) {
            codeEditor.loadCodeFromFile(file);
          }
          // Reset input so same file can be loaded again
          e.target.value = '';
        });

        // Reload button
        document.getElementById('reload-btn').addEventListener('click', () => {
          codeEditor.reloadCode();
        });

        document.getElementById('fullscreen-btn').addEventListener('click', async () => {
          const container = document.getElementById('canvas-container');
          
          try {
            if (!document.fullscreenElement) {
              // Enter fullscreen mode
              await container.requestFullscreen();
              document.getElementById('fullscreen-btn').textContent = 'Exit Fullscreen';
            } else {
              // Exit fullscreen mode
              await document.exitFullscreen();
              document.getElementById('fullscreen-btn').textContent = 'Fullscreen';
            }
          } catch (error) {
            console.error('Fullscreen error:', error);
            alert('Fullscreen mode is not supported or was blocked. Please try pressing F11 or allow fullscreen permissions.');
          }
        });

        // Example selector dropdown
        document.getElementById('example-selector').addEventListener('change', (e) => {
          const exampleName = e.target.value;
          if (exampleName) {
            codeEditor.loadExample(exampleName);
          }
        });

        // Simulation control sliders
        const attentionSlider = document.getElementById('sim-attention');
        const meditationSlider = document.getElementById('sim-meditation');
        const attentionVal = document.getElementById('sim-attention-val');
        const meditationVal = document.getElementById('sim-meditation-val');
        
        attentionSlider.addEventListener('input', (e) => {
          const value = e.target.value;
          attentionVal.textContent = value;
          if (eegSimulator && eegSimulator.isRunning) {
            eegSimulator.setAttention(value);
          }
        });
        
        meditationSlider.addEventListener('input', (e) => {
          const value = e.target.value;
          meditationVal.textContent = value;
          if (eegSimulator && eegSimulator.isRunning) {
            eegSimulator.setMeditation(value);
          }
        });

        // Listen for fullscreen changes (e.g., when user presses ESC)
        document.addEventListener('fullscreenchange', () => {
          const btn = document.getElementById('fullscreen-btn');
          if (document.fullscreenElement) {
            btn.textContent = 'Exit Fullscreen';
          } else {
            btn.textContent = 'Fullscreen';
          }
        });

        // Check for Web Bluetooth support first
        if (!navigator.bluetooth) {
          logger.log('⚠️ Web Bluetooth is not supported in this browser', 'error');
          logger.log('Please use Chrome, Edge, or Opera to connect to Muse devices', 'warning');
          document.getElementById('connect-btn').disabled = true;
          document.getElementById('connect-btn').title = 'Web Bluetooth not supported in this browser';
          museManager.updateStatus('Bluetooth not supported', 'error');
        } else {
          logger.log('✅ Web Bluetooth is supported in this browser', 'success');
        }
        
        // Check if muse-js library loaded successfully
        logger.log('🔍 Checking muse-js library...', 'info');
        
        if (window.muse && window.muse.MuseClient) {
          logger.log('✅ muse-js library is ready!', 'success');
          document.getElementById('connect-btn').disabled = false;
          museManager.updateStatus('Ready to connect', '');
          logger.log('Click "Connect Muse" to pair with your device', 'info');
        } else {
          logger.log('❌ muse-js library failed to load!', 'error');
          logger.log('Check your internet connection and refresh the page', 'warning');
          document.getElementById('connect-btn').disabled = true;
          museManager.updateStatus('muse-js library error', 'error');
        }
        
        logger.log('🧠 BrainImation initialized successfully!', 'success');
      }

      // Simulation control functions
      function startSimulation() {
        logger.log('🎮 Starting EEG data simulation...', 'info');
        eegSimulator.start();
        currentDataSource = 'simulator';
        
        document.getElementById('simulate-btn').textContent = 'Stop Simulation';
        document.getElementById('connect-btn').disabled = true;
        document.getElementById('sim-controls').style.display = 'block';
        document.getElementById('status-text').textContent = 'Simulating EEG Data';
        document.getElementById('muse-status').className = 'status-indicator connected';
        
        // Initialize with current slider values
        eegSimulator.setAttention(document.getElementById('sim-attention').value);
        eegSimulator.setMeditation(document.getElementById('sim-meditation').value);
        
        logger.log('✅ Simulation active - Use sliders to control brain wave parameters', 'success');
      }

      function stopSimulation() {
        logger.log('🎮 Stopping EEG data simulation...', 'info');
        eegSimulator.stop();
        currentDataSource = null;
        
        document.getElementById('simulate-btn').textContent = 'Simulate Data';
        document.getElementById('connect-btn').disabled = false;
        document.getElementById('sim-controls').style.display = 'none';
        document.getElementById('status-text').textContent = 'Disconnected';
        document.getElementById('muse-status').className = 'status-indicator';
        
        // Reset eegData
        Object.keys(eegData).forEach(key => {
          if (typeof eegData[key] === 'number') {
            eegData[key] = 0;
          } else if (Array.isArray(eegData[key])) {
            eegData[key] = [0, 0, 0, 0];
          } else if (key === 'connected') {
            eegData[key] = false;
          } else if (key === 'rawHistory') {
            eegData[key] = { TP9: [], AF7: [], AF8: [], TP10: [] };
          }
        });
        
        // Update display
        document.getElementById('alpha-value').textContent = '0.0';
        document.getElementById('beta-value').textContent = '0.0';
        document.getElementById('theta-value').textContent = '0.0';
        document.getElementById('delta-value').textContent = '0.0';
        
        logger.log('✅ Simulation stopped', 'success');
      }

      // Global error handler
      window.showError = function(message) {
        codeEditor?.showError(message);
      };

      // Start the application
      window.addEventListener('load', initApp);
    </script>
  </body>
</html>
